System.registerDynamic("client/lib/main.js", ["npm:rx@3.0.1.js", "client/lib/api.js", "npm:lodash@3.10.1.js", "npm:video.js@4.12.13/dist/video-js/video.dev.js", "npm:plex-api-headers@1.1.0.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var rx_1 = require("npm:rx@3.0.1.js");
  var api_1 = require("client/lib/api.js");
  var lodash_1 = require("npm:lodash@3.10.1.js");
  var videojs = require("npm:video.js@4.12.13/dist/video-js/video.dev.js");
  var plexApiHeaders = require("npm:plex-api-headers@1.1.0.js");
  var played = new Set();
  var api = new api_1.PlexAPI({
    hostname: "rainbowdash",
    port: 32400,
    options: {identifier: "kids-player-123"}
  });
  var a = api.query("/library/sections");
  rx_1.Observable.fromPromise(a).flatMap(function(response) {
    console.log(response);
    var kidsSections = lodash_1.filter(response.directory, function(x) {
      return lodash_1.startsWith(x.title, "Kids ");
    });
    return rx_1.Observable.from(kidsSections).flatMap(function(x) {
      var path = "/library/sections/" + x.key;
      return rx_1.Observable.fromPromise(api.query(path)).map(function(response) {
        return ({
          path: path,
          response: response
        });
      });
    }).flatMap(function(_a) {
      var response = _a.response,
          path = _a.path;
      console.log(response);
      var sections = lodash_1.filter(response.directory, function(x) {
        return lodash_1.contains(['all', 'newest', 'recentlyAdded'], x.key);
      });
      var results = rx_1.Observable.from(sections).flatMap(function(z) {
        var a = path + "/" + z.key;
        return rx_1.Observable.fromPromise(api.query(a)).map(function(response) {
          return ({
            a: a,
            response: response
          });
        });
      });
      results.subscribe(function(x) {
        console.log(x);
      });
      return results.concatMap(function(x) {
        return x.response.video || [];
      }).where(function(x) {
        var media = x.media;
        if (media && media.part && !lodash_1.has(media.part, 'optimizedForStreaming')) {
          return true;
        }
        return false;
      });
    });
  }).toArray().subscribe(function(items) {
    playNext(items);
  });
  function playNext(items) {
    var next = items.splice(lodash_1.random(0, items.length - 1), 1)[0];
    openVideo(api, next, function() {
      return playNext(items);
    });
  }
  function openVideo(api, video, cb) {
    var media = video.media;
    var playerOptions = {
      controls: true,
      height: '100%',
      width: '100%'
    };
    var videoElement = document.createElement('video');
    videoElement.src = "" + api.serverUrl + media.part.key;
    videoElement.autoplay = true;
    videoElement.dataset['name'] = video.title;
    videoElement.classList.add('video-js');
    videoElement.classList.add('vjs-default-skin');
    videoElement.classList.add('vjs-full-window');
    document.body.appendChild(videoElement);
    var player = videojs(videoElement, playerOptions, function() {
      var _this = this;
      this.on('ended', function() {
        lodash_1.defer(function() {
          _this.dispose();
          cb();
        });
      });
      this.on('error', function() {
        lodash_1.defer(function() {
          _this.dispose();
          cb();
        });
      });
    });
  }
  var b = api.query("/");
  rx_1.Observable.fromPromise(b).subscribe(function(response) {
    console.log(response);
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1.js", ["npm:rx@3.0.1/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:rx@3.0.1/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:plex-api-headers@1.1.0.js", ["npm:plex-api-headers@1.1.0/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:plex-api-headers@1.1.0/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1.js", ["npm:lodash@3.10.1/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:lodash@3.10.1/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("client/lib/api.js", ["npm:uuid@2.0.1.js", "npm:url@0.10.3.js", "npm:bluebird@2.9.34.js", "npm:xml2js@0.4.10.js", "npm:plex-api-headers@1.1.0.js", "client/lib/uri.js", "client/lib/credentials.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var uuid = require("npm:uuid@2.0.1.js");
  var url = require("npm:url@0.10.3.js");
  var Promise = require("npm:bluebird@2.9.34.js");
  var xml2js = require("npm:xml2js@0.4.10.js");
  var plexApiHeaders = require("npm:plex-api-headers@1.1.0.js");
  var uri = require("client/lib/uri.js");
  var credentials_1 = require("client/lib/credentials.js");
  var PLEX_SERVER_PORT = 32400;
  var PlexAPI = (function() {
    function PlexAPI(settings) {
      var _this = this;
      this.getHostname = function() {
        return _this.hostname;
      };
      this.getPort = function() {
        return _this.port;
      };
      this.getIdentifier = function() {
        return _this.options.identifier;
      };
      this.hostname = settings.hostname;
      this.port = settings.port || PLEX_SERVER_PORT;
      this.username = settings.username;
      this.password = settings.password;
      this.authenticator = settings.authenticator || this._credentialsAuthenticator();
      this.options = settings.options;
      this.options.identifier = this.options.identifier || uuid.v4();
      this.options.product = this.options.product || 'Node.js App';
      this.options.version = this.options.version || '1.0';
      this.options.device = this.options.device || "Awesome";
      this.options.deviceName = this.options.deviceName || 'Node.js App';
      this.options.platform = this.options.platform || 'Node.js';
      this.options.platformVersion = this.options.platformVersion || '1.0';
      this.serverUrl = 'http://' + this.hostname + ':' + this.port;
      this._initializeAuthenticator();
    }
    PlexAPI.prototype.query = function(url) {
      if (url === undefined) {
        throw new TypeError('Requires url argument');
      }
      return this._request(url, 'GET', true).then(uri.attach(url));
    };
    PlexAPI.prototype.postQuery = function(url) {
      if (url === undefined) {
        throw new TypeError('Requires url argument');
      }
      return this._request(url, 'POST', true).then(uri.attach(url));
    };
    PlexAPI.prototype.perform = function(url) {
      if (url === undefined) {
        throw new TypeError('Requires url argument');
      }
      return this._request(url, 'GET', false);
    };
    PlexAPI.prototype._request = function(relativeUrl, method, parseResponse) {
      var _this = this;
      var reqUrl = generateRelativeUrl.call(this, relativeUrl);
      var headers = new Headers(plexApiHeaders(this, {
        'Accept': 'application/json',
        'X-Plex-Token': this.authToken,
        'X-Plex-Username': this.username
      }));
      return new Promise(function(resolve, reject) {
        window.fetch(reqUrl, {
          method: method || 'GET',
          headers: headers
        }).then(function(response) {
          if (response.status === 401) {
            if (_this.authenticator === undefined) {
              return reject(new Error('Plex Server denied request, you must provide a way to authenticate! ' + 'Read more about plex-api authenticators on https://www.npmjs.com/package/plex-api#authenticators'));
            }
            return resolve(_this._authenticate().then(function() {
              return this._request(relativeUrl, method, parseResponse);
            }));
          }
          if (response.status !== 200) {
            return reject(new Error('Plex Server didnt respond with status code 200, response code: ' + response.status));
          }
          if (parseResponse) {
            if (response.headers.get('content-type') === 'application/json') {
              return response.json().then(resolve, reject);
            }
            if (response.headers.get('content-type').indexOf('xml') > -1) {
              return response.text().then(function(text) {
                return xml2js.parseString(text, {
                  object: true,
                  mergeAttrs: true,
                  explicitArray: false,
                  explicitRoot: false,
                  tagNameProcessors: [xml2js.processors.firstCharLowerCase],
                  attrNameProcessors: [xml2js.processors.firstCharLowerCase],
                  valueProcessors: [xml2js.processors.parseNumbers, xml2js.processors.parseBooleans]
                }, function(err, result) {
                  if (err)
                    reject(err);
                  resolve(result);
                });
              }, reject);
            }
            return response.text().then(function(x) {
              return resolve(x);
            }, reject);
          } else {
            return resolve();
          }
        });
      });
    };
    PlexAPI.prototype._authenticate = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        if (_this.authToken) {
          return reject(new Error('Permission denied even after attempted authentication :( Wrong username and/or password maybe?'));
        }
        _this.authenticator.authenticate(_this.options, function(err, token) {
          if (err) {
            return reject(new Error('Authentication failed, reason: ' + err.message));
          }
          _this.authToken = token;
          resolve();
        });
      });
    };
    PlexAPI.prototype._credentialsAuthenticator = function() {
      if (this.username && this.password) {
        return credentials_1.default({
          username: this.username,
          password: this.password
        });
      }
      return undefined;
    };
    PlexAPI.prototype._initializeAuthenticator = function() {
      if (this.authenticator && typeof this.authenticator.initialize === 'function') {
        this.authenticator.initialize(this);
      }
    };
    return PlexAPI;
  })();
  exports.PlexAPI = PlexAPI;
  function generateRelativeUrl(relativeUrl) {
    return this.serverUrl + relativeUrl;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/index.js", ["npm:rx@3.0.1/dist/rx.js", "npm:rx@3.0.1/dist/rx.aggregates.js", "npm:rx@3.0.1/dist/rx.async.js", "npm:rx@3.0.1/dist/rx.backpressure.js", "npm:rx@3.0.1/dist/rx.binding.js", "npm:rx@3.0.1/dist/rx.coincidence.js", "npm:rx@3.0.1/dist/rx.experimental.js", "npm:rx@3.0.1/dist/rx.joinpatterns.js", "npm:rx@3.0.1/dist/rx.sorting.js", "npm:rx@3.0.1/dist/rx.virtualtime.js", "npm:rx@3.0.1/dist/rx.testing.js", "npm:rx@3.0.1/dist/rx.time.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@3.0.1/dist/rx.js");
  require("npm:rx@3.0.1/dist/rx.aggregates.js");
  require("npm:rx@3.0.1/dist/rx.async.js");
  require("npm:rx@3.0.1/dist/rx.backpressure.js");
  require("npm:rx@3.0.1/dist/rx.binding.js");
  require("npm:rx@3.0.1/dist/rx.coincidence.js");
  require("npm:rx@3.0.1/dist/rx.experimental.js");
  require("npm:rx@3.0.1/dist/rx.joinpatterns.js");
  require("npm:rx@3.0.1/dist/rx.sorting.js");
  require("npm:rx@3.0.1/dist/rx.virtualtime.js");
  require("npm:rx@3.0.1/dist/rx.testing.js");
  require("npm:rx@3.0.1/dist/rx.time.js");
  module.exports = Rx;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:plex-api-headers@1.1.0/index.js", ["github:jspm/nodelibs-util@0.1.0.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var extend = require("github:jspm/nodelibs-util@0.1.0.js")._extend;
  function withoutNulls(obj) {
    return obj && Object.keys(obj).reduce(function(sum, curr) {
      if (typeof obj[curr] === 'string') {
        sum[curr] = obj[curr];
      }
      return sum;
    }, {});
  }
  module.exports = function headers(plexApi, extraHeaders) {
    if (typeof plexApi !== 'object') {
      throw new TypeError('A PlexAPI object containing .options is required');
    }
    var options = plexApi.options;
    extraHeaders = withoutNulls(extraHeaders) || {};
    return extend(extraHeaders, {
      'X-Plex-Client-Identifier': options.identifier,
      'X-Plex-Product': options.product,
      'X-Plex-Version': options.version,
      'X-Plex-Device': options.device,
      'X-Plex-Device-Name': options.deviceName,
      'X-Plex-Platform': options.platform,
      'X-Plex-Platform-Version': options.platformVersion,
      'X-Plex-Provides': 'controller'
    });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:video.js@4.12.13/dist/video-js/video.dev.js", ["github:jspm/nodelibs-buffer@0.1.0.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(Buffer, process) {
    document.createElement('video');
    document.createElement('audio');
    document.createElement('track');
    var vjs = function(id, options, ready) {
      var tag;
      if (typeof id === 'string') {
        if (id.indexOf('#') === 0) {
          id = id.slice(1);
        }
        if (vjs.players[id]) {
          if (options) {
            vjs.log.warn('Player "' + id + '" is already initialised. Options will not be applied.');
          }
          if (ready) {
            vjs.players[id].ready(ready);
          }
          return vjs.players[id];
        } else {
          tag = vjs.el(id);
        }
      } else {
        tag = id;
      }
      if (!tag || !tag.nodeName) {
        throw new TypeError('The element or ID supplied is not valid. (videojs)');
      }
      return tag['player'] || new vjs.Player(tag, options, ready);
    };
    var videojs = window['videojs'] = vjs;
    vjs.CDN_VERSION = '4.12';
    vjs.ACCESS_PROTOCOL = ('https:' == document.location.protocol ? 'https://' : 'http://');
    vjs['VERSION'] = '4.12.13';
    vjs.options = {
      'techOrder': ['html5', 'flash'],
      'html5': {},
      'flash': {},
      'width': 300,
      'height': 150,
      'defaultVolume': 0.00,
      'playbackRates': [],
      'inactivityTimeout': 2000,
      'children': {
        'mediaLoader': {},
        'posterImage': {},
        'loadingSpinner': {},
        'textTrackDisplay': {},
        'bigPlayButton': {},
        'controlBar': {},
        'errorDisplay': {},
        'textTrackSettings': {}
      },
      'language': document.getElementsByTagName('html')[0].getAttribute('lang') || navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',
      'languages': {},
      'notSupportedMessage': 'No compatible source was found for this video.'
    };
    if (vjs.CDN_VERSION !== 'GENERATED' + '_CDN_VSN') {
      videojs.options['flash']['swf'] = vjs.ACCESS_PROTOCOL + 'vjs.zencdn.net/' + vjs.CDN_VERSION + '/video-js.swf';
    }
    vjs.addLanguage = function(code, data) {
      if (vjs.options['languages'][code] !== undefined) {
        vjs.options['languages'][code] = vjs.util.mergeOptions(vjs.options['languages'][code], data);
      } else {
        vjs.options['languages'][code] = data;
      }
      return vjs.options['languages'];
    };
    vjs.players = {};
    if (typeof define === 'function' && define['amd']) {
      define('videojs', [], function() {
        return videojs;
      });
    } else if (typeof exports === 'object' && typeof module === 'object') {
      module['exports'] = videojs;
    }
    vjs.CoreObject = vjs['CoreObject'] = function() {};
    vjs.CoreObject.extend = function(props) {
      var init,
          subObj;
      props = props || {};
      init = props['init'] || props.init || this.prototype['init'] || this.prototype.init || function() {};
      subObj = function() {
        init.apply(this, arguments);
      };
      subObj.prototype = vjs.obj.create(this.prototype);
      subObj.prototype.constructor = subObj;
      subObj.extend = vjs.CoreObject.extend;
      subObj.create = vjs.CoreObject.create;
      for (var name in props) {
        if (props.hasOwnProperty(name)) {
          subObj.prototype[name] = props[name];
        }
      }
      return subObj;
    };
    vjs.CoreObject.create = function() {
      var inst = vjs.obj.create(this.prototype);
      this.apply(inst, arguments);
      return inst;
    };
    vjs.on = function(elem, type, fn) {
      if (vjs.obj.isArray(type)) {
        return _handleMultipleEvents(vjs.on, elem, type, fn);
      }
      var data = vjs.getData(elem);
      if (!data.handlers)
        data.handlers = {};
      if (!data.handlers[type])
        data.handlers[type] = [];
      if (!fn.guid)
        fn.guid = vjs.guid++;
      data.handlers[type].push(fn);
      if (!data.dispatcher) {
        data.disabled = false;
        data.dispatcher = function(event) {
          if (data.disabled)
            return;
          event = vjs.fixEvent(event);
          var handlers = data.handlers[event.type];
          if (handlers) {
            var handlersCopy = handlers.slice(0);
            for (var m = 0,
                n = handlersCopy.length; m < n; m++) {
              if (event.isImmediatePropagationStopped()) {
                break;
              } else {
                handlersCopy[m].call(elem, event);
              }
            }
          }
        };
      }
      if (data.handlers[type].length == 1) {
        if (elem.addEventListener) {
          elem.addEventListener(type, data.dispatcher, false);
        } else if (elem.attachEvent) {
          elem.attachEvent('on' + type, data.dispatcher);
        }
      }
    };
    vjs.off = function(elem, type, fn) {
      if (!vjs.hasData(elem))
        return;
      var data = vjs.getData(elem);
      if (!data.handlers) {
        return;
      }
      if (vjs.obj.isArray(type)) {
        return _handleMultipleEvents(vjs.off, elem, type, fn);
      }
      var removeType = function(t) {
        data.handlers[t] = [];
        vjs.cleanUpEvents(elem, t);
      };
      if (!type) {
        for (var t in data.handlers)
          removeType(t);
        return;
      }
      var handlers = data.handlers[type];
      if (!handlers)
        return;
      if (!fn) {
        removeType(type);
        return;
      }
      if (fn.guid) {
        for (var n = 0; n < handlers.length; n++) {
          if (handlers[n].guid === fn.guid) {
            handlers.splice(n--, 1);
          }
        }
      }
      vjs.cleanUpEvents(elem, type);
    };
    vjs.cleanUpEvents = function(elem, type) {
      var data = vjs.getData(elem);
      if (data.handlers[type].length === 0) {
        delete data.handlers[type];
        if (elem.removeEventListener) {
          elem.removeEventListener(type, data.dispatcher, false);
        } else if (elem.detachEvent) {
          elem.detachEvent('on' + type, data.dispatcher);
        }
      }
      if (vjs.isEmpty(data.handlers)) {
        delete data.handlers;
        delete data.dispatcher;
        delete data.disabled;
      }
      if (vjs.isEmpty(data)) {
        vjs.removeData(elem);
      }
    };
    vjs.fixEvent = function(event) {
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      if (!event || !event.isPropagationStopped) {
        var old = event || window.event;
        event = {};
        for (var key in old) {
          if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation') {
            if (!(key == 'returnValue' && old.preventDefault)) {
              event[key] = old[key];
            }
          }
        }
        if (!event.target) {
          event.target = event.srcElement || document;
        }
        event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
        event.preventDefault = function() {
          if (old.preventDefault) {
            old.preventDefault();
          }
          event.returnValue = false;
          event.isDefaultPrevented = returnTrue;
          event.defaultPrevented = true;
        };
        event.isDefaultPrevented = returnFalse;
        event.defaultPrevented = false;
        event.stopPropagation = function() {
          if (old.stopPropagation) {
            old.stopPropagation();
          }
          event.cancelBubble = true;
          event.isPropagationStopped = returnTrue;
        };
        event.isPropagationStopped = returnFalse;
        event.stopImmediatePropagation = function() {
          if (old.stopImmediatePropagation) {
            old.stopImmediatePropagation();
          }
          event.isImmediatePropagationStopped = returnTrue;
          event.stopPropagation();
        };
        event.isImmediatePropagationStopped = returnFalse;
        if (event.clientX != null) {
          var doc = document.documentElement,
              body = document.body;
          event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        event.which = event.charCode || event.keyCode;
        if (event.button != null) {
          event.button = (event.button & 1 ? 0 : (event.button & 4 ? 1 : (event.button & 2 ? 2 : 0)));
        }
      }
      return event;
    };
    vjs.trigger = function(elem, event) {
      var elemData = (vjs.hasData(elem)) ? vjs.getData(elem) : {};
      var parent = elem.parentNode || elem.ownerDocument;
      if (typeof event === 'string') {
        event = {
          type: event,
          target: elem
        };
      }
      event = vjs.fixEvent(event);
      if (elemData.dispatcher) {
        elemData.dispatcher.call(elem, event);
      }
      if (parent && !event.isPropagationStopped() && event.bubbles !== false) {
        vjs.trigger(parent, event);
      } else if (!parent && !event.defaultPrevented) {
        var targetData = vjs.getData(event.target);
        if (event.target[event.type]) {
          targetData.disabled = true;
          if (typeof event.target[event.type] === 'function') {
            event.target[event.type]();
          }
          targetData.disabled = false;
        }
      }
      return !event.defaultPrevented;
    };
    vjs.one = function(elem, type, fn) {
      if (vjs.obj.isArray(type)) {
        return _handleMultipleEvents(vjs.one, elem, type, fn);
      }
      var func = function() {
        vjs.off(elem, type, func);
        fn.apply(this, arguments);
      };
      func.guid = fn.guid = fn.guid || vjs.guid++;
      vjs.on(elem, type, func);
    };
    function _handleMultipleEvents(fn, elem, type, callback) {
      vjs.arr.forEach(type, function(type) {
        fn(elem, type, callback);
      });
    }
    var hasOwnProp = Object.prototype.hasOwnProperty;
    vjs.createEl = function(tagName, properties) {
      var el;
      tagName = tagName || 'div';
      properties = properties || {};
      el = document.createElement(tagName);
      vjs.obj.each(properties, function(propName, val) {
        if (propName.indexOf('aria-') !== -1 || propName == 'role') {
          el.setAttribute(propName, val);
        } else {
          el[propName] = val;
        }
      });
      return el;
    };
    vjs.capitalize = function(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };
    vjs.obj = {};
    vjs.obj.create = Object.create || function(obj) {
      function F() {}
      F.prototype = obj;
      return new F();
    };
    vjs.obj.each = function(obj, fn, context) {
      for (var key in obj) {
        if (hasOwnProp.call(obj, key)) {
          fn.call(context || this, key, obj[key]);
        }
      }
    };
    vjs.obj.merge = function(obj1, obj2) {
      if (!obj2) {
        return obj1;
      }
      for (var key in obj2) {
        if (hasOwnProp.call(obj2, key)) {
          obj1[key] = obj2[key];
        }
      }
      return obj1;
    };
    vjs.obj.deepMerge = function(obj1, obj2) {
      var key,
          val1,
          val2;
      obj1 = vjs.obj.copy(obj1);
      for (key in obj2) {
        if (hasOwnProp.call(obj2, key)) {
          val1 = obj1[key];
          val2 = obj2[key];
          if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
            obj1[key] = vjs.obj.deepMerge(val1, val2);
          } else {
            obj1[key] = obj2[key];
          }
        }
      }
      return obj1;
    };
    vjs.obj.copy = function(obj) {
      return vjs.obj.merge({}, obj);
    };
    vjs.obj.isPlain = function(obj) {
      return !!obj && typeof obj === 'object' && obj.toString() === '[object Object]' && obj.constructor === Object;
    };
    vjs.obj.isArray = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) === '[object Array]';
    };
    vjs.isNaN = function(num) {
      return num !== num;
    };
    vjs.bind = function(context, fn, uid) {
      if (!fn.guid) {
        fn.guid = vjs.guid++;
      }
      var ret = function() {
        return fn.apply(context, arguments);
      };
      ret.guid = (uid) ? uid + '_' + fn.guid : fn.guid;
      return ret;
    };
    vjs.cache = {};
    vjs.guid = 1;
    vjs.expando = 'vdata' + (new Date()).getTime();
    vjs.getData = function(el) {
      var id = el[vjs.expando];
      if (!id) {
        id = el[vjs.expando] = vjs.guid++;
      }
      if (!vjs.cache[id]) {
        vjs.cache[id] = {};
      }
      return vjs.cache[id];
    };
    vjs.hasData = function(el) {
      var id = el[vjs.expando];
      return !(!id || vjs.isEmpty(vjs.cache[id]));
    };
    vjs.removeData = function(el) {
      var id = el[vjs.expando];
      if (!id) {
        return;
      }
      delete vjs.cache[id];
      try {
        delete el[vjs.expando];
      } catch (e) {
        if (el.removeAttribute) {
          el.removeAttribute(vjs.expando);
        } else {
          el[vjs.expando] = null;
        }
      }
    };
    vjs.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj[prop] !== null) {
          return false;
        }
      }
      return true;
    };
    vjs.hasClass = function(element, classToCheck) {
      return ((' ' + element.className + ' ').indexOf(' ' + classToCheck + ' ') !== -1);
    };
    vjs.addClass = function(element, classToAdd) {
      if (!vjs.hasClass(element, classToAdd)) {
        element.className = element.className === '' ? classToAdd : element.className + ' ' + classToAdd;
      }
    };
    vjs.removeClass = function(element, classToRemove) {
      var classNames,
          i;
      if (!vjs.hasClass(element, classToRemove)) {
        return;
      }
      classNames = element.className.split(' ');
      for (i = classNames.length - 1; i >= 0; i--) {
        if (classNames[i] === classToRemove) {
          classNames.splice(i, 1);
        }
      }
      element.className = classNames.join(' ');
    };
    vjs.TEST_VID = vjs.createEl('video');
    (function() {
      var track = document.createElement('track');
      track.kind = 'captions';
      track.srclang = 'en';
      track.label = 'English';
      vjs.TEST_VID.appendChild(track);
    })();
    vjs.USER_AGENT = navigator.userAgent;
    vjs.IS_IPHONE = (/iPhone/i).test(vjs.USER_AGENT);
    vjs.IS_IPAD = (/iPad/i).test(vjs.USER_AGENT);
    vjs.IS_IPOD = (/iPod/i).test(vjs.USER_AGENT);
    vjs.IS_IOS = vjs.IS_IPHONE || vjs.IS_IPAD || vjs.IS_IPOD;
    vjs.IOS_VERSION = (function() {
      var match = vjs.USER_AGENT.match(/OS (\d+)_/i);
      if (match && match[1]) {
        return match[1];
      }
    })();
    vjs.IS_ANDROID = (/Android/i).test(vjs.USER_AGENT);
    vjs.ANDROID_VERSION = (function() {
      var match = vjs.USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i),
          major,
          minor;
      if (!match) {
        return null;
      }
      major = match[1] && parseFloat(match[1]);
      minor = match[2] && parseFloat(match[2]);
      if (major && minor) {
        return parseFloat(match[1] + '.' + match[2]);
      } else if (major) {
        return major;
      } else {
        return null;
      }
    })();
    vjs.IS_OLD_ANDROID = vjs.IS_ANDROID && (/webkit/i).test(vjs.USER_AGENT) && vjs.ANDROID_VERSION < 2.3;
    vjs.IS_FIREFOX = (/Firefox/i).test(vjs.USER_AGENT);
    vjs.IS_CHROME = (/Chrome/i).test(vjs.USER_AGENT);
    vjs.IS_IE8 = (/MSIE\s8\.0/).test(vjs.USER_AGENT);
    vjs.TOUCH_ENABLED = !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch);
    vjs.BACKGROUND_SIZE_SUPPORTED = 'backgroundSize' in vjs.TEST_VID.style;
    vjs.setElementAttributes = function(el, attributes) {
      vjs.obj.each(attributes, function(attrName, attrValue) {
        if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
          el.removeAttribute(attrName);
        } else {
          el.setAttribute(attrName, (attrValue === true ? '' : attrValue));
        }
      });
    };
    vjs.getElementAttributes = function(tag) {
      var obj,
          knownBooleans,
          attrs,
          attrName,
          attrVal;
      obj = {};
      knownBooleans = ',' + 'autoplay,controls,loop,muted,default' + ',';
      if (tag && tag.attributes && tag.attributes.length > 0) {
        attrs = tag.attributes;
        for (var i = attrs.length - 1; i >= 0; i--) {
          attrName = attrs[i].name;
          attrVal = attrs[i].value;
          if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
            attrVal = (attrVal !== null) ? true : false;
          }
          obj[attrName] = attrVal;
        }
      }
      return obj;
    };
    vjs.getComputedDimension = function(el, strCssRule) {
      var strValue = '';
      if (document.defaultView && document.defaultView.getComputedStyle) {
        strValue = document.defaultView.getComputedStyle(el, '').getPropertyValue(strCssRule);
      } else if (el.currentStyle) {
        strValue = el['client' + strCssRule.substr(0, 1).toUpperCase() + strCssRule.substr(1)] + 'px';
      }
      return strValue;
    };
    vjs.insertFirst = function(child, parent) {
      if (parent.firstChild) {
        parent.insertBefore(child, parent.firstChild);
      } else {
        parent.appendChild(child);
      }
    };
    vjs.browser = {};
    vjs.el = function(id) {
      if (id.indexOf('#') === 0) {
        id = id.slice(1);
      }
      return document.getElementById(id);
    };
    vjs.formatTime = function(seconds, guide) {
      guide = guide || seconds;
      var s = Math.floor(seconds % 60),
          m = Math.floor(seconds / 60 % 60),
          h = Math.floor(seconds / 3600),
          gm = Math.floor(guide / 60 % 60),
          gh = Math.floor(guide / 3600);
      if (isNaN(seconds) || seconds === Infinity) {
        h = m = s = '-';
      }
      h = (h > 0 || gh > 0) ? h + ':' : '';
      m = (((h || gm >= 10) && m < 10) ? '0' + m : m) + ':';
      s = (s < 10) ? '0' + s : s;
      return h + m + s;
    };
    vjs.blockTextSelection = function() {
      document.body.focus();
      document.onselectstart = function() {
        return false;
      };
    };
    vjs.unblockTextSelection = function() {
      document.onselectstart = function() {
        return true;
      };
    };
    vjs.trim = function(str) {
      return (str + '').replace(/^\s+|\s+$/g, '');
    };
    vjs.round = function(num, dec) {
      if (!dec) {
        dec = 0;
      }
      return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
    };
    vjs.createTimeRange = function(start, end) {
      if (start === undefined && end === undefined) {
        return {
          length: 0,
          start: function() {
            throw new Error('This TimeRanges object is empty');
          },
          end: function() {
            throw new Error('This TimeRanges object is empty');
          }
        };
      }
      return {
        length: 1,
        start: function() {
          return start;
        },
        end: function() {
          return end;
        }
      };
    };
    vjs.setLocalStorage = function(key, value) {
      try {
        var localStorage = window.localStorage || false;
        if (!localStorage) {
          return;
        }
        localStorage[key] = value;
      } catch (e) {
        if (e.code == 22 || e.code == 1014) {
          vjs.log('LocalStorage Full (VideoJS)', e);
        } else {
          if (e.code == 18) {
            vjs.log('LocalStorage not allowed (VideoJS)', e);
          } else {
            vjs.log('LocalStorage Error (VideoJS)', e);
          }
        }
      }
    };
    vjs.getAbsoluteURL = function(url) {
      if (!url.match(/^https?:\/\//)) {
        url = vjs.createEl('div', {innerHTML: '<a href="' + url + '">x</a>'}).firstChild.href;
      }
      return url;
    };
    vjs.parseUrl = function(url) {
      var div,
          a,
          addToBody,
          props,
          details;
      props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];
      a = vjs.createEl('a', {href: url});
      addToBody = (a.host === '' && a.protocol !== 'file:');
      if (addToBody) {
        div = vjs.createEl('div');
        div.innerHTML = '<a href="' + url + '"></a>';
        a = div.firstChild;
        div.setAttribute('style', 'display:none; position:absolute;');
        document.body.appendChild(div);
      }
      details = {};
      for (var i = 0; i < props.length; i++) {
        details[props[i]] = a[props[i]];
      }
      if (details.protocol === 'http:') {
        details.host = details.host.replace(/:80$/, '');
      }
      if (details.protocol === 'https:') {
        details.host = details.host.replace(/:443$/, '');
      }
      if (addToBody) {
        document.body.removeChild(div);
      }
      return details;
    };
    function _logType(type, args) {
      var argsArray,
          noop,
          console;
      argsArray = Array.prototype.slice.call(args);
      noop = function() {};
      console = window['console'] || {
        'log': noop,
        'warn': noop,
        'error': noop
      };
      if (type) {
        argsArray.unshift(type.toUpperCase() + ':');
      } else {
        type = 'log';
      }
      vjs.log.history.push(argsArray);
      argsArray.unshift('VIDEOJS:');
      if (console[type].apply) {
        console[type].apply(console, argsArray);
      } else {
        console[type](argsArray.join(' '));
      }
    }
    vjs.log = function() {
      _logType(null, arguments);
    };
    vjs.log.history = [];
    vjs.log.error = function() {
      _logType('error', arguments);
    };
    vjs.log.warn = function() {
      _logType('warn', arguments);
    };
    vjs.findPosition = function(el) {
      var box,
          docEl,
          body,
          clientLeft,
          scrollLeft,
          left,
          clientTop,
          scrollTop,
          top;
      if (el.getBoundingClientRect && el.parentNode) {
        box = el.getBoundingClientRect();
      }
      if (!box) {
        return {
          left: 0,
          top: 0
        };
      }
      docEl = document.documentElement;
      body = document.body;
      clientLeft = docEl.clientLeft || body.clientLeft || 0;
      scrollLeft = window.pageXOffset || body.scrollLeft;
      left = box.left + scrollLeft - clientLeft;
      clientTop = docEl.clientTop || body.clientTop || 0;
      scrollTop = window.pageYOffset || body.scrollTop;
      top = box.top + scrollTop - clientTop;
      return {
        left: vjs.round(left),
        top: vjs.round(top)
      };
    };
    vjs.arr = {};
    vjs.arr.forEach = function(array, callback, thisArg) {
      if (vjs.obj.isArray(array) && callback instanceof Function) {
        for (var i = 0,
            len = array.length; i < len; ++i) {
          callback.call(thisArg || vjs, array[i], i, array);
        }
      }
      return array;
    };
    vjs.xhr = function(options, callback) {
      var XHR,
          request,
          urlInfo,
          winLoc,
          fileUrl,
          crossOrigin,
          abortTimeout,
          successHandler,
          errorHandler;
      if (typeof options === 'string') {
        options = {uri: options};
      }
      videojs.util.mergeOptions({
        method: 'GET',
        timeout: 45 * 1000
      }, options);
      callback = callback || function() {};
      successHandler = function() {
        window.clearTimeout(abortTimeout);
        callback(null, request, request.response || request.responseText);
      };
      errorHandler = function(err) {
        window.clearTimeout(abortTimeout);
        if (!err || typeof err === 'string') {
          err = new Error(err);
        }
        callback(err, request);
      };
      XHR = window.XMLHttpRequest;
      if (typeof XHR === 'undefined') {
        XHR = function() {
          try {
            return new window.ActiveXObject('Msxml2.XMLHTTP.6.0');
          } catch (e) {}
          try {
            return new window.ActiveXObject('Msxml2.XMLHTTP.3.0');
          } catch (f) {}
          try {
            return new window.ActiveXObject('Msxml2.XMLHTTP');
          } catch (g) {}
          throw new Error('This browser does not support XMLHttpRequest.');
        };
      }
      request = new XHR();
      request.uri = options.uri;
      urlInfo = vjs.parseUrl(options.uri);
      winLoc = window.location;
      crossOrigin = (urlInfo.protocol + urlInfo.host) !== (winLoc.protocol + winLoc.host);
      if (crossOrigin && window.XDomainRequest && !('withCredentials' in request)) {
        request = new window.XDomainRequest();
        request.onload = successHandler;
        request.onerror = errorHandler;
        request.onprogress = function() {};
        request.ontimeout = function() {};
      } else {
        fileUrl = (urlInfo.protocol == 'file:' || winLoc.protocol == 'file:');
        request.onreadystatechange = function() {
          if (request.readyState === 4) {
            if (request.timedout) {
              return errorHandler('timeout');
            }
            if (request.status === 200 || fileUrl && request.status === 0) {
              successHandler();
            } else {
              errorHandler();
            }
          }
        };
        if (options.timeout) {
          abortTimeout = window.setTimeout(function() {
            if (request.readyState !== 4) {
              request.timedout = true;
              request.abort();
            }
          }, options.timeout);
        }
      }
      try {
        request.open(options.method || 'GET', options.uri, true);
      } catch (err) {
        return errorHandler(err);
      }
      if (options.withCredentials) {
        request.withCredentials = true;
      }
      if (options.responseType) {
        request.responseType = options.responseType;
      }
      try {
        request.send();
      } catch (err) {
        return errorHandler(err);
      }
      return request;
    };
    vjs.util = {};
    vjs.util.mergeOptions = function(obj1, obj2) {
      var key,
          val1,
          val2;
      obj1 = vjs.obj.copy(obj1);
      for (key in obj2) {
        if (obj2.hasOwnProperty(key)) {
          val1 = obj1[key];
          val2 = obj2[key];
          if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
            obj1[key] = vjs.util.mergeOptions(val1, val2);
          } else {
            obj1[key] = obj2[key];
          }
        }
      }
      return obj1;
    };
    vjs.EventEmitter = function() {};
    vjs.EventEmitter.prototype.allowedEvents_ = {};
    vjs.EventEmitter.prototype.on = function(type, fn) {
      var ael = this.addEventListener;
      this.addEventListener = Function.prototype;
      vjs.on(this, type, fn);
      this.addEventListener = ael;
    };
    vjs.EventEmitter.prototype.addEventListener = vjs.EventEmitter.prototype.on;
    vjs.EventEmitter.prototype.off = function(type, fn) {
      vjs.off(this, type, fn);
    };
    vjs.EventEmitter.prototype.removeEventListener = vjs.EventEmitter.prototype.off;
    vjs.EventEmitter.prototype.one = function(type, fn) {
      vjs.one(this, type, fn);
    };
    vjs.EventEmitter.prototype.trigger = function(event) {
      var type = event.type || event;
      if (typeof event === 'string') {
        event = {type: type};
      }
      event = vjs.fixEvent(event);
      if (this.allowedEvents_[type] && this['on' + type]) {
        this['on' + type](event);
      }
      vjs.trigger(this, event);
    };
    vjs.EventEmitter.prototype.dispatchEvent = vjs.EventEmitter.prototype.trigger;
    vjs.Component = vjs.CoreObject.extend({init: function(player, options, ready) {
        this.player_ = player;
        this.options_ = vjs.obj.copy(this.options_);
        options = this.options(options);
        this.id_ = options['id'] || (options['el'] && options['el']['id']);
        if (!this.id_) {
          this.id_ = ((player.id && player.id()) || 'no_player') + '_component_' + vjs.guid++;
        }
        this.name_ = options['name'] || null;
        this.el_ = options['el'] || this.createEl();
        this.children_ = [];
        this.childIndex_ = {};
        this.childNameIndex_ = {};
        this.initChildren();
        this.ready(ready);
        if (options.reportTouchActivity !== false) {
          this.enableTouchActivity();
        }
      }});
    vjs.Component.prototype.dispose = function() {
      this.trigger({
        type: 'dispose',
        'bubbles': false
      });
      if (this.children_) {
        for (var i = this.children_.length - 1; i >= 0; i--) {
          if (this.children_[i].dispose) {
            this.children_[i].dispose();
          }
        }
      }
      this.children_ = null;
      this.childIndex_ = null;
      this.childNameIndex_ = null;
      this.off();
      if (this.el_.parentNode) {
        this.el_.parentNode.removeChild(this.el_);
      }
      vjs.removeData(this.el_);
      this.el_ = null;
    };
    vjs.Component.prototype.player_ = true;
    vjs.Component.prototype.player = function() {
      return this.player_;
    };
    vjs.Component.prototype.options_;
    vjs.Component.prototype.options = function(obj) {
      if (obj === undefined)
        return this.options_;
      return this.options_ = vjs.util.mergeOptions(this.options_, obj);
    };
    vjs.Component.prototype.el_;
    vjs.Component.prototype.createEl = function(tagName, attributes) {
      return vjs.createEl(tagName, attributes);
    };
    vjs.Component.prototype.localize = function(string) {
      var lang = this.player_.language(),
          languages = this.player_.languages();
      if (languages && languages[lang] && languages[lang][string]) {
        return languages[lang][string];
      }
      return string;
    };
    vjs.Component.prototype.el = function() {
      return this.el_;
    };
    vjs.Component.prototype.contentEl_;
    vjs.Component.prototype.contentEl = function() {
      return this.contentEl_ || this.el_;
    };
    vjs.Component.prototype.id_;
    vjs.Component.prototype.id = function() {
      return this.id_;
    };
    vjs.Component.prototype.name_;
    vjs.Component.prototype.name = function() {
      return this.name_;
    };
    vjs.Component.prototype.children_;
    vjs.Component.prototype.children = function() {
      return this.children_;
    };
    vjs.Component.prototype.childIndex_;
    vjs.Component.prototype.getChildById = function(id) {
      return this.childIndex_[id];
    };
    vjs.Component.prototype.childNameIndex_;
    vjs.Component.prototype.getChild = function(name) {
      return this.childNameIndex_[name];
    };
    vjs.Component.prototype.addChild = function(child, options) {
      var component,
          componentClass,
          componentName;
      if (typeof child === 'string') {
        componentName = child;
        options = options || {};
        componentClass = options['componentClass'] || vjs.capitalize(componentName);
        options['name'] = componentName;
        component = new window['videojs'][componentClass](this.player_ || this, options);
      } else {
        component = child;
      }
      this.children_.push(component);
      if (typeof component.id === 'function') {
        this.childIndex_[component.id()] = component;
      }
      componentName = componentName || (component.name && component.name());
      if (componentName) {
        this.childNameIndex_[componentName] = component;
      }
      if (typeof component['el'] === 'function' && component['el']()) {
        this.contentEl().appendChild(component['el']());
      }
      return component;
    };
    vjs.Component.prototype.removeChild = function(component) {
      if (typeof component === 'string') {
        component = this.getChild(component);
      }
      if (!component || !this.children_)
        return;
      var childFound = false;
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i] === component) {
          childFound = true;
          this.children_.splice(i, 1);
          break;
        }
      }
      if (!childFound)
        return;
      this.childIndex_[component.id()] = null;
      this.childNameIndex_[component.name()] = null;
      var compEl = component.el();
      if (compEl && compEl.parentNode === this.contentEl()) {
        this.contentEl().removeChild(component.el());
      }
    };
    vjs.Component.prototype.initChildren = function() {
      var parent,
          parentOptions,
          children,
          child,
          name,
          opts,
          handleAdd;
      parent = this;
      parentOptions = parent.options();
      children = parentOptions['children'];
      if (children) {
        handleAdd = function(name, opts) {
          if (parentOptions[name] !== undefined) {
            opts = parentOptions[name];
          }
          if (opts === false)
            return;
          parent[name] = parent.addChild(name, opts);
        };
        if (vjs.obj.isArray(children)) {
          for (var i = 0; i < children.length; i++) {
            child = children[i];
            if (typeof child == 'string') {
              name = child;
              opts = {};
            } else {
              name = child.name;
              opts = child;
            }
            handleAdd(name, opts);
          }
        } else {
          vjs.obj.each(children, handleAdd);
        }
      }
    };
    vjs.Component.prototype.buildCSSClass = function() {
      return '';
    };
    vjs.Component.prototype.on = function(first, second, third) {
      var target,
          type,
          fn,
          removeOnDispose,
          cleanRemover,
          thisComponent;
      if (typeof first === 'string' || vjs.obj.isArray(first)) {
        vjs.on(this.el_, first, vjs.bind(this, second));
      } else {
        target = first;
        type = second;
        fn = vjs.bind(this, third);
        thisComponent = this;
        removeOnDispose = function() {
          thisComponent.off(target, type, fn);
        };
        removeOnDispose.guid = fn.guid;
        this.on('dispose', removeOnDispose);
        cleanRemover = function() {
          thisComponent.off('dispose', removeOnDispose);
        };
        cleanRemover.guid = fn.guid;
        if (first.nodeName) {
          vjs.on(target, type, fn);
          vjs.on(target, 'dispose', cleanRemover);
        } else if (typeof first.on === 'function') {
          target.on(type, fn);
          target.on('dispose', cleanRemover);
        }
      }
      return this;
    };
    vjs.Component.prototype.off = function(first, second, third) {
      var target,
          otherComponent,
          type,
          fn,
          otherEl;
      if (!first || typeof first === 'string' || vjs.obj.isArray(first)) {
        vjs.off(this.el_, first, second);
      } else {
        target = first;
        type = second;
        fn = vjs.bind(this, third);
        this.off('dispose', fn);
        if (first.nodeName) {
          vjs.off(target, type, fn);
          vjs.off(target, 'dispose', fn);
        } else {
          target.off(type, fn);
          target.off('dispose', fn);
        }
      }
      return this;
    };
    vjs.Component.prototype.one = function(first, second, third) {
      var target,
          type,
          fn,
          thisComponent,
          newFunc;
      if (typeof first === 'string' || vjs.obj.isArray(first)) {
        vjs.one(this.el_, first, vjs.bind(this, second));
      } else {
        target = first;
        type = second;
        fn = vjs.bind(this, third);
        thisComponent = this;
        newFunc = function() {
          thisComponent.off(target, type, newFunc);
          fn.apply(this, arguments);
        };
        newFunc.guid = fn.guid;
        this.on(target, type, newFunc);
      }
      return this;
    };
    vjs.Component.prototype.trigger = function(event) {
      vjs.trigger(this.el_, event);
      return this;
    };
    vjs.Component.prototype.isReady_;
    vjs.Component.prototype.isReadyOnInitFinish_ = true;
    vjs.Component.prototype.readyQueue_;
    vjs.Component.prototype.ready = function(fn) {
      if (fn) {
        if (this.isReady_) {
          fn.call(this);
        } else {
          if (this.readyQueue_ === undefined) {
            this.readyQueue_ = [];
          }
          this.readyQueue_.push(fn);
        }
      }
      return this;
    };
    vjs.Component.prototype.triggerReady = function() {
      this.isReady_ = true;
      var readyQueue = this.readyQueue_;
      this.readyQueue_ = [];
      if (readyQueue && readyQueue.length > 0) {
        for (var i = 0,
            j = readyQueue.length; i < j; i++) {
          readyQueue[i].call(this);
        }
        this.trigger('ready');
      }
    };
    vjs.Component.prototype.hasClass = function(classToCheck) {
      return vjs.hasClass(this.el_, classToCheck);
    };
    vjs.Component.prototype.addClass = function(classToAdd) {
      vjs.addClass(this.el_, classToAdd);
      return this;
    };
    vjs.Component.prototype.removeClass = function(classToRemove) {
      vjs.removeClass(this.el_, classToRemove);
      return this;
    };
    vjs.Component.prototype.show = function() {
      this.removeClass('vjs-hidden');
      return this;
    };
    vjs.Component.prototype.hide = function() {
      this.addClass('vjs-hidden');
      return this;
    };
    vjs.Component.prototype.lockShowing = function() {
      this.addClass('vjs-lock-showing');
      return this;
    };
    vjs.Component.prototype.unlockShowing = function() {
      this.removeClass('vjs-lock-showing');
      return this;
    };
    vjs.Component.prototype.disable = function() {
      this.hide();
      this.show = function() {};
    };
    vjs.Component.prototype.width = function(num, skipListeners) {
      return this.dimension('width', num, skipListeners);
    };
    vjs.Component.prototype.height = function(num, skipListeners) {
      return this.dimension('height', num, skipListeners);
    };
    vjs.Component.prototype.dimensions = function(width, height) {
      return this.width(width, true).height(height);
    };
    vjs.Component.prototype.dimension = function(widthOrHeight, num, skipListeners) {
      if (num !== undefined) {
        if (num === null || vjs.isNaN(num)) {
          num = 0;
        }
        if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
          this.el_.style[widthOrHeight] = num;
        } else if (num === 'auto') {
          this.el_.style[widthOrHeight] = '';
        } else {
          this.el_.style[widthOrHeight] = num + 'px';
        }
        if (!skipListeners) {
          this.trigger('resize');
        }
        return this;
      }
      if (!this.el_)
        return 0;
      var val = this.el_.style[widthOrHeight];
      var pxIndex = val.indexOf('px');
      if (pxIndex !== -1) {
        return parseInt(val.slice(0, pxIndex), 10);
      } else {
        return parseInt(this.el_['offset' + vjs.capitalize(widthOrHeight)], 10);
      }
    };
    vjs.Component.prototype.onResize;
    vjs.Component.prototype.emitTapEvents = function() {
      var touchStart,
          firstTouch,
          touchTime,
          couldBeTap,
          noTap,
          xdiff,
          ydiff,
          touchDistance,
          tapMovementThreshold,
          touchTimeThreshold;
      touchStart = 0;
      firstTouch = null;
      tapMovementThreshold = 10;
      touchTimeThreshold = 200;
      this.on('touchstart', function(event) {
        if (event.touches.length === 1) {
          firstTouch = vjs.obj.copy(event.touches[0]);
          touchStart = new Date().getTime();
          couldBeTap = true;
        }
      });
      this.on('touchmove', function(event) {
        if (event.touches.length > 1) {
          couldBeTap = false;
        } else if (firstTouch) {
          xdiff = event.touches[0].pageX - firstTouch.pageX;
          ydiff = event.touches[0].pageY - firstTouch.pageY;
          touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
          if (touchDistance > tapMovementThreshold) {
            couldBeTap = false;
          }
        }
      });
      noTap = function() {
        couldBeTap = false;
      };
      this.on('touchleave', noTap);
      this.on('touchcancel', noTap);
      this.on('touchend', function(event) {
        firstTouch = null;
        if (couldBeTap === true) {
          touchTime = new Date().getTime() - touchStart;
          if (touchTime < touchTimeThreshold) {
            event.preventDefault();
            this.trigger('tap');
          }
        }
      });
    };
    vjs.Component.prototype.enableTouchActivity = function() {
      var report,
          touchHolding,
          touchEnd;
      if (!this.player().reportUserActivity) {
        return;
      }
      report = vjs.bind(this.player(), this.player().reportUserActivity);
      this.on('touchstart', function() {
        report();
        this.clearInterval(touchHolding);
        touchHolding = this.setInterval(report, 250);
      });
      touchEnd = function(event) {
        report();
        this.clearInterval(touchHolding);
      };
      this.on('touchmove', report);
      this.on('touchend', touchEnd);
      this.on('touchcancel', touchEnd);
    };
    vjs.Component.prototype.setTimeout = function(fn, timeout) {
      fn = vjs.bind(this, fn);
      var timeoutId = setTimeout(fn, timeout);
      var disposeFn = function() {
        this.clearTimeout(timeoutId);
      };
      disposeFn.guid = 'vjs-timeout-' + timeoutId;
      this.on('dispose', disposeFn);
      return timeoutId;
    };
    vjs.Component.prototype.clearTimeout = function(timeoutId) {
      clearTimeout(timeoutId);
      var disposeFn = function() {};
      disposeFn.guid = 'vjs-timeout-' + timeoutId;
      this.off('dispose', disposeFn);
      return timeoutId;
    };
    vjs.Component.prototype.setInterval = function(fn, interval) {
      fn = vjs.bind(this, fn);
      var intervalId = setInterval(fn, interval);
      var disposeFn = function() {
        this.clearInterval(intervalId);
      };
      disposeFn.guid = 'vjs-interval-' + intervalId;
      this.on('dispose', disposeFn);
      return intervalId;
    };
    vjs.Component.prototype.clearInterval = function(intervalId) {
      clearInterval(intervalId);
      var disposeFn = function() {};
      disposeFn.guid = 'vjs-interval-' + intervalId;
      this.off('dispose', disposeFn);
      return intervalId;
    };
    vjs.Button = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
        this.emitTapEvents();
        this.on('tap', this.onClick);
        this.on('click', this.onClick);
        this.on('focus', this.onFocus);
        this.on('blur', this.onBlur);
      }});
    vjs.Button.prototype.createEl = function(type, props) {
      var el;
      props = vjs.obj.merge({
        className: this.buildCSSClass(),
        'role': 'button',
        'aria-live': 'polite',
        tabIndex: 0
      }, props);
      el = vjs.Component.prototype.createEl.call(this, type, props);
      if (!props.innerHTML) {
        this.contentEl_ = vjs.createEl('div', {className: 'vjs-control-content'});
        this.controlText_ = vjs.createEl('span', {
          className: 'vjs-control-text',
          innerHTML: this.localize(this.buttonText) || 'Need Text'
        });
        this.contentEl_.appendChild(this.controlText_);
        el.appendChild(this.contentEl_);
      }
      return el;
    };
    vjs.Button.prototype.buildCSSClass = function() {
      return 'vjs-control ' + vjs.Component.prototype.buildCSSClass.call(this);
    };
    vjs.Button.prototype.onClick = function() {};
    vjs.Button.prototype.onFocus = function() {
      vjs.on(document, 'keydown', vjs.bind(this, this.onKeyPress));
    };
    vjs.Button.prototype.onKeyPress = function(event) {
      if (event.which == 32 || event.which == 13) {
        event.preventDefault();
        this.onClick();
      }
    };
    vjs.Button.prototype.onBlur = function() {
      vjs.off(document, 'keydown', vjs.bind(this, this.onKeyPress));
    };
    vjs.Slider = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
        this.bar = this.getChild(this.options_['barName']);
        this.handle = this.getChild(this.options_['handleName']);
        this.on('mousedown', this.onMouseDown);
        this.on('touchstart', this.onMouseDown);
        this.on('focus', this.onFocus);
        this.on('blur', this.onBlur);
        this.on('click', this.onClick);
        this.on(player, 'controlsvisible', this.update);
        this.on(player, this.playerEvent, this.update);
      }});
    vjs.Slider.prototype.createEl = function(type, props) {
      props = props || {};
      props.className = props.className + ' vjs-slider';
      props = vjs.obj.merge({
        'role': 'slider',
        'aria-valuenow': 0,
        'aria-valuemin': 0,
        'aria-valuemax': 100,
        tabIndex: 0
      }, props);
      return vjs.Component.prototype.createEl.call(this, type, props);
    };
    vjs.Slider.prototype.onMouseDown = function(event) {
      event.preventDefault();
      vjs.blockTextSelection();
      this.addClass('vjs-sliding');
      this.on(document, 'mousemove', this.onMouseMove);
      this.on(document, 'mouseup', this.onMouseUp);
      this.on(document, 'touchmove', this.onMouseMove);
      this.on(document, 'touchend', this.onMouseUp);
      this.onMouseMove(event);
    };
    vjs.Slider.prototype.onMouseMove = function() {};
    vjs.Slider.prototype.onMouseUp = function() {
      vjs.unblockTextSelection();
      this.removeClass('vjs-sliding');
      this.off(document, 'mousemove', this.onMouseMove);
      this.off(document, 'mouseup', this.onMouseUp);
      this.off(document, 'touchmove', this.onMouseMove);
      this.off(document, 'touchend', this.onMouseUp);
      this.update();
    };
    vjs.Slider.prototype.update = function() {
      if (!this.el_)
        return;
      var barProgress,
          progress = this.getPercent(),
          handle = this.handle,
          bar = this.bar;
      if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {
        progress = 0;
      }
      barProgress = progress;
      if (handle) {
        var box = this.el_,
            boxWidth = box.offsetWidth,
            handleWidth = handle.el().offsetWidth,
            handlePercent = (handleWidth) ? handleWidth / boxWidth : 0,
            boxAdjustedPercent = 1 - handlePercent,
            adjustedProgress = progress * boxAdjustedPercent;
        barProgress = adjustedProgress + (handlePercent / 2);
        handle.el().style.left = vjs.round(adjustedProgress * 100, 2) + '%';
      }
      if (bar) {
        bar.el().style.width = vjs.round(barProgress * 100, 2) + '%';
      }
    };
    vjs.Slider.prototype.calculateDistance = function(event) {
      var el,
          box,
          boxX,
          boxY,
          boxW,
          boxH,
          handle,
          pageX,
          pageY;
      el = this.el_;
      box = vjs.findPosition(el);
      boxW = boxH = el.offsetWidth;
      handle = this.handle;
      if (this.options()['vertical']) {
        boxY = box.top;
        if (event.changedTouches) {
          pageY = event.changedTouches[0].pageY;
        } else {
          pageY = event.pageY;
        }
        if (handle) {
          var handleH = handle.el().offsetHeight;
          boxY = boxY + (handleH / 2);
          boxH = boxH - handleH;
        }
        return Math.max(0, Math.min(1, ((boxY - pageY) + boxH) / boxH));
      } else {
        boxX = box.left;
        if (event.changedTouches) {
          pageX = event.changedTouches[0].pageX;
        } else {
          pageX = event.pageX;
        }
        if (handle) {
          var handleW = handle.el().offsetWidth;
          boxX = boxX + (handleW / 2);
          boxW = boxW - handleW;
        }
        return Math.max(0, Math.min(1, (pageX - boxX) / boxW));
      }
    };
    vjs.Slider.prototype.onFocus = function() {
      this.on(document, 'keydown', this.onKeyPress);
    };
    vjs.Slider.prototype.onKeyPress = function(event) {
      if (event.which == 37 || event.which == 40) {
        event.preventDefault();
        this.stepBack();
      } else if (event.which == 38 || event.which == 39) {
        event.preventDefault();
        this.stepForward();
      }
    };
    vjs.Slider.prototype.onBlur = function() {
      this.off(document, 'keydown', this.onKeyPress);
    };
    vjs.Slider.prototype.onClick = function(event) {
      event.stopImmediatePropagation();
      event.preventDefault();
    };
    vjs.SliderHandle = vjs.Component.extend();
    vjs.SliderHandle.prototype.defaultValue = 0;
    vjs.SliderHandle.prototype.createEl = function(type, props) {
      props = props || {};
      props.className = props.className + ' vjs-slider-handle';
      props = vjs.obj.merge({innerHTML: '<span class="vjs-control-text">' + this.defaultValue + '</span>'}, props);
      return vjs.Component.prototype.createEl.call(this, 'div', props);
    };
    vjs.Menu = vjs.Component.extend();
    vjs.Menu.prototype.addItem = function(component) {
      this.addChild(component);
      component.on('click', vjs.bind(this, function() {
        this.unlockShowing();
      }));
    };
    vjs.Menu.prototype.createEl = function() {
      var contentElType = this.options().contentElType || 'ul';
      this.contentEl_ = vjs.createEl(contentElType, {className: 'vjs-menu-content'});
      var el = vjs.Component.prototype.createEl.call(this, 'div', {
        append: this.contentEl_,
        className: 'vjs-menu'
      });
      el.appendChild(this.contentEl_);
      vjs.on(el, 'click', function(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      });
      return el;
    };
    vjs.MenuItem = vjs.Button.extend({init: function(player, options) {
        vjs.Button.call(this, player, options);
        this.selected(options['selected']);
      }});
    vjs.MenuItem.prototype.createEl = function(type, props) {
      return vjs.Button.prototype.createEl.call(this, 'li', vjs.obj.merge({
        className: 'vjs-menu-item',
        innerHTML: this.localize(this.options_['label'])
      }, props));
    };
    vjs.MenuItem.prototype.onClick = function() {
      this.selected(true);
    };
    vjs.MenuItem.prototype.selected = function(selected) {
      if (selected) {
        this.addClass('vjs-selected');
        this.el_.setAttribute('aria-selected', true);
      } else {
        this.removeClass('vjs-selected');
        this.el_.setAttribute('aria-selected', false);
      }
    };
    vjs.MenuButton = vjs.Button.extend({init: function(player, options) {
        vjs.Button.call(this, player, options);
        this.update();
        this.on('keydown', this.onKeyPress);
        this.el_.setAttribute('aria-haspopup', true);
        this.el_.setAttribute('role', 'button');
      }});
    vjs.MenuButton.prototype.update = function() {
      var menu = this.createMenu();
      if (this.menu) {
        this.removeChild(this.menu);
      }
      this.menu = menu;
      this.addChild(menu);
      if (this.items && this.items.length === 0) {
        this.hide();
      } else if (this.items && this.items.length > 1) {
        this.show();
      }
    };
    vjs.MenuButton.prototype.buttonPressed_ = false;
    vjs.MenuButton.prototype.createMenu = function() {
      var menu = new vjs.Menu(this.player_);
      if (this.options().title) {
        menu.contentEl().appendChild(vjs.createEl('li', {
          className: 'vjs-menu-title',
          innerHTML: vjs.capitalize(this.options().title),
          tabindex: -1
        }));
      }
      this.items = this['createItems']();
      if (this.items) {
        for (var i = 0; i < this.items.length; i++) {
          menu.addItem(this.items[i]);
        }
      }
      return menu;
    };
    vjs.MenuButton.prototype.createItems = function() {};
    vjs.MenuButton.prototype.buildCSSClass = function() {
      return this.className + ' vjs-menu-button ' + vjs.Button.prototype.buildCSSClass.call(this);
    };
    vjs.MenuButton.prototype.onFocus = function() {};
    vjs.MenuButton.prototype.onBlur = function() {};
    vjs.MenuButton.prototype.onClick = function() {
      this.one('mouseout', vjs.bind(this, function() {
        this.menu.unlockShowing();
        this.el_.blur();
      }));
      if (this.buttonPressed_) {
        this.unpressButton();
      } else {
        this.pressButton();
      }
    };
    vjs.MenuButton.prototype.onKeyPress = function(event) {
      if (event.which == 32 || event.which == 13) {
        if (this.buttonPressed_) {
          this.unpressButton();
        } else {
          this.pressButton();
        }
        event.preventDefault();
      } else if (event.which == 27) {
        if (this.buttonPressed_) {
          this.unpressButton();
        }
        event.preventDefault();
      }
    };
    vjs.MenuButton.prototype.pressButton = function() {
      this.buttonPressed_ = true;
      this.menu.lockShowing();
      this.el_.setAttribute('aria-pressed', true);
      if (this.items && this.items.length > 0) {
        this.items[0].el().focus();
      }
    };
    vjs.MenuButton.prototype.unpressButton = function() {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.el_.setAttribute('aria-pressed', false);
    };
    vjs.MediaError = function(code) {
      if (typeof code === 'number') {
        this.code = code;
      } else if (typeof code === 'string') {
        this.message = code;
      } else if (typeof code === 'object') {
        vjs.obj.merge(this, code);
      }
      if (!this.message) {
        this.message = vjs.MediaError.defaultMessages[this.code] || '';
      }
    };
    vjs.MediaError.prototype.code = 0;
    vjs.MediaError.prototype.message = '';
    vjs.MediaError.prototype.status = null;
    vjs.MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];
    vjs.MediaError.defaultMessages = {
      1: 'You aborted the video playback',
      2: 'A network error caused the video download to fail part-way.',
      3: 'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',
      4: 'The video could not be loaded, either because the server or network failed or because the format is not supported.',
      5: 'The video is encrypted and we do not have the keys to decrypt it.'
    };
    for (var errNum = 0; errNum < vjs.MediaError.errorTypes.length; errNum++) {
      vjs.MediaError[vjs.MediaError.errorTypes[errNum]] = errNum;
      vjs.MediaError.prototype[vjs.MediaError.errorTypes[errNum]] = errNum;
    }
    (function() {
      var apiMap,
          specApi,
          browserApi,
          i;
      vjs.browser.fullscreenAPI;
      apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'], ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'], ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'], ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'], ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];
      specApi = apiMap[0];
      for (i = 0; i < apiMap.length; i++) {
        if (apiMap[i][1] in document) {
          browserApi = apiMap[i];
          break;
        }
      }
      if (browserApi) {
        vjs.browser.fullscreenAPI = {};
        for (i = 0; i < browserApi.length; i++) {
          vjs.browser.fullscreenAPI[specApi[i]] = browserApi[i];
        }
      }
    })();
    vjs.Player = vjs.Component.extend({init: function(tag, options, ready) {
        this.tag = tag;
        tag.id = tag.id || 'vjs_video_' + vjs.guid++;
        this.tagAttributes = tag && vjs.getElementAttributes(tag);
        options = vjs.obj.merge(this.getTagSettings(tag), options);
        this.language_ = options['language'] || vjs.options['language'];
        this.languages_ = options['languages'] || vjs.options['languages'];
        this.cache_ = {};
        this.poster_ = options['poster'] || '';
        this.controls_ = !!options['controls'];
        tag.controls = false;
        options.reportTouchActivity = false;
        this.isAudio(this.tag.nodeName.toLowerCase() === 'audio');
        vjs.Component.call(this, this, options, ready);
        if (this.controls()) {
          this.addClass('vjs-controls-enabled');
        } else {
          this.addClass('vjs-controls-disabled');
        }
        if (this.isAudio()) {
          this.addClass('vjs-audio');
        }
        vjs.players[this.id_] = this;
        if (options['plugins']) {
          vjs.obj.each(options['plugins'], function(key, val) {
            this[key](val);
          }, this);
        }
        this.listenForUserActivity();
      }});
    vjs.Player.prototype.language_;
    vjs.Player.prototype.language = function(languageCode) {
      if (languageCode === undefined) {
        return this.language_;
      }
      this.language_ = languageCode;
      return this;
    };
    vjs.Player.prototype.languages_;
    vjs.Player.prototype.languages = function() {
      return this.languages_;
    };
    vjs.Player.prototype.options_ = vjs.options;
    vjs.Player.prototype.dispose = function() {
      this.trigger('dispose');
      this.off('dispose');
      vjs.players[this.id_] = null;
      if (this.tag && this.tag['player']) {
        this.tag['player'] = null;
      }
      if (this.el_ && this.el_['player']) {
        this.el_['player'] = null;
      }
      if (this.tech) {
        this.tech.dispose();
      }
      vjs.Component.prototype.dispose.call(this);
    };
    vjs.Player.prototype.getTagSettings = function(tag) {
      var tagOptions,
          dataSetup,
          options = {
            'sources': [],
            'tracks': []
          };
      tagOptions = vjs.getElementAttributes(tag);
      dataSetup = tagOptions['data-setup'];
      if (dataSetup !== null) {
        vjs.obj.merge(tagOptions, vjs.JSON.parse(dataSetup || '{}'));
      }
      vjs.obj.merge(options, tagOptions);
      if (tag.hasChildNodes()) {
        var children,
            child,
            childName,
            i,
            j;
        children = tag.childNodes;
        for (i = 0, j = children.length; i < j; i++) {
          child = children[i];
          childName = child.nodeName.toLowerCase();
          if (childName === 'source') {
            options['sources'].push(vjs.getElementAttributes(child));
          } else if (childName === 'track') {
            options['tracks'].push(vjs.getElementAttributes(child));
          }
        }
      }
      return options;
    };
    vjs.Player.prototype.createEl = function() {
      var el = this.el_ = vjs.Component.prototype.createEl.call(this, 'div'),
          tag = this.tag,
          attrs;
      tag.removeAttribute('width');
      tag.removeAttribute('height');
      attrs = vjs.getElementAttributes(tag);
      vjs.obj.each(attrs, function(attr) {
        if (attr == 'class') {
          el.className = attrs[attr];
        } else {
          el.setAttribute(attr, attrs[attr]);
        }
      });
      tag.id += '_html5_api';
      tag.className = 'vjs-tech';
      tag['player'] = el['player'] = this;
      this.addClass('vjs-paused');
      this.width(this.options_['width'], true);
      this.height(this.options_['height'], true);
      tag.initNetworkState_ = tag.networkState;
      if (tag.parentNode) {
        tag.parentNode.insertBefore(el, tag);
      }
      vjs.insertFirst(tag, el);
      this.el_ = el;
      this.on('loadstart', this.onLoadStart);
      this.on('waiting', this.onWaiting);
      this.on(['canplay', 'canplaythrough', 'playing', 'ended'], this.onWaitEnd);
      this.on('seeking', this.onSeeking);
      this.on('seeked', this.onSeeked);
      this.on('ended', this.onEnded);
      this.on('play', this.onPlay);
      this.on('firstplay', this.onFirstPlay);
      this.on('pause', this.onPause);
      this.on('progress', this.onProgress);
      this.on('durationchange', this.onDurationChange);
      this.on('fullscreenchange', this.onFullscreenChange);
      return el;
    };
    vjs.Player.prototype.loadTech = function(techName, source) {
      if (this.tech) {
        this.unloadTech();
      }
      if (techName !== 'Html5' && this.tag) {
        vjs.Html5.disposeMediaElement(this.tag);
        this.tag = null;
      }
      this.techName = techName;
      this.isReady_ = false;
      var techReady = function() {
        this.player_.triggerReady();
      };
      var techOptions = vjs.obj.merge({
        'source': source,
        'parentEl': this.el_
      }, this.options_[techName.toLowerCase()]);
      if (source) {
        this.currentType_ = source.type;
        if (source.src == this.cache_.src && this.cache_.currentTime > 0) {
          techOptions['startTime'] = this.cache_.currentTime;
        }
        this.cache_.src = source.src;
      }
      this.tech = new window['videojs'][techName](this, techOptions);
      this.tech.ready(techReady);
    };
    vjs.Player.prototype.unloadTech = function() {
      this.isReady_ = false;
      this.tech.dispose();
      this.tech = false;
    };
    vjs.Player.prototype.onLoadStart = function() {
      this.removeClass('vjs-ended');
      this.error(null);
      if (!this.paused()) {
        this.trigger('firstplay');
      } else {
        this.hasStarted(false);
      }
    };
    vjs.Player.prototype.hasStarted_ = false;
    vjs.Player.prototype.hasStarted = function(hasStarted) {
      if (hasStarted !== undefined) {
        if (this.hasStarted_ !== hasStarted) {
          this.hasStarted_ = hasStarted;
          if (hasStarted) {
            this.addClass('vjs-has-started');
            this.trigger('firstplay');
          } else {
            this.removeClass('vjs-has-started');
          }
        }
        return this;
      }
      return this.hasStarted_;
    };
    vjs.Player.prototype.onLoadedMetaData;
    vjs.Player.prototype.onLoadedData;
    vjs.Player.prototype.onLoadedAllData;
    vjs.Player.prototype.onPlay = function() {
      this.removeClass('vjs-ended');
      this.removeClass('vjs-paused');
      this.addClass('vjs-playing');
      this.hasStarted(true);
    };
    vjs.Player.prototype.onWaiting = function() {
      this.addClass('vjs-waiting');
    };
    vjs.Player.prototype.onWaitEnd = function() {
      this.removeClass('vjs-waiting');
    };
    vjs.Player.prototype.onSeeking = function() {
      this.addClass('vjs-seeking');
    };
    vjs.Player.prototype.onSeeked = function() {
      this.removeClass('vjs-seeking');
    };
    vjs.Player.prototype.onFirstPlay = function() {
      if (this.options_['starttime']) {
        this.currentTime(this.options_['starttime']);
      }
      this.addClass('vjs-has-started');
    };
    vjs.Player.prototype.onPause = function() {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
    };
    vjs.Player.prototype.onTimeUpdate;
    vjs.Player.prototype.onProgress = function() {
      if (this.bufferedPercent() == 1) {
        this.trigger('loadedalldata');
      }
    };
    vjs.Player.prototype.onEnded = function() {
      this.addClass('vjs-ended');
      if (this.options_['loop']) {
        this.currentTime(0);
        this.play();
      } else if (!this.paused()) {
        this.pause();
      }
    };
    vjs.Player.prototype.onDurationChange = function() {
      var duration = this.techGet('duration');
      if (duration) {
        if (duration < 0) {
          duration = Infinity;
        }
        this.duration(duration);
        if (duration === Infinity) {
          this.addClass('vjs-live');
        } else {
          this.removeClass('vjs-live');
        }
      }
    };
    vjs.Player.prototype.onVolumeChange;
    vjs.Player.prototype.onFullscreenChange = function() {
      if (this.isFullscreen()) {
        this.addClass('vjs-fullscreen');
      } else {
        this.removeClass('vjs-fullscreen');
      }
    };
    vjs.Player.prototype.onError;
    vjs.Player.prototype.cache_;
    vjs.Player.prototype.getCache = function() {
      return this.cache_;
    };
    vjs.Player.prototype.techCall = function(method, arg) {
      if (this.tech && !this.tech.isReady_) {
        this.tech.ready(function() {
          this[method](arg);
        });
      } else {
        try {
          this.tech[method](arg);
        } catch (e) {
          vjs.log(e);
          throw e;
        }
      }
    };
    vjs.Player.prototype.techGet = function(method) {
      if (this.tech && this.tech.isReady_) {
        try {
          return this.tech[method]();
        } catch (e) {
          if (this.tech[method] === undefined) {
            vjs.log('Video.js: ' + method + ' method not defined for ' + this.techName + ' playback technology.', e);
          } else {
            if (e.name == 'TypeError') {
              vjs.log('Video.js: ' + method + ' unavailable on ' + this.techName + ' playback technology element.', e);
              this.tech.isReady_ = false;
            } else {
              vjs.log(e);
            }
          }
          throw e;
        }
      }
      return;
    };
    vjs.Player.prototype.play = function() {
      this.techCall('play');
      return this;
    };
    vjs.Player.prototype.pause = function() {
      this.techCall('pause');
      return this;
    };
    vjs.Player.prototype.paused = function() {
      return (this.techGet('paused') === false) ? false : true;
    };
    vjs.Player.prototype.currentTime = function(seconds) {
      if (seconds !== undefined) {
        this.techCall('setCurrentTime', seconds);
        return this;
      }
      return this.cache_.currentTime = (this.techGet('currentTime') || 0);
    };
    vjs.Player.prototype.duration = function(seconds) {
      if (seconds !== undefined) {
        this.cache_.duration = parseFloat(seconds);
        return this;
      }
      if (this.cache_.duration === undefined) {
        this.onDurationChange();
      }
      return this.cache_.duration || 0;
    };
    vjs.Player.prototype.remainingTime = function() {
      return this.duration() - this.currentTime();
    };
    vjs.Player.prototype.buffered = function() {
      var buffered = this.techGet('buffered');
      if (!buffered || !buffered.length) {
        buffered = vjs.createTimeRange(0, 0);
      }
      return buffered;
    };
    vjs.Player.prototype.bufferedPercent = function() {
      var duration = this.duration(),
          buffered = this.buffered(),
          bufferedDuration = 0,
          start,
          end;
      if (!duration) {
        return 0;
      }
      for (var i = 0; i < buffered.length; i++) {
        start = buffered.start(i);
        end = buffered.end(i);
        if (end > duration) {
          end = duration;
        }
        bufferedDuration += end - start;
      }
      return bufferedDuration / duration;
    };
    vjs.Player.prototype.bufferedEnd = function() {
      var buffered = this.buffered(),
          duration = this.duration(),
          end = buffered.end(buffered.length - 1);
      if (end > duration) {
        end = duration;
      }
      return end;
    };
    vjs.Player.prototype.volume = function(percentAsDecimal) {
      var vol;
      if (percentAsDecimal !== undefined) {
        vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
        this.cache_.volume = vol;
        this.techCall('setVolume', vol);
        vjs.setLocalStorage('volume', vol);
        return this;
      }
      vol = parseFloat(this.techGet('volume'));
      return (isNaN(vol)) ? 1 : vol;
    };
    vjs.Player.prototype.muted = function(muted) {
      if (muted !== undefined) {
        this.techCall('setMuted', muted);
        return this;
      }
      return this.techGet('muted') || false;
    };
    vjs.Player.prototype.supportsFullScreen = function() {
      return this.techGet('supportsFullScreen') || false;
    };
    vjs.Player.prototype.isFullscreen_ = false;
    vjs.Player.prototype.isFullscreen = function(isFS) {
      if (isFS !== undefined) {
        this.isFullscreen_ = !!isFS;
        return this;
      }
      return this.isFullscreen_;
    };
    vjs.Player.prototype.isFullScreen = function(isFS) {
      vjs.log.warn('player.isFullScreen() has been deprecated, use player.isFullscreen() with a lowercase "s")');
      return this.isFullscreen(isFS);
    };
    vjs.Player.prototype.requestFullscreen = function() {
      var fsApi = vjs.browser.fullscreenAPI;
      this.isFullscreen(true);
      if (fsApi) {
        vjs.on(document, fsApi['fullscreenchange'], vjs.bind(this, function(e) {
          this.isFullscreen(document[fsApi.fullscreenElement]);
          if (this.isFullscreen() === false) {
            vjs.off(document, fsApi['fullscreenchange'], arguments.callee);
          }
          this.trigger('fullscreenchange');
        }));
        this.el_[fsApi.requestFullscreen]();
      } else if (this.tech.supportsFullScreen()) {
        this.techCall('enterFullScreen');
      } else {
        this.enterFullWindow();
        this.trigger('fullscreenchange');
      }
      return this;
    };
    vjs.Player.prototype.requestFullScreen = function() {
      vjs.log.warn('player.requestFullScreen() has been deprecated, use player.requestFullscreen() with a lowercase "s")');
      return this.requestFullscreen();
    };
    vjs.Player.prototype.exitFullscreen = function() {
      var fsApi = vjs.browser.fullscreenAPI;
      this.isFullscreen(false);
      if (fsApi) {
        document[fsApi.exitFullscreen]();
      } else if (this.tech.supportsFullScreen()) {
        this.techCall('exitFullScreen');
      } else {
        this.exitFullWindow();
        this.trigger('fullscreenchange');
      }
      return this;
    };
    vjs.Player.prototype.cancelFullScreen = function() {
      vjs.log.warn('player.cancelFullScreen() has been deprecated, use player.exitFullscreen()');
      return this.exitFullscreen();
    };
    vjs.Player.prototype.enterFullWindow = function() {
      this.isFullWindow = true;
      this.docOrigOverflow = document.documentElement.style.overflow;
      vjs.on(document, 'keydown', vjs.bind(this, this.fullWindowOnEscKey));
      document.documentElement.style.overflow = 'hidden';
      vjs.addClass(document.body, 'vjs-full-window');
      this.trigger('enterFullWindow');
    };
    vjs.Player.prototype.fullWindowOnEscKey = function(event) {
      if (event.keyCode === 27) {
        if (this.isFullscreen() === true) {
          this.exitFullscreen();
        } else {
          this.exitFullWindow();
        }
      }
    };
    vjs.Player.prototype.exitFullWindow = function() {
      this.isFullWindow = false;
      vjs.off(document, 'keydown', this.fullWindowOnEscKey);
      document.documentElement.style.overflow = this.docOrigOverflow;
      vjs.removeClass(document.body, 'vjs-full-window');
      this.trigger('exitFullWindow');
    };
    vjs.Player.prototype.selectSource = function(sources) {
      for (var i = 0,
          j = this.options_['techOrder']; i < j.length; i++) {
        var techName = vjs.capitalize(j[i]),
            tech = window['videojs'][techName];
        if (!tech) {
          vjs.log.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
          continue;
        }
        if (tech.isSupported()) {
          for (var a = 0,
              b = sources; a < b.length; a++) {
            var source = b[a];
            if (tech['canPlaySource'](source)) {
              return {
                source: source,
                tech: techName
              };
            }
          }
        }
      }
      return false;
    };
    vjs.Player.prototype.src = function(source) {
      if (source === undefined) {
        return this.techGet('src');
      }
      if (vjs.obj.isArray(source)) {
        this.sourceList_(source);
      } else if (typeof source === 'string') {
        this.src({src: source});
      } else if (source instanceof Object) {
        if (source.type && !window['videojs'][this.techName]['canPlaySource'](source)) {
          this.sourceList_([source]);
        } else {
          this.cache_.src = source.src;
          this.currentType_ = source.type || '';
          this.ready(function() {
            if (window['videojs'][this.techName].prototype.hasOwnProperty('setSource')) {
              this.techCall('setSource', source);
            } else {
              this.techCall('src', source.src);
            }
            if (this.options_['preload'] == 'auto') {
              this.load();
            }
            if (this.options_['autoplay']) {
              this.play();
            }
          });
        }
      }
      return this;
    };
    vjs.Player.prototype.sourceList_ = function(sources) {
      var sourceTech = this.selectSource(sources);
      if (sourceTech) {
        if (sourceTech.tech === this.techName) {
          this.src(sourceTech.source);
        } else {
          this.loadTech(sourceTech.tech, sourceTech.source);
        }
      } else {
        this.setTimeout(function() {
          this.error({
            code: 4,
            message: this.localize(this.options()['notSupportedMessage'])
          });
        }, 0);
        this.triggerReady();
      }
    };
    vjs.Player.prototype.load = function() {
      this.techCall('load');
      return this;
    };
    vjs.Player.prototype.currentSrc = function() {
      return this.techGet('currentSrc') || this.cache_.src || '';
    };
    vjs.Player.prototype.currentType = function() {
      return this.currentType_ || '';
    };
    vjs.Player.prototype.preload = function(value) {
      if (value !== undefined) {
        this.techCall('setPreload', value);
        this.options_['preload'] = value;
        return this;
      }
      return this.techGet('preload');
    };
    vjs.Player.prototype.autoplay = function(value) {
      if (value !== undefined) {
        this.techCall('setAutoplay', value);
        this.options_['autoplay'] = value;
        return this;
      }
      return this.techGet('autoplay', value);
    };
    vjs.Player.prototype.loop = function(value) {
      if (value !== undefined) {
        this.techCall('setLoop', value);
        this.options_['loop'] = value;
        return this;
      }
      return this.techGet('loop');
    };
    vjs.Player.prototype.poster_;
    vjs.Player.prototype.poster = function(src) {
      if (src === undefined) {
        return this.poster_;
      }
      if (!src) {
        src = '';
      }
      this.poster_ = src;
      this.techCall('setPoster', src);
      this.trigger('posterchange');
      return this;
    };
    vjs.Player.prototype.controls_;
    vjs.Player.prototype.controls = function(bool) {
      if (bool !== undefined) {
        bool = !!bool;
        if (this.controls_ !== bool) {
          this.controls_ = bool;
          if (bool) {
            this.removeClass('vjs-controls-disabled');
            this.addClass('vjs-controls-enabled');
            this.trigger('controlsenabled');
          } else {
            this.removeClass('vjs-controls-enabled');
            this.addClass('vjs-controls-disabled');
            this.trigger('controlsdisabled');
          }
        }
        return this;
      }
      return this.controls_;
    };
    vjs.Player.prototype.usingNativeControls_;
    vjs.Player.prototype.usingNativeControls = function(bool) {
      if (bool !== undefined) {
        bool = !!bool;
        if (this.usingNativeControls_ !== bool) {
          this.usingNativeControls_ = bool;
          if (bool) {
            this.addClass('vjs-using-native-controls');
            this.trigger('usingnativecontrols');
          } else {
            this.removeClass('vjs-using-native-controls');
            this.trigger('usingcustomcontrols');
          }
        }
        return this;
      }
      return this.usingNativeControls_;
    };
    vjs.Player.prototype.error_ = null;
    vjs.Player.prototype.error = function(err) {
      if (err === undefined) {
        return this.error_;
      }
      if (err === null) {
        this.error_ = err;
        this.removeClass('vjs-error');
        return this;
      }
      if (err instanceof vjs.MediaError) {
        this.error_ = err;
      } else {
        this.error_ = new vjs.MediaError(err);
      }
      this.trigger('error');
      this.addClass('vjs-error');
      vjs.log.error('(CODE:' + this.error_.code + ' ' + vjs.MediaError.errorTypes[this.error_.code] + ')', this.error_.message, this.error_);
      return this;
    };
    vjs.Player.prototype.ended = function() {
      return this.techGet('ended');
    };
    vjs.Player.prototype.seeking = function() {
      return this.techGet('seeking');
    };
    vjs.Player.prototype.seekable = function() {
      return this.techGet('seekable');
    };
    vjs.Player.prototype.userActivity_ = true;
    vjs.Player.prototype.reportUserActivity = function(event) {
      this.userActivity_ = true;
    };
    vjs.Player.prototype.userActive_ = true;
    vjs.Player.prototype.userActive = function(bool) {
      if (bool !== undefined) {
        bool = !!bool;
        if (bool !== this.userActive_) {
          this.userActive_ = bool;
          if (bool) {
            this.userActivity_ = true;
            this.removeClass('vjs-user-inactive');
            this.addClass('vjs-user-active');
            this.trigger('useractive');
          } else {
            this.userActivity_ = false;
            if (this.tech) {
              this.tech.one('mousemove', function(e) {
                e.stopPropagation();
                e.preventDefault();
              });
            }
            this.removeClass('vjs-user-active');
            this.addClass('vjs-user-inactive');
            this.trigger('userinactive');
          }
        }
        return this;
      }
      return this.userActive_;
    };
    vjs.Player.prototype.listenForUserActivity = function() {
      var onActivity,
          onMouseMove,
          onMouseDown,
          mouseInProgress,
          onMouseUp,
          activityCheck,
          inactivityTimeout,
          lastMoveX,
          lastMoveY;
      onActivity = vjs.bind(this, this.reportUserActivity);
      onMouseMove = function(e) {
        if (e.screenX != lastMoveX || e.screenY != lastMoveY) {
          lastMoveX = e.screenX;
          lastMoveY = e.screenY;
          onActivity();
        }
      };
      onMouseDown = function() {
        onActivity();
        this.clearInterval(mouseInProgress);
        mouseInProgress = this.setInterval(onActivity, 250);
      };
      onMouseUp = function(event) {
        onActivity();
        this.clearInterval(mouseInProgress);
      };
      this.on('mousedown', onMouseDown);
      this.on('mousemove', onMouseMove);
      this.on('mouseup', onMouseUp);
      this.on('keydown', onActivity);
      this.on('keyup', onActivity);
      activityCheck = this.setInterval(function() {
        if (this.userActivity_) {
          this.userActivity_ = false;
          this.userActive(true);
          this.clearTimeout(inactivityTimeout);
          var timeout = this.options()['inactivityTimeout'];
          if (timeout > 0) {
            inactivityTimeout = this.setTimeout(function() {
              if (!this.userActivity_) {
                this.userActive(false);
              }
            }, timeout);
          }
        }
      }, 250);
    };
    vjs.Player.prototype.playbackRate = function(rate) {
      if (rate !== undefined) {
        this.techCall('setPlaybackRate', rate);
        return this;
      }
      if (this.tech && this.tech['featuresPlaybackRate']) {
        return this.techGet('playbackRate');
      } else {
        return 1.0;
      }
    };
    vjs.Player.prototype.isAudio_ = false;
    vjs.Player.prototype.isAudio = function(bool) {
      if (bool !== undefined) {
        this.isAudio_ = !!bool;
        return this;
      }
      return this.isAudio_;
    };
    vjs.Player.prototype.networkState = function() {
      return this.techGet('networkState');
    };
    vjs.Player.prototype.readyState = function() {
      return this.techGet('readyState');
    };
    vjs.Player.prototype.textTracks = function() {
      return this.tech && this.tech['textTracks']();
    };
    vjs.Player.prototype.remoteTextTracks = function() {
      return this.tech && this.tech['remoteTextTracks']();
    };
    vjs.Player.prototype.addTextTrack = function(kind, label, language) {
      return this.tech && this.tech['addTextTrack'](kind, label, language);
    };
    vjs.Player.prototype.addRemoteTextTrack = function(options) {
      return this.tech && this.tech['addRemoteTextTrack'](options);
    };
    vjs.Player.prototype.removeRemoteTextTrack = function(track) {
      this.tech && this.tech['removeRemoteTextTrack'](track);
    };
    vjs.ControlBar = vjs.Component.extend();
    vjs.ControlBar.prototype.options_ = {
      loadEvent: 'play',
      children: {
        'playToggle': {},
        'currentTimeDisplay': {},
        'timeDivider': {},
        'durationDisplay': {},
        'remainingTimeDisplay': {},
        'liveDisplay': {},
        'progressControl': {},
        'fullscreenToggle': {},
        'volumeControl': {},
        'muteToggle': {},
        'playbackRateMenuButton': {},
        'subtitlesButton': {},
        'captionsButton': {},
        'chaptersButton': {}
      }
    };
    vjs.ControlBar.prototype.createEl = function() {
      return vjs.createEl('div', {className: 'vjs-control-bar'});
    };
    vjs.LiveDisplay = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
      }});
    vjs.LiveDisplay.prototype.createEl = function() {
      var el = vjs.Component.prototype.createEl.call(this, 'div', {className: 'vjs-live-controls vjs-control'});
      this.contentEl_ = vjs.createEl('div', {
        className: 'vjs-live-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE'),
        'aria-live': 'off'
      });
      el.appendChild(this.contentEl_);
      return el;
    };
    vjs.PlayToggle = vjs.Button.extend({init: function(player, options) {
        vjs.Button.call(this, player, options);
        this.on(player, 'play', this.onPlay);
        this.on(player, 'pause', this.onPause);
      }});
    vjs.PlayToggle.prototype.buttonText = 'Play';
    vjs.PlayToggle.prototype.buildCSSClass = function() {
      return 'vjs-play-control ' + vjs.Button.prototype.buildCSSClass.call(this);
    };
    vjs.PlayToggle.prototype.onClick = function() {
      if (this.player_.paused()) {
        this.player_.play();
      } else {
        this.player_.pause();
      }
    };
    vjs.PlayToggle.prototype.onPlay = function() {
      this.removeClass('vjs-paused');
      this.addClass('vjs-playing');
      this.el_.children[0].children[0].innerHTML = this.localize('Pause');
    };
    vjs.PlayToggle.prototype.onPause = function() {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      this.el_.children[0].children[0].innerHTML = this.localize('Play');
    };
    vjs.CurrentTimeDisplay = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
        this.on(player, 'timeupdate', this.updateContent);
      }});
    vjs.CurrentTimeDisplay.prototype.createEl = function() {
      var el = vjs.Component.prototype.createEl.call(this, 'div', {className: 'vjs-current-time vjs-time-controls vjs-control'});
      this.contentEl_ = vjs.createEl('div', {
        className: 'vjs-current-time-display',
        innerHTML: '<span class="vjs-control-text">Current Time </span>' + '0:00',
        'aria-live': 'off'
      });
      el.appendChild(this.contentEl_);
      return el;
    };
    vjs.CurrentTimeDisplay.prototype.updateContent = function() {
      var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
      this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Current Time') + '</span> ' + vjs.formatTime(time, this.player_.duration());
    };
    vjs.DurationDisplay = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
        this.on(player, 'timeupdate', this.updateContent);
        this.on(player, 'loadedmetadata', this.updateContent);
      }});
    vjs.DurationDisplay.prototype.createEl = function() {
      var el = vjs.Component.prototype.createEl.call(this, 'div', {className: 'vjs-duration vjs-time-controls vjs-control'});
      this.contentEl_ = vjs.createEl('div', {
        className: 'vjs-duration-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> ' + '0:00',
        'aria-live': 'off'
      });
      el.appendChild(this.contentEl_);
      return el;
    };
    vjs.DurationDisplay.prototype.updateContent = function() {
      var duration = this.player_.duration();
      if (duration) {
        this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> ' + vjs.formatTime(duration);
      }
    };
    vjs.TimeDivider = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
      }});
    vjs.TimeDivider.prototype.createEl = function() {
      return vjs.Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-time-divider',
        innerHTML: '<div><span>/</span></div>'
      });
    };
    vjs.RemainingTimeDisplay = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
        this.on(player, 'timeupdate', this.updateContent);
      }});
    vjs.RemainingTimeDisplay.prototype.createEl = function() {
      var el = vjs.Component.prototype.createEl.call(this, 'div', {className: 'vjs-remaining-time vjs-time-controls vjs-control'});
      this.contentEl_ = vjs.createEl('div', {
        className: 'vjs-remaining-time-display',
        innerHTML: '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> ' + '-0:00',
        'aria-live': 'off'
      });
      el.appendChild(this.contentEl_);
      return el;
    };
    vjs.RemainingTimeDisplay.prototype.updateContent = function() {
      if (this.player_.duration()) {
        this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> ' + '-' + vjs.formatTime(this.player_.remainingTime());
      }
    };
    vjs.FullscreenToggle = vjs.Button.extend({init: function(player, options) {
        vjs.Button.call(this, player, options);
      }});
    vjs.FullscreenToggle.prototype.buttonText = 'Fullscreen';
    vjs.FullscreenToggle.prototype.buildCSSClass = function() {
      return 'vjs-fullscreen-control ' + vjs.Button.prototype.buildCSSClass.call(this);
    };
    vjs.FullscreenToggle.prototype.onClick = function() {
      if (!this.player_.isFullscreen()) {
        this.player_.requestFullscreen();
        this.controlText_.innerHTML = this.localize('Non-Fullscreen');
      } else {
        this.player_.exitFullscreen();
        this.controlText_.innerHTML = this.localize('Fullscreen');
      }
    };
    vjs.ProgressControl = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
      }});
    vjs.ProgressControl.prototype.options_ = {children: {'seekBar': {}}};
    vjs.ProgressControl.prototype.createEl = function() {
      return vjs.Component.prototype.createEl.call(this, 'div', {className: 'vjs-progress-control vjs-control'});
    };
    vjs.SeekBar = vjs.Slider.extend({init: function(player, options) {
        vjs.Slider.call(this, player, options);
        this.on(player, 'timeupdate', this.updateARIAAttributes);
        player.ready(vjs.bind(this, this.updateARIAAttributes));
      }});
    vjs.SeekBar.prototype.options_ = {
      children: {
        'loadProgressBar': {},
        'playProgressBar': {},
        'seekHandle': {}
      },
      'barName': 'playProgressBar',
      'handleName': 'seekHandle'
    };
    vjs.SeekBar.prototype.playerEvent = 'timeupdate';
    vjs.SeekBar.prototype.createEl = function() {
      return vjs.Slider.prototype.createEl.call(this, 'div', {
        className: 'vjs-progress-holder',
        'aria-label': 'video progress bar'
      });
    };
    vjs.SeekBar.prototype.updateARIAAttributes = function() {
      var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
      this.el_.setAttribute('aria-valuenow', vjs.round(this.getPercent() * 100, 2));
      this.el_.setAttribute('aria-valuetext', vjs.formatTime(time, this.player_.duration()));
    };
    vjs.SeekBar.prototype.getPercent = function() {
      return this.player_.currentTime() / this.player_.duration();
    };
    vjs.SeekBar.prototype.onMouseDown = function(event) {
      vjs.Slider.prototype.onMouseDown.call(this, event);
      this.player_.scrubbing = true;
      this.player_.addClass('vjs-scrubbing');
      this.videoWasPlaying = !this.player_.paused();
      this.player_.pause();
    };
    vjs.SeekBar.prototype.onMouseMove = function(event) {
      var newTime = this.calculateDistance(event) * this.player_.duration();
      if (newTime == this.player_.duration()) {
        newTime = newTime - 0.1;
      }
      this.player_.currentTime(newTime);
    };
    vjs.SeekBar.prototype.onMouseUp = function(event) {
      vjs.Slider.prototype.onMouseUp.call(this, event);
      this.player_.scrubbing = false;
      this.player_.removeClass('vjs-scrubbing');
      if (this.videoWasPlaying) {
        this.player_.play();
      }
    };
    vjs.SeekBar.prototype.stepForward = function() {
      this.player_.currentTime(this.player_.currentTime() + 5);
    };
    vjs.SeekBar.prototype.stepBack = function() {
      this.player_.currentTime(this.player_.currentTime() - 5);
    };
    vjs.LoadProgressBar = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
        this.on(player, 'progress', this.update);
      }});
    vjs.LoadProgressBar.prototype.createEl = function() {
      return vjs.Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-load-progress',
        innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
      });
    };
    vjs.LoadProgressBar.prototype.update = function() {
      var i,
          start,
          end,
          part,
          buffered = this.player_.buffered(),
          duration = this.player_.duration(),
          bufferedEnd = this.player_.bufferedEnd(),
          children = this.el_.children,
          percentify = function(time, end) {
            var percent = (time / end) || 0;
            return (percent * 100) + '%';
          };
      this.el_.style.width = percentify(bufferedEnd, duration);
      for (i = 0; i < buffered.length; i++) {
        start = buffered.start(i), end = buffered.end(i), part = children[i];
        if (!part) {
          part = this.el_.appendChild(vjs.createEl());
        }
        part.style.left = percentify(start, bufferedEnd);
        part.style.width = percentify(end - start, bufferedEnd);
      }
      for (i = children.length; i > buffered.length; i--) {
        this.el_.removeChild(children[i - 1]);
      }
    };
    vjs.PlayProgressBar = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
      }});
    vjs.PlayProgressBar.prototype.createEl = function() {
      return vjs.Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-play-progress',
        innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
      });
    };
    vjs.SeekHandle = vjs.SliderHandle.extend({init: function(player, options) {
        vjs.SliderHandle.call(this, player, options);
        this.on(player, 'timeupdate', this.updateContent);
      }});
    vjs.SeekHandle.prototype.defaultValue = '00:00';
    vjs.SeekHandle.prototype.createEl = function() {
      return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
        className: 'vjs-seek-handle',
        'aria-live': 'off'
      });
    };
    vjs.SeekHandle.prototype.updateContent = function() {
      var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
      this.el_.innerHTML = '<span class="vjs-control-text">' + vjs.formatTime(time, this.player_.duration()) + '</span>';
    };
    vjs.VolumeControl = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
        if (player.tech && player.tech['featuresVolumeControl'] === false) {
          this.addClass('vjs-hidden');
        }
        this.on(player, 'loadstart', function() {
          if (player.tech['featuresVolumeControl'] === false) {
            this.addClass('vjs-hidden');
          } else {
            this.removeClass('vjs-hidden');
          }
        });
      }});
    vjs.VolumeControl.prototype.options_ = {children: {'volumeBar': {}}};
    vjs.VolumeControl.prototype.createEl = function() {
      return vjs.Component.prototype.createEl.call(this, 'div', {className: 'vjs-volume-control vjs-control'});
    };
    vjs.VolumeBar = vjs.Slider.extend({init: function(player, options) {
        vjs.Slider.call(this, player, options);
        this.on(player, 'volumechange', this.updateARIAAttributes);
        player.ready(vjs.bind(this, this.updateARIAAttributes));
      }});
    vjs.VolumeBar.prototype.updateARIAAttributes = function() {
      this.el_.setAttribute('aria-valuenow', vjs.round(this.player_.volume() * 100, 2));
      this.el_.setAttribute('aria-valuetext', vjs.round(this.player_.volume() * 100, 2) + '%');
    };
    vjs.VolumeBar.prototype.options_ = {
      children: {
        'volumeLevel': {},
        'volumeHandle': {}
      },
      'barName': 'volumeLevel',
      'handleName': 'volumeHandle'
    };
    vjs.VolumeBar.prototype.playerEvent = 'volumechange';
    vjs.VolumeBar.prototype.createEl = function() {
      return vjs.Slider.prototype.createEl.call(this, 'div', {
        className: 'vjs-volume-bar',
        'aria-label': 'volume level'
      });
    };
    vjs.VolumeBar.prototype.onMouseMove = function(event) {
      if (this.player_.muted()) {
        this.player_.muted(false);
      }
      this.player_.volume(this.calculateDistance(event));
    };
    vjs.VolumeBar.prototype.getPercent = function() {
      if (this.player_.muted()) {
        return 0;
      } else {
        return this.player_.volume();
      }
    };
    vjs.VolumeBar.prototype.stepForward = function() {
      this.player_.volume(this.player_.volume() + 0.1);
    };
    vjs.VolumeBar.prototype.stepBack = function() {
      this.player_.volume(this.player_.volume() - 0.1);
    };
    vjs.VolumeLevel = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
      }});
    vjs.VolumeLevel.prototype.createEl = function() {
      return vjs.Component.prototype.createEl.call(this, 'div', {
        className: 'vjs-volume-level',
        innerHTML: '<span class="vjs-control-text"></span>'
      });
    };
    vjs.VolumeHandle = vjs.SliderHandle.extend();
    vjs.VolumeHandle.prototype.defaultValue = '00:00';
    vjs.VolumeHandle.prototype.createEl = function() {
      return vjs.SliderHandle.prototype.createEl.call(this, 'div', {className: 'vjs-volume-handle'});
    };
    vjs.MuteToggle = vjs.Button.extend({init: function(player, options) {
        vjs.Button.call(this, player, options);
        this.on(player, 'volumechange', this.update);
        if (player.tech && player.tech['featuresVolumeControl'] === false) {
          this.addClass('vjs-hidden');
        }
        this.on(player, 'loadstart', function() {
          if (player.tech['featuresVolumeControl'] === false) {
            this.addClass('vjs-hidden');
          } else {
            this.removeClass('vjs-hidden');
          }
        });
      }});
    vjs.MuteToggle.prototype.createEl = function() {
      return vjs.Button.prototype.createEl.call(this, 'div', {
        className: 'vjs-mute-control vjs-control',
        innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
      });
    };
    vjs.MuteToggle.prototype.onClick = function() {
      this.player_.muted(this.player_.muted() ? false : true);
    };
    vjs.MuteToggle.prototype.update = function() {
      var vol = this.player_.volume(),
          level = 3;
      if (vol === 0 || this.player_.muted()) {
        level = 0;
      } else if (vol < 0.33) {
        level = 1;
      } else if (vol < 0.67) {
        level = 2;
      }
      if (this.player_.muted()) {
        if (this.el_.children[0].children[0].innerHTML != this.localize('Unmute')) {
          this.el_.children[0].children[0].innerHTML = this.localize('Unmute');
        }
      } else {
        if (this.el_.children[0].children[0].innerHTML != this.localize('Mute')) {
          this.el_.children[0].children[0].innerHTML = this.localize('Mute');
        }
      }
      for (var i = 0; i < 4; i++) {
        vjs.removeClass(this.el_, 'vjs-vol-' + i);
      }
      vjs.addClass(this.el_, 'vjs-vol-' + level);
    };
    vjs.VolumeMenuButton = vjs.MenuButton.extend({init: function(player, options) {
        vjs.MenuButton.call(this, player, options);
        this.on(player, 'volumechange', this.volumeUpdate);
        if (player.tech && player.tech['featuresVolumeControl'] === false) {
          this.addClass('vjs-hidden');
        }
        this.on(player, 'loadstart', function() {
          if (player.tech['featuresVolumeControl'] === false) {
            this.addClass('vjs-hidden');
          } else {
            this.removeClass('vjs-hidden');
          }
        });
        this.addClass('vjs-menu-button');
      }});
    vjs.VolumeMenuButton.prototype.createMenu = function() {
      var menu = new vjs.Menu(this.player_, {contentElType: 'div'});
      var vc = new vjs.VolumeBar(this.player_, this.options_['volumeBar']);
      vc.on('focus', function() {
        menu.lockShowing();
      });
      vc.on('blur', function() {
        menu.unlockShowing();
      });
      menu.addChild(vc);
      return menu;
    };
    vjs.VolumeMenuButton.prototype.onClick = function() {
      vjs.MuteToggle.prototype.onClick.call(this);
      vjs.MenuButton.prototype.onClick.call(this);
    };
    vjs.VolumeMenuButton.prototype.createEl = function() {
      return vjs.Button.prototype.createEl.call(this, 'div', {
        className: 'vjs-volume-menu-button vjs-menu-button vjs-control',
        innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
      });
    };
    vjs.VolumeMenuButton.prototype.volumeUpdate = vjs.MuteToggle.prototype.update;
    vjs.PlaybackRateMenuButton = vjs.MenuButton.extend({init: function(player, options) {
        vjs.MenuButton.call(this, player, options);
        this.updateVisibility();
        this.updateLabel();
        this.on(player, 'loadstart', this.updateVisibility);
        this.on(player, 'ratechange', this.updateLabel);
      }});
    vjs.PlaybackRateMenuButton.prototype.buttonText = 'Playback Rate';
    vjs.PlaybackRateMenuButton.prototype.className = 'vjs-playback-rate';
    vjs.PlaybackRateMenuButton.prototype.createEl = function() {
      var el = vjs.MenuButton.prototype.createEl.call(this);
      this.labelEl_ = vjs.createEl('div', {
        className: 'vjs-playback-rate-value',
        innerHTML: 1.0
      });
      el.appendChild(this.labelEl_);
      return el;
    };
    vjs.PlaybackRateMenuButton.prototype.createMenu = function() {
      var menu = new vjs.Menu(this.player());
      var rates = this.player().options()['playbackRates'];
      if (rates) {
        for (var i = rates.length - 1; i >= 0; i--) {
          menu.addChild(new vjs.PlaybackRateMenuItem(this.player(), {'rate': rates[i] + 'x'}));
        }
      }
      return menu;
    };
    vjs.PlaybackRateMenuButton.prototype.updateARIAAttributes = function() {
      this.el().setAttribute('aria-valuenow', this.player().playbackRate());
    };
    vjs.PlaybackRateMenuButton.prototype.onClick = function() {
      var currentRate = this.player().playbackRate();
      var rates = this.player().options()['playbackRates'];
      var newRate = rates[0];
      for (var i = 0; i < rates.length; i++) {
        if (rates[i] > currentRate) {
          newRate = rates[i];
          break;
        }
      }
      this.player().playbackRate(newRate);
    };
    vjs.PlaybackRateMenuButton.prototype.playbackRateSupported = function() {
      return this.player().tech && this.player().tech['featuresPlaybackRate'] && this.player().options()['playbackRates'] && this.player().options()['playbackRates'].length > 0;
      ;
    };
    vjs.PlaybackRateMenuButton.prototype.updateVisibility = function() {
      if (this.playbackRateSupported()) {
        this.removeClass('vjs-hidden');
      } else {
        this.addClass('vjs-hidden');
      }
    };
    vjs.PlaybackRateMenuButton.prototype.updateLabel = function() {
      if (this.playbackRateSupported()) {
        this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
      }
    };
    vjs.PlaybackRateMenuItem = vjs.MenuItem.extend({
      contentElType: 'button',
      init: function(player, options) {
        var label = this.label = options['rate'];
        var rate = this.rate = parseFloat(label, 10);
        options['label'] = label;
        options['selected'] = rate === 1;
        vjs.MenuItem.call(this, player, options);
        this.on(player, 'ratechange', this.update);
      }
    });
    vjs.PlaybackRateMenuItem.prototype.onClick = function() {
      vjs.MenuItem.prototype.onClick.call(this);
      this.player().playbackRate(this.rate);
    };
    vjs.PlaybackRateMenuItem.prototype.update = function() {
      this.selected(this.player().playbackRate() == this.rate);
    };
    vjs.PosterImage = vjs.Button.extend({init: function(player, options) {
        vjs.Button.call(this, player, options);
        this.update();
        player.on('posterchange', vjs.bind(this, this.update));
      }});
    vjs.PosterImage.prototype.dispose = function() {
      this.player().off('posterchange', this.update);
      vjs.Button.prototype.dispose.call(this);
    };
    vjs.PosterImage.prototype.createEl = function() {
      var el = vjs.createEl('div', {
        className: 'vjs-poster',
        tabIndex: -1
      });
      if (!vjs.BACKGROUND_SIZE_SUPPORTED) {
        this.fallbackImg_ = vjs.createEl('img');
        el.appendChild(this.fallbackImg_);
      }
      return el;
    };
    vjs.PosterImage.prototype.update = function() {
      var url = this.player().poster();
      this.setSrc(url);
      if (url) {
        this.show();
      } else {
        this.hide();
      }
    };
    vjs.PosterImage.prototype.setSrc = function(url) {
      var backgroundImage;
      if (this.fallbackImg_) {
        this.fallbackImg_.src = url;
      } else {
        backgroundImage = '';
        if (url) {
          backgroundImage = 'url("' + url + '")';
        }
        this.el_.style.backgroundImage = backgroundImage;
      }
    };
    vjs.PosterImage.prototype.onClick = function() {
      this.player_.play();
    };
    vjs.LoadingSpinner = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
      }});
    vjs.LoadingSpinner.prototype.createEl = function() {
      return vjs.Component.prototype.createEl.call(this, 'div', {className: 'vjs-loading-spinner'});
    };
    vjs.BigPlayButton = vjs.Button.extend();
    vjs.BigPlayButton.prototype.createEl = function() {
      return vjs.Button.prototype.createEl.call(this, 'div', {
        className: 'vjs-big-play-button',
        innerHTML: '<span aria-hidden="true"></span>',
        'aria-label': 'play video'
      });
    };
    vjs.BigPlayButton.prototype.onClick = function() {
      this.player_.play();
    };
    vjs.ErrorDisplay = vjs.Component.extend({init: function(player, options) {
        vjs.Component.call(this, player, options);
        this.update();
        this.on(player, 'error', this.update);
      }});
    vjs.ErrorDisplay.prototype.createEl = function() {
      var el = vjs.Component.prototype.createEl.call(this, 'div', {className: 'vjs-error-display'});
      this.contentEl_ = vjs.createEl('div');
      el.appendChild(this.contentEl_);
      return el;
    };
    vjs.ErrorDisplay.prototype.update = function() {
      if (this.player().error()) {
        this.contentEl_.innerHTML = this.localize(this.player().error().message);
      }
    };
    (function() {
      var createTrackHelper;
      vjs.MediaTechController = vjs.Component.extend({init: function(player, options, ready) {
          options = options || {};
          options.reportTouchActivity = false;
          vjs.Component.call(this, player, options, ready);
          if (!this['featuresProgressEvents']) {
            this.manualProgressOn();
          }
          if (!this['featuresTimeupdateEvents']) {
            this.manualTimeUpdatesOn();
          }
          this.initControlsListeners();
          if (!this['featuresNativeTextTracks']) {
            this.emulateTextTracks();
          }
          this.initTextTrackListeners();
        }});
      vjs.MediaTechController.prototype.initControlsListeners = function() {
        var player,
            activateControls;
        player = this.player();
        activateControls = function() {
          if (player.controls() && !player.usingNativeControls()) {
            this.addControlsListeners();
          }
        };
        this.ready(activateControls);
        this.on(player, 'controlsenabled', activateControls);
        this.on(player, 'controlsdisabled', this.removeControlsListeners);
        this.ready(function() {
          if (this.networkState && this.networkState() > 0) {
            this.player().trigger('loadstart');
          }
        });
      };
      vjs.MediaTechController.prototype.addControlsListeners = function() {
        var userWasActive;
        this.on('mousedown', this.onClick);
        this.on('touchstart', function(event) {
          userWasActive = this.player_.userActive();
        });
        this.on('touchmove', function(event) {
          if (userWasActive) {
            this.player().reportUserActivity();
          }
        });
        this.on('touchend', function(event) {
          event.preventDefault();
        });
        this.emitTapEvents();
        this.on('tap', this.onTap);
      };
      vjs.MediaTechController.prototype.removeControlsListeners = function() {
        this.off('tap');
        this.off('touchstart');
        this.off('touchmove');
        this.off('touchleave');
        this.off('touchcancel');
        this.off('touchend');
        this.off('click');
        this.off('mousedown');
      };
      vjs.MediaTechController.prototype.onClick = function(event) {
        if (event.button !== 0)
          return;
        if (this.player().controls()) {
          if (this.player().paused()) {
            this.player().play();
          } else {
            this.player().pause();
          }
        }
      };
      vjs.MediaTechController.prototype.onTap = function() {
        this.player().userActive(!this.player().userActive());
      };
      vjs.MediaTechController.prototype.manualProgressOn = function() {
        this.manualProgress = true;
        this.trackProgress();
      };
      vjs.MediaTechController.prototype.manualProgressOff = function() {
        this.manualProgress = false;
        this.stopTrackingProgress();
      };
      vjs.MediaTechController.prototype.trackProgress = function() {
        this.progressInterval = this.setInterval(function() {
          var bufferedPercent = this.player().bufferedPercent();
          if (this.bufferedPercent_ != bufferedPercent) {
            this.player().trigger('progress');
          }
          this.bufferedPercent_ = bufferedPercent;
          if (bufferedPercent === 1) {
            this.stopTrackingProgress();
          }
        }, 500);
      };
      vjs.MediaTechController.prototype.stopTrackingProgress = function() {
        this.clearInterval(this.progressInterval);
      };
      vjs.MediaTechController.prototype.manualTimeUpdatesOn = function() {
        var player = this.player_;
        this.manualTimeUpdates = true;
        this.on(player, 'play', this.trackCurrentTime);
        this.on(player, 'pause', this.stopTrackingCurrentTime);
        this.one('timeupdate', function() {
          this['featuresTimeupdateEvents'] = true;
          this.manualTimeUpdatesOff();
        });
      };
      vjs.MediaTechController.prototype.manualTimeUpdatesOff = function() {
        var player = this.player_;
        this.manualTimeUpdates = false;
        this.stopTrackingCurrentTime();
        this.off(player, 'play', this.trackCurrentTime);
        this.off(player, 'pause', this.stopTrackingCurrentTime);
      };
      vjs.MediaTechController.prototype.trackCurrentTime = function() {
        if (this.currentTimeInterval) {
          this.stopTrackingCurrentTime();
        }
        this.currentTimeInterval = this.setInterval(function() {
          this.player().trigger('timeupdate');
        }, 250);
      };
      vjs.MediaTechController.prototype.stopTrackingCurrentTime = function() {
        this.clearInterval(this.currentTimeInterval);
        this.player().trigger('timeupdate');
      };
      vjs.MediaTechController.prototype.dispose = function() {
        if (this.manualProgress) {
          this.manualProgressOff();
        }
        if (this.manualTimeUpdates) {
          this.manualTimeUpdatesOff();
        }
        vjs.Component.prototype.dispose.call(this);
      };
      vjs.MediaTechController.prototype.setCurrentTime = function() {
        if (this.manualTimeUpdates) {
          this.player().trigger('timeupdate');
        }
      };
      vjs.MediaTechController.prototype.initTextTrackListeners = function() {
        var player = this.player_,
            tracks,
            textTrackListChanges = function() {
              var textTrackDisplay = player.getChild('textTrackDisplay'),
                  controlBar;
              if (textTrackDisplay) {
                textTrackDisplay.updateDisplay();
              }
            };
        tracks = this.textTracks();
        if (!tracks) {
          return;
        }
        tracks.addEventListener('removetrack', textTrackListChanges);
        tracks.addEventListener('addtrack', textTrackListChanges);
        this.on('dispose', vjs.bind(this, function() {
          tracks.removeEventListener('removetrack', textTrackListChanges);
          tracks.removeEventListener('addtrack', textTrackListChanges);
        }));
      };
      vjs.MediaTechController.prototype.emulateTextTracks = function() {
        var player = this.player_,
            textTracksChanges,
            tracks,
            script;
        if (!window['WebVTT']) {
          script = document.createElement('script');
          script.src = player.options()['vtt.js'] || '../node_modules/vtt.js/dist/vtt.js';
          player.el().appendChild(script);
          window['WebVTT'] = true;
        }
        tracks = this.textTracks();
        if (!tracks) {
          return;
        }
        textTracksChanges = function() {
          var i,
              track,
              textTrackDisplay;
          textTrackDisplay = player.getChild('textTrackDisplay'), textTrackDisplay.updateDisplay();
          for (i = 0; i < this.length; i++) {
            track = this[i];
            track.removeEventListener('cuechange', vjs.bind(textTrackDisplay, textTrackDisplay.updateDisplay));
            if (track.mode === 'showing') {
              track.addEventListener('cuechange', vjs.bind(textTrackDisplay, textTrackDisplay.updateDisplay));
            }
          }
        };
        tracks.addEventListener('change', textTracksChanges);
        this.on('dispose', vjs.bind(this, function() {
          tracks.removeEventListener('change', textTracksChanges);
        }));
      };
      vjs.MediaTechController.prototype.textTracks_;
      vjs.MediaTechController.prototype.textTracks = function() {
        this.player_.textTracks_ = this.player_.textTracks_ || new vjs.TextTrackList();
        return this.player_.textTracks_;
      };
      vjs.MediaTechController.prototype.remoteTextTracks = function() {
        this.player_.remoteTextTracks_ = this.player_.remoteTextTracks_ || new vjs.TextTrackList();
        return this.player_.remoteTextTracks_;
      };
      createTrackHelper = function(self, kind, label, language, options) {
        var tracks = self.textTracks(),
            track;
        options = options || {};
        options['kind'] = kind;
        if (label) {
          options['label'] = label;
        }
        if (language) {
          options['language'] = language;
        }
        options['player'] = self.player_;
        track = new vjs.TextTrack(options);
        tracks.addTrack_(track);
        return track;
      };
      vjs.MediaTechController.prototype.addTextTrack = function(kind, label, language) {
        if (!kind) {
          throw new Error('TextTrack kind is required but was not provided');
        }
        return createTrackHelper(this, kind, label, language);
      };
      vjs.MediaTechController.prototype.addRemoteTextTrack = function(options) {
        var track = createTrackHelper(this, options['kind'], options['label'], options['language'], options);
        this.remoteTextTracks().addTrack_(track);
        return {track: track};
      };
      vjs.MediaTechController.prototype.removeRemoteTextTrack = function(track) {
        this.textTracks().removeTrack_(track);
        this.remoteTextTracks().removeTrack_(track);
      };
      vjs.MediaTechController.prototype.setPoster = function() {};
      vjs.MediaTechController.prototype['featuresVolumeControl'] = true;
      vjs.MediaTechController.prototype['featuresFullscreenResize'] = false;
      vjs.MediaTechController.prototype['featuresPlaybackRate'] = false;
      vjs.MediaTechController.prototype['featuresProgressEvents'] = false;
      vjs.MediaTechController.prototype['featuresTimeupdateEvents'] = false;
      vjs.MediaTechController.prototype['featuresNativeTextTracks'] = false;
      vjs.MediaTechController.withSourceHandlers = function(Tech) {
        Tech['registerSourceHandler'] = function(handler, index) {
          var handlers = Tech.sourceHandlers;
          if (!handlers) {
            handlers = Tech.sourceHandlers = [];
          }
          if (index === undefined) {
            index = handlers.length;
          }
          handlers.splice(index, 0, handler);
        };
        Tech.selectSourceHandler = function(source) {
          var handlers = Tech.sourceHandlers || [],
              can;
          for (var i = 0; i < handlers.length; i++) {
            can = handlers[i]['canHandleSource'](source);
            if (can) {
              return handlers[i];
            }
          }
          return null;
        };
        Tech.canPlaySource = function(srcObj) {
          var sh = Tech.selectSourceHandler(srcObj);
          if (sh) {
            return sh['canHandleSource'](srcObj);
          }
          return '';
        };
        Tech.prototype.setSource = function(source) {
          var sh = Tech.selectSourceHandler(source);
          if (!sh) {
            if (Tech['nativeSourceHandler']) {
              sh = Tech['nativeSourceHandler'];
            } else {
              vjs.log.error('No source hander found for the current source.');
            }
          }
          this.disposeSourceHandler();
          this.off('dispose', this.disposeSourceHandler);
          this.currentSource_ = source;
          this.sourceHandler_ = sh['handleSource'](source, this);
          this.on('dispose', this.disposeSourceHandler);
          return this;
        };
        Tech.prototype.disposeSourceHandler = function() {
          if (this.sourceHandler_ && this.sourceHandler_['dispose']) {
            this.sourceHandler_['dispose']();
          }
        };
      };
      vjs.media = {};
    })();
    vjs.Html5 = vjs.MediaTechController.extend({init: function(player, options, ready) {
        var nodes,
            nodesLength,
            i,
            node,
            nodeName,
            removeNodes;
        if (options['nativeCaptions'] === false || options['nativeTextTracks'] === false) {
          this['featuresNativeTextTracks'] = false;
        }
        vjs.MediaTechController.call(this, player, options, ready);
        this.setupTriggers();
        var source = options['source'];
        if (source && (this.el_.currentSrc !== source.src || (player.tag && player.tag.initNetworkState_ === 3))) {
          this.setSource(source);
        }
        if (this.el_.hasChildNodes()) {
          nodes = this.el_.childNodes;
          nodesLength = nodes.length;
          removeNodes = [];
          while (nodesLength--) {
            node = nodes[nodesLength];
            nodeName = node.nodeName.toLowerCase();
            if (nodeName === 'track') {
              if (!this['featuresNativeTextTracks']) {
                removeNodes.push(node);
              } else {
                this.remoteTextTracks().addTrack_(node['track']);
              }
            }
          }
          for (i = 0; i < removeNodes.length; i++) {
            this.el_.removeChild(removeNodes[i]);
          }
        }
        if (this['featuresNativeTextTracks']) {
          this.on('loadstart', vjs.bind(this, this.hideCaptions));
        }
        if (vjs.TOUCH_ENABLED && player.options()['nativeControlsForTouch'] === true) {
          this.useNativeControls();
        }
        player.ready(function() {
          if (this.src() && this.tag && this.options_['autoplay'] && this.paused()) {
            delete this.tag['poster'];
            this.play();
          }
        });
        this.triggerReady();
      }});
    vjs.Html5.prototype.dispose = function() {
      vjs.Html5.disposeMediaElement(this.el_);
      vjs.MediaTechController.prototype.dispose.call(this);
    };
    vjs.Html5.prototype.createEl = function() {
      var player = this.player_,
          track,
          trackEl,
          i,
          el = player.tag,
          attributes,
          newEl,
          clone;
      if (!el || this['movingMediaElementInDOM'] === false) {
        if (el) {
          clone = el.cloneNode(false);
          vjs.Html5.disposeMediaElement(el);
          el = clone;
          player.tag = null;
        } else {
          el = vjs.createEl('video');
          attributes = videojs.util.mergeOptions({}, player.tagAttributes);
          if (!vjs.TOUCH_ENABLED || player.options()['nativeControlsForTouch'] !== true) {
            delete attributes.controls;
          }
          vjs.setElementAttributes(el, vjs.obj.merge(attributes, {
            id: player.id() + '_html5_api',
            'class': 'vjs-tech'
          }));
        }
        el['player'] = player;
        if (player.options_.tracks) {
          for (i = 0; i < player.options_.tracks.length; i++) {
            track = player.options_.tracks[i];
            trackEl = document.createElement('track');
            trackEl.kind = track.kind;
            trackEl.label = track.label;
            trackEl.srclang = track.srclang;
            trackEl.src = track.src;
            if ('default' in track) {
              trackEl.setAttribute('default', 'default');
            }
            el.appendChild(trackEl);
          }
        }
        vjs.insertFirst(el, player.el());
      }
      var settingsAttrs = ['autoplay', 'preload', 'loop', 'muted'];
      for (i = settingsAttrs.length - 1; i >= 0; i--) {
        var attr = settingsAttrs[i];
        var overwriteAttrs = {};
        if (typeof player.options_[attr] !== 'undefined') {
          overwriteAttrs[attr] = player.options_[attr];
        }
        vjs.setElementAttributes(el, overwriteAttrs);
      }
      return el;
    };
    vjs.Html5.prototype.hideCaptions = function() {
      var tracks = this.el_.querySelectorAll('track'),
          track,
          i = tracks.length,
          kinds = {
            'captions': 1,
            'subtitles': 1
          };
      while (i--) {
        track = tracks[i].track;
        if ((track && track['kind'] in kinds) && (!tracks[i]['default'])) {
          track.mode = 'disabled';
        }
      }
    };
    vjs.Html5.prototype.setupTriggers = function() {
      for (var i = vjs.Html5.Events.length - 1; i >= 0; i--) {
        this.on(vjs.Html5.Events[i], this.eventHandler);
      }
    };
    vjs.Html5.prototype.eventHandler = function(evt) {
      if (evt.type == 'error' && this.error()) {
        this.player().error(this.error().code);
      } else {
        evt.bubbles = false;
        this.player().trigger(evt);
      }
    };
    vjs.Html5.prototype.useNativeControls = function() {
      var tech,
          player,
          controlsOn,
          controlsOff,
          cleanUp;
      tech = this;
      player = this.player();
      tech.setControls(player.controls());
      controlsOn = function() {
        tech.setControls(true);
      };
      controlsOff = function() {
        tech.setControls(false);
      };
      player.on('controlsenabled', controlsOn);
      player.on('controlsdisabled', controlsOff);
      cleanUp = function() {
        player.off('controlsenabled', controlsOn);
        player.off('controlsdisabled', controlsOff);
      };
      tech.on('dispose', cleanUp);
      player.on('usingcustomcontrols', cleanUp);
      player.usingNativeControls(true);
    };
    vjs.Html5.prototype.play = function() {
      this.el_.play();
    };
    vjs.Html5.prototype.pause = function() {
      this.el_.pause();
    };
    vjs.Html5.prototype.paused = function() {
      return this.el_.paused;
    };
    vjs.Html5.prototype.currentTime = function() {
      return this.el_.currentTime;
    };
    vjs.Html5.prototype.setCurrentTime = function(seconds) {
      try {
        this.el_.currentTime = seconds;
      } catch (e) {
        vjs.log(e, 'Video is not ready. (Video.js)');
      }
    };
    vjs.Html5.prototype.duration = function() {
      return this.el_.duration || 0;
    };
    vjs.Html5.prototype.buffered = function() {
      return this.el_.buffered;
    };
    vjs.Html5.prototype.volume = function() {
      return this.el_.volume;
    };
    vjs.Html5.prototype.setVolume = function(percentAsDecimal) {
      this.el_.volume = percentAsDecimal;
    };
    vjs.Html5.prototype.muted = function() {
      return this.el_.muted;
    };
    vjs.Html5.prototype.setMuted = function(muted) {
      this.el_.muted = muted;
    };
    vjs.Html5.prototype.width = function() {
      return this.el_.offsetWidth;
    };
    vjs.Html5.prototype.height = function() {
      return this.el_.offsetHeight;
    };
    vjs.Html5.prototype.supportsFullScreen = function() {
      if (typeof this.el_.webkitEnterFullScreen == 'function') {
        if (/Android/.test(vjs.USER_AGENT) || !/Chrome|Mac OS X 10.5/.test(vjs.USER_AGENT)) {
          return true;
        }
      }
      return false;
    };
    vjs.Html5.prototype.enterFullScreen = function() {
      var video = this.el_;
      if ('webkitDisplayingFullscreen' in video) {
        this.one('webkitbeginfullscreen', function() {
          this.player_.isFullscreen(true);
          this.one('webkitendfullscreen', function() {
            this.player_.isFullscreen(false);
            this.player_.trigger('fullscreenchange');
          });
          this.player_.trigger('fullscreenchange');
        });
      }
      if (video.paused && video.networkState <= video.HAVE_METADATA) {
        this.el_.play();
        this.setTimeout(function() {
          video.pause();
          video.webkitEnterFullScreen();
        }, 0);
      } else {
        video.webkitEnterFullScreen();
      }
    };
    vjs.Html5.prototype.exitFullScreen = function() {
      this.el_.webkitExitFullScreen();
    };
    vjs.Html5.prototype.returnOriginalIfBlobURI_ = function(elementURI, originalURI) {
      var blobURIRegExp = /^blob\:/i;
      if (originalURI && elementURI && blobURIRegExp.test(elementURI)) {
        return originalURI;
      }
      return elementURI;
    };
    vjs.Html5.prototype.src = function(src) {
      var elementSrc = this.el_.src;
      if (src === undefined) {
        return this.returnOriginalIfBlobURI_(elementSrc, this.source_);
      } else {
        this.setSrc(src);
      }
    };
    vjs.Html5.prototype.setSrc = function(src) {
      this.el_.src = src;
    };
    vjs.Html5.prototype.load = function() {
      this.el_.load();
    };
    vjs.Html5.prototype.currentSrc = function() {
      var elementSrc = this.el_.currentSrc;
      if (!this.currentSource_) {
        return elementSrc;
      }
      return this.returnOriginalIfBlobURI_(elementSrc, this.currentSource_.src);
    };
    vjs.Html5.prototype.poster = function() {
      return this.el_.poster;
    };
    vjs.Html5.prototype.setPoster = function(val) {
      this.el_.poster = val;
    };
    vjs.Html5.prototype.preload = function() {
      return this.el_.preload;
    };
    vjs.Html5.prototype.setPreload = function(val) {
      this.el_.preload = val;
    };
    vjs.Html5.prototype.autoplay = function() {
      return this.el_.autoplay;
    };
    vjs.Html5.prototype.setAutoplay = function(val) {
      this.el_.autoplay = val;
    };
    vjs.Html5.prototype.controls = function() {
      return this.el_.controls;
    };
    vjs.Html5.prototype.setControls = function(val) {
      this.el_.controls = !!val;
    };
    vjs.Html5.prototype.loop = function() {
      return this.el_.loop;
    };
    vjs.Html5.prototype.setLoop = function(val) {
      this.el_.loop = val;
    };
    vjs.Html5.prototype.error = function() {
      return this.el_.error;
    };
    vjs.Html5.prototype.seeking = function() {
      return this.el_.seeking;
    };
    vjs.Html5.prototype.seekable = function() {
      return this.el_.seekable;
    };
    vjs.Html5.prototype.ended = function() {
      return this.el_.ended;
    };
    vjs.Html5.prototype.defaultMuted = function() {
      return this.el_.defaultMuted;
    };
    vjs.Html5.prototype.playbackRate = function() {
      return this.el_.playbackRate;
    };
    vjs.Html5.prototype.setPlaybackRate = function(val) {
      this.el_.playbackRate = val;
    };
    vjs.Html5.prototype.networkState = function() {
      return this.el_.networkState;
    };
    vjs.Html5.prototype.readyState = function() {
      return this.el_.readyState;
    };
    vjs.Html5.prototype.textTracks = function() {
      if (!this['featuresNativeTextTracks']) {
        return vjs.MediaTechController.prototype.textTracks.call(this);
      }
      return this.el_.textTracks;
    };
    vjs.Html5.prototype.addTextTrack = function(kind, label, language) {
      if (!this['featuresNativeTextTracks']) {
        return vjs.MediaTechController.prototype.addTextTrack.call(this, kind, label, language);
      }
      return this.el_.addTextTrack(kind, label, language);
    };
    vjs.Html5.prototype.addRemoteTextTrack = function(options) {
      if (!this['featuresNativeTextTracks']) {
        return vjs.MediaTechController.prototype.addRemoteTextTrack.call(this, options);
      }
      var track = document.createElement('track');
      options = options || {};
      if (options['kind']) {
        track['kind'] = options['kind'];
      }
      if (options['label']) {
        track['label'] = options['label'];
      }
      if (options['language'] || options['srclang']) {
        track['srclang'] = options['language'] || options['srclang'];
      }
      if (options['default']) {
        track['default'] = options['default'];
      }
      if (options['id']) {
        track['id'] = options['id'];
      }
      if (options['src']) {
        track['src'] = options['src'];
      }
      this.el().appendChild(track);
      if (track.track['kind'] === 'metadata') {
        track['track']['mode'] = 'hidden';
      } else {
        track['track']['mode'] = 'disabled';
      }
      track['onload'] = function() {
        var tt = track['track'];
        if (track.readyState >= 2) {
          if (tt['kind'] === 'metadata' && tt['mode'] !== 'hidden') {
            tt['mode'] = 'hidden';
          } else if (tt['kind'] !== 'metadata' && tt['mode'] !== 'disabled') {
            tt['mode'] = 'disabled';
          }
          track['onload'] = null;
        }
      };
      this.remoteTextTracks().addTrack_(track.track);
      return track;
    };
    vjs.Html5.prototype.removeRemoteTextTrack = function(track) {
      if (!this['featuresNativeTextTracks']) {
        return vjs.MediaTechController.prototype.removeRemoteTextTrack.call(this, track);
      }
      var tracks,
          i;
      this.remoteTextTracks().removeTrack_(track);
      tracks = this.el()['querySelectorAll']('track');
      for (i = 0; i < tracks.length; i++) {
        if (tracks[i] === track || tracks[i]['track'] === track) {
          tracks[i]['parentNode']['removeChild'](tracks[i]);
          break;
        }
      }
    };
    vjs.Html5.isSupported = function() {
      try {
        vjs.TEST_VID['volume'] = 0.5;
      } catch (e) {
        return false;
      }
      return !!vjs.TEST_VID.canPlayType;
    };
    vjs.MediaTechController.withSourceHandlers(vjs.Html5);
    (function() {
      var origSetSource = vjs.Html5.prototype.setSource,
          origDisposeSourceHandler = vjs.Html5.prototype.disposeSourceHandler;
      vjs.Html5.prototype.setSource = function(source) {
        var retVal = origSetSource.call(this, source);
        this.source_ = source.src;
        return retVal;
      };
      vjs.Html5.prototype.disposeSourceHandler = function() {
        this.source_ = undefined;
        return origDisposeSourceHandler.call(this);
      };
    })();
    vjs.Html5['nativeSourceHandler'] = {};
    vjs.Html5['nativeSourceHandler']['canHandleSource'] = function(source) {
      var match,
          ext;
      function canPlayType(type) {
        try {
          return vjs.TEST_VID.canPlayType(type);
        } catch (e) {
          return '';
        }
      }
      if (source.type) {
        return canPlayType(source.type);
      } else if (source.src) {
        match = source.src.match(/\.([^.\/\?]+)(\?[^\/]+)?$/i);
        ext = match && match[1];
        return canPlayType('video/' + ext);
      }
      return '';
    };
    vjs.Html5['nativeSourceHandler']['handleSource'] = function(source, tech) {
      tech.setSrc(source.src);
    };
    vjs.Html5['nativeSourceHandler']['dispose'] = function() {};
    vjs.Html5['registerSourceHandler'](vjs.Html5['nativeSourceHandler']);
    vjs.Html5.canControlVolume = function() {
      var volume = vjs.TEST_VID.volume;
      vjs.TEST_VID.volume = (volume / 2) + 0.1;
      return volume !== vjs.TEST_VID.volume;
    };
    vjs.Html5.canControlPlaybackRate = function() {
      var playbackRate = vjs.TEST_VID.playbackRate;
      vjs.TEST_VID.playbackRate = (playbackRate / 2) + 0.1;
      return playbackRate !== vjs.TEST_VID.playbackRate;
    };
    vjs.Html5.supportsNativeTextTracks = function() {
      var supportsTextTracks;
      supportsTextTracks = !!vjs.TEST_VID.textTracks;
      if (supportsTextTracks && vjs.TEST_VID.textTracks.length > 0) {
        supportsTextTracks = typeof vjs.TEST_VID.textTracks[0]['mode'] !== 'number';
      }
      if (supportsTextTracks && vjs.IS_FIREFOX) {
        supportsTextTracks = false;
      }
      return supportsTextTracks;
    };
    vjs.Html5.prototype['featuresVolumeControl'] = vjs.Html5.canControlVolume();
    vjs.Html5.prototype['featuresPlaybackRate'] = vjs.Html5.canControlPlaybackRate();
    vjs.Html5.prototype['movingMediaElementInDOM'] = !vjs.IS_IOS;
    vjs.Html5.prototype['featuresFullscreenResize'] = true;
    vjs.Html5.prototype['featuresProgressEvents'] = true;
    vjs.Html5.prototype['featuresNativeTextTracks'] = vjs.Html5.supportsNativeTextTracks();
    (function() {
      var canPlayType,
          mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i,
          mp4RE = /^video\/mp4/i;
      vjs.Html5.patchCanPlayType = function() {
        if (vjs.ANDROID_VERSION >= 4.0) {
          if (!canPlayType) {
            canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
          }
          vjs.TEST_VID.constructor.prototype.canPlayType = function(type) {
            if (type && mpegurlRE.test(type)) {
              return 'maybe';
            }
            return canPlayType.call(this, type);
          };
        }
        if (vjs.IS_OLD_ANDROID) {
          if (!canPlayType) {
            canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
          }
          vjs.TEST_VID.constructor.prototype.canPlayType = function(type) {
            if (type && mp4RE.test(type)) {
              return 'maybe';
            }
            return canPlayType.call(this, type);
          };
        }
      };
      vjs.Html5.unpatchCanPlayType = function() {
        var r = vjs.TEST_VID.constructor.prototype.canPlayType;
        vjs.TEST_VID.constructor.prototype.canPlayType = canPlayType;
        canPlayType = null;
        return r;
      };
      vjs.Html5.patchCanPlayType();
    })();
    vjs.Html5.Events = 'loadstart,suspend,abort,error,emptied,stalled,loadedmetadata,loadeddata,canplay,canplaythrough,playing,waiting,seeking,seeked,ended,durationchange,timeupdate,progress,play,pause,ratechange,volumechange'.split(',');
    vjs.Html5.disposeMediaElement = function(el) {
      if (!el) {
        return;
      }
      el['player'] = null;
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
      while (el.hasChildNodes()) {
        el.removeChild(el.firstChild);
      }
      el.removeAttribute('src');
      if (typeof el.load === 'function') {
        (function() {
          try {
            el.load();
          } catch (e) {}
        })();
      }
    };
    vjs.Flash = vjs.MediaTechController.extend({init: function(player, options, ready) {
        vjs.MediaTechController.call(this, player, options, ready);
        var source = options['source'],
            objId = player.id() + '_flash_api',
            playerOptions = player.options_,
            flashVars = vjs.obj.merge({
              'readyFunction': 'videojs.Flash.onReady',
              'eventProxyFunction': 'videojs.Flash.onEvent',
              'errorEventProxyFunction': 'videojs.Flash.onError',
              'autoplay': playerOptions.autoplay,
              'preload': playerOptions.preload,
              'loop': playerOptions.loop,
              'muted': playerOptions.muted
            }, options['flashVars']),
            params = vjs.obj.merge({
              'wmode': 'opaque',
              'bgcolor': '#000000'
            }, options['params']),
            attributes = vjs.obj.merge({
              'id': objId,
              'name': objId,
              'class': 'vjs-tech'
            }, options['attributes']);
        ;
        if (source) {
          this.ready(function() {
            this.setSource(source);
          });
        }
        vjs.insertFirst(this.el_, options['parentEl']);
        if (options['startTime']) {
          this.ready(function() {
            this.load();
            this.play();
            this['currentTime'](options['startTime']);
          });
        }
        if (vjs.IS_FIREFOX) {
          this.ready(function() {
            this.on('mousemove', function() {
              this.player().trigger({
                'type': 'mousemove',
                'bubbles': false
              });
            });
          });
        }
        player.on('stageclick', player.reportUserActivity);
        this.el_ = vjs.Flash.embed(options['swf'], this.el_, flashVars, params, attributes);
      }});
    vjs.Flash.prototype.dispose = function() {
      vjs.MediaTechController.prototype.dispose.call(this);
    };
    vjs.Flash.prototype.play = function() {
      this.el_.vjs_play();
    };
    vjs.Flash.prototype.pause = function() {
      this.el_.vjs_pause();
    };
    vjs.Flash.prototype.src = function(src) {
      if (src === undefined) {
        return this['currentSrc']();
      }
      return this.setSrc(src);
    };
    vjs.Flash.prototype.setSrc = function(src) {
      src = vjs.getAbsoluteURL(src);
      this.el_.vjs_src(src);
      if (this.player_.autoplay()) {
        var tech = this;
        this.setTimeout(function() {
          tech.play();
        }, 0);
      }
    };
    vjs.Flash.prototype['setCurrentTime'] = function(time) {
      this.lastSeekTarget_ = time;
      this.el_.vjs_setProperty('currentTime', time);
      vjs.MediaTechController.prototype.setCurrentTime.call(this);
    };
    vjs.Flash.prototype['currentTime'] = function(time) {
      if (this.seeking()) {
        return this.lastSeekTarget_ || 0;
      }
      return this.el_.vjs_getProperty('currentTime');
    };
    vjs.Flash.prototype['currentSrc'] = function() {
      if (this.currentSource_) {
        return this.currentSource_.src;
      } else {
        return this.el_.vjs_getProperty('currentSrc');
      }
    };
    vjs.Flash.prototype.load = function() {
      this.el_.vjs_load();
    };
    vjs.Flash.prototype.poster = function() {
      this.el_.vjs_getProperty('poster');
    };
    vjs.Flash.prototype['setPoster'] = function() {};
    vjs.Flash.prototype.seekable = function() {
      var duration = this.duration();
      if (duration === 0) {
        return vjs.createTimeRange();
      }
      return vjs.createTimeRange(0, this.duration());
    };
    vjs.Flash.prototype.buffered = function() {
      if (!this.el_.vjs_getProperty) {
        return vjs.createTimeRange();
      }
      return vjs.createTimeRange(0, this.el_.vjs_getProperty('buffered'));
    };
    vjs.Flash.prototype.duration = function() {
      if (!this.el_.vjs_getProperty) {
        return 0;
      }
      return this.el_.vjs_getProperty('duration');
    };
    vjs.Flash.prototype.supportsFullScreen = function() {
      return false;
    };
    vjs.Flash.prototype.enterFullScreen = function() {
      return false;
    };
    (function() {
      var api = vjs.Flash.prototype,
          readWrite = 'rtmpConnection,rtmpStream,preload,defaultPlaybackRate,playbackRate,autoplay,loop,mediaGroup,controller,controls,volume,muted,defaultMuted'.split(','),
          readOnly = 'error,networkState,readyState,seeking,initialTime,startOffsetTime,paused,played,ended,videoTracks,audioTracks,videoWidth,videoHeight'.split(','),
          i;
      function createSetter(attr) {
        var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);
        api['set' + attrUpper] = function(val) {
          return this.el_.vjs_setProperty(attr, val);
        };
      }
      function createGetter(attr) {
        api[attr] = function() {
          return this.el_.vjs_getProperty(attr);
        };
      }
      for (i = 0; i < readWrite.length; i++) {
        createGetter(readWrite[i]);
        createSetter(readWrite[i]);
      }
      for (i = 0; i < readOnly.length; i++) {
        createGetter(readOnly[i]);
      }
    })();
    vjs.Flash.isSupported = function() {
      return vjs.Flash.version()[0] >= 10;
    };
    vjs.MediaTechController.withSourceHandlers(vjs.Flash);
    vjs.Flash['nativeSourceHandler'] = {};
    vjs.Flash['nativeSourceHandler']['canHandleSource'] = function(source) {
      var type;
      if (!source.type) {
        return '';
      }
      type = source.type.replace(/;.*/, '').toLowerCase();
      if (type in vjs.Flash.formats) {
        return 'maybe';
      }
      return '';
    };
    vjs.Flash['nativeSourceHandler']['handleSource'] = function(source, tech) {
      tech.setSrc(source.src);
    };
    vjs.Flash['nativeSourceHandler']['dispose'] = function() {};
    vjs.Flash['registerSourceHandler'](vjs.Flash['nativeSourceHandler']);
    vjs.Flash.formats = {
      'video/flv': 'FLV',
      'video/x-flv': 'FLV',
      'video/mp4': 'MP4',
      'video/m4v': 'MP4'
    };
    vjs.Flash['onReady'] = function(currSwf) {
      var el,
          player;
      el = vjs.el(currSwf);
      player = el && el.parentNode && el.parentNode['player'];
      if (player) {
        el['player'] = player;
        vjs.Flash['checkReady'](player.tech);
      }
    };
    vjs.Flash['checkReady'] = function(tech) {
      if (!tech.el()) {
        return;
      }
      if (tech.el().vjs_getProperty) {
        tech.triggerReady();
      } else {
        this.setTimeout(function() {
          vjs.Flash['checkReady'](tech);
        }, 50);
      }
    };
    vjs.Flash['onEvent'] = function(swfID, eventName) {
      var player = vjs.el(swfID)['player'];
      player.trigger(eventName);
    };
    vjs.Flash['onError'] = function(swfID, err) {
      var player = vjs.el(swfID)['player'];
      var msg = 'FLASH: ' + err;
      if (err == 'srcnotfound') {
        player.error({
          code: 4,
          message: msg
        });
      } else {
        player.error(msg);
      }
    };
    vjs.Flash.version = function() {
      var version = '0,0,0';
      try {
        version = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
      } catch (e) {
        try {
          if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
            version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
          }
        } catch (err) {}
      }
      return version.split(',');
    };
    vjs.Flash.embed = function(swf, placeHolder, flashVars, params, attributes) {
      var code = vjs.Flash.getEmbedCode(swf, flashVars, params, attributes),
          obj = vjs.createEl('div', {innerHTML: code}).childNodes[0],
          par = placeHolder.parentNode;
      ;
      placeHolder.parentNode.replaceChild(obj, placeHolder);
      obj[vjs.expando] = placeHolder[vjs.expando];
      var newObj = par.childNodes[0];
      setTimeout(function() {
        newObj.style.display = 'block';
      }, 1000);
      return obj;
    };
    vjs.Flash.getEmbedCode = function(swf, flashVars, params, attributes) {
      var objTag = '<object type="application/x-shockwave-flash" ',
          flashVarsString = '',
          paramsString = '',
          attrsString = '';
      if (flashVars) {
        vjs.obj.each(flashVars, function(key, val) {
          flashVarsString += (key + '=' + val + '&amp;');
        });
      }
      params = vjs.obj.merge({
        'movie': swf,
        'flashvars': flashVarsString,
        'allowScriptAccess': 'always',
        'allowNetworking': 'all'
      }, params);
      vjs.obj.each(params, function(key, val) {
        paramsString += '<param name="' + key + '" value="' + val + '" />';
      });
      attributes = vjs.obj.merge({
        'data': swf,
        'width': '100%',
        'height': '100%'
      }, attributes);
      vjs.obj.each(attributes, function(key, val) {
        attrsString += (key + '="' + val + '" ');
      });
      return objTag + attrsString + '>' + paramsString + '</object>';
    };
    vjs.Flash.streamingFormats = {
      'rtmp/mp4': 'MP4',
      'rtmp/flv': 'FLV'
    };
    vjs.Flash.streamFromParts = function(connection, stream) {
      return connection + '&' + stream;
    };
    vjs.Flash.streamToParts = function(src) {
      var parts = {
        connection: '',
        stream: ''
      };
      if (!src) {
        return parts;
      }
      var connEnd = src.indexOf('&');
      var streamBegin;
      if (connEnd !== -1) {
        streamBegin = connEnd + 1;
      } else {
        connEnd = streamBegin = src.lastIndexOf('/') + 1;
        if (connEnd === 0) {
          connEnd = streamBegin = src.length;
        }
      }
      parts.connection = src.substring(0, connEnd);
      parts.stream = src.substring(streamBegin, src.length);
      return parts;
    };
    vjs.Flash.isStreamingType = function(srcType) {
      return srcType in vjs.Flash.streamingFormats;
    };
    vjs.Flash.RTMP_RE = /^rtmp[set]?:\/\//i;
    vjs.Flash.isStreamingSrc = function(src) {
      return vjs.Flash.RTMP_RE.test(src);
    };
    vjs.Flash.rtmpSourceHandler = {};
    vjs.Flash.rtmpSourceHandler['canHandleSource'] = function(source) {
      if (vjs.Flash.isStreamingType(source.type) || vjs.Flash.isStreamingSrc(source.src)) {
        return 'maybe';
      }
      return '';
    };
    vjs.Flash.rtmpSourceHandler['handleSource'] = function(source, tech) {
      var srcParts = vjs.Flash.streamToParts(source.src);
      tech['setRtmpConnection'](srcParts.connection);
      tech['setRtmpStream'](srcParts.stream);
    };
    vjs.Flash['registerSourceHandler'](vjs.Flash.rtmpSourceHandler);
    vjs.MediaLoader = vjs.Component.extend({init: function(player, options, ready) {
        vjs.Component.call(this, player, options, ready);
        if (!player.options_['sources'] || player.options_['sources'].length === 0) {
          for (var i = 0,
              j = player.options_['techOrder']; i < j.length; i++) {
            var techName = vjs.capitalize(j[i]),
                tech = window['videojs'][techName];
            if (tech && tech.isSupported()) {
              player.loadTech(techName);
              break;
            }
          }
        } else {
          player.src(player.options_['sources']);
        }
      }});
    vjs.TextTrackMode = {
      'disabled': 'disabled',
      'hidden': 'hidden',
      'showing': 'showing'
    };
    vjs.TextTrackKind = {
      'subtitles': 'subtitles',
      'captions': 'captions',
      'descriptions': 'descriptions',
      'chapters': 'chapters',
      'metadata': 'metadata'
    };
    (function() {
      vjs.TextTrack = function(options) {
        var tt,
            id,
            mode,
            kind,
            label,
            language,
            cues,
            activeCues,
            timeupdateHandler,
            changed,
            prop;
        options = options || {};
        if (!options['player']) {
          throw new Error('A player was not provided.');
        }
        tt = this;
        if (vjs.IS_IE8) {
          tt = document.createElement('custom');
          for (prop in vjs.TextTrack.prototype) {
            tt[prop] = vjs.TextTrack.prototype[prop];
          }
        }
        tt.player_ = options['player'];
        mode = vjs.TextTrackMode[options['mode']] || 'disabled';
        kind = vjs.TextTrackKind[options['kind']] || 'subtitles';
        label = options['label'] || '';
        language = options['language'] || options['srclang'] || '';
        id = options['id'] || 'vjs_text_track_' + vjs.guid++;
        if (kind === 'metadata' || kind === 'chapters') {
          mode = 'hidden';
        }
        tt.cues_ = [];
        tt.activeCues_ = [];
        cues = new vjs.TextTrackCueList(tt.cues_);
        activeCues = new vjs.TextTrackCueList(tt.activeCues_);
        changed = false;
        timeupdateHandler = vjs.bind(tt, function() {
          this['activeCues'];
          if (changed) {
            this['trigger']('cuechange');
            changed = false;
          }
        });
        if (mode !== 'disabled') {
          tt.player_.on('timeupdate', timeupdateHandler);
        }
        Object.defineProperty(tt, 'kind', {
          get: function() {
            return kind;
          },
          set: Function.prototype
        });
        Object.defineProperty(tt, 'label', {
          get: function() {
            return label;
          },
          set: Function.prototype
        });
        Object.defineProperty(tt, 'language', {
          get: function() {
            return language;
          },
          set: Function.prototype
        });
        Object.defineProperty(tt, 'id', {
          get: function() {
            return id;
          },
          set: Function.prototype
        });
        Object.defineProperty(tt, 'mode', {
          get: function() {
            return mode;
          },
          set: function(newMode) {
            if (!vjs.TextTrackMode[newMode]) {
              return;
            }
            mode = newMode;
            if (mode === 'showing') {
              this.player_.on('timeupdate', timeupdateHandler);
            }
            this.trigger('modechange');
          }
        });
        Object.defineProperty(tt, 'cues', {
          get: function() {
            if (!this.loaded_) {
              return null;
            }
            return cues;
          },
          set: Function.prototype
        });
        Object.defineProperty(tt, 'activeCues', {
          get: function() {
            var i,
                l,
                active,
                ct,
                cue;
            if (!this.loaded_) {
              return null;
            }
            if (this['cues'].length === 0) {
              return activeCues;
            }
            ct = this.player_.currentTime();
            i = 0;
            l = this['cues'].length;
            active = [];
            for (; i < l; i++) {
              cue = this['cues'][i];
              if (cue['startTime'] <= ct && cue['endTime'] >= ct) {
                active.push(cue);
              } else if (cue['startTime'] === cue['endTime'] && cue['startTime'] <= ct && cue['startTime'] + 0.5 >= ct) {
                active.push(cue);
              }
            }
            changed = false;
            if (active.length !== this.activeCues_.length) {
              changed = true;
            } else {
              for (i = 0; i < active.length; i++) {
                if (indexOf.call(this.activeCues_, active[i]) === -1) {
                  changed = true;
                }
              }
            }
            this.activeCues_ = active;
            activeCues.setCues_(this.activeCues_);
            return activeCues;
          },
          set: Function.prototype
        });
        if (options.src) {
          loadTrack(options.src, tt);
        } else {
          tt.loaded_ = true;
        }
        if (vjs.IS_IE8) {
          return tt;
        }
      };
      vjs.TextTrack.prototype = vjs.obj.create(vjs.EventEmitter.prototype);
      vjs.TextTrack.prototype.constructor = vjs.TextTrack;
      vjs.TextTrack.prototype.allowedEvents_ = {'cuechange': 'cuechange'};
      vjs.TextTrack.prototype.addCue = function(cue) {
        var tracks = this.player_.textTracks(),
            i = 0;
        if (tracks) {
          for (; i < tracks.length; i++) {
            if (tracks[i] !== this) {
              tracks[i].removeCue(cue);
            }
          }
        }
        this.cues_.push(cue);
        this['cues'].setCues_(this.cues_);
      };
      vjs.TextTrack.prototype.removeCue = function(removeCue) {
        var i = 0,
            l = this.cues_.length,
            cue,
            removed = false;
        for (; i < l; i++) {
          cue = this.cues_[i];
          if (cue === removeCue) {
            this.cues_.splice(i, 1);
            removed = true;
          }
        }
        if (removed) {
          this.cues.setCues_(this.cues_);
        }
      };
      var loadTrack,
          parseCues,
          indexOf;
      loadTrack = function(src, track) {
        vjs.xhr(src, vjs.bind(this, function(err, response, responseBody) {
          if (err) {
            return vjs.log.error(err);
          }
          track.loaded_ = true;
          parseCues(responseBody, track);
        }));
      };
      parseCues = function(srcContent, track) {
        if (typeof window['WebVTT'] !== 'function') {
          return window.setTimeout(function() {
            parseCues(srcContent, track);
          }, 25);
        }
        var parser = new window['WebVTT']['Parser'](window, window['vttjs'], window['WebVTT']['StringDecoder']());
        parser['oncue'] = function(cue) {
          track.addCue(cue);
        };
        parser['onparsingerror'] = function(error) {
          vjs.log.error(error);
        };
        parser['parse'](srcContent);
        parser['flush']();
      };
      indexOf = function(searchElement, fromIndex) {
        var k;
        if (this == null) {
          throw new TypeError('"this" is null or not defined');
        }
        var O = Object(this);
        var len = O.length >>> 0;
        if (len === 0) {
          return -1;
        }
        var n = +fromIndex || 0;
        if (Math.abs(n) === Infinity) {
          n = 0;
        }
        if (n >= len) {
          return -1;
        }
        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
        while (k < len) {
          if (k in O && O[k] === searchElement) {
            return k;
          }
          k++;
        }
        return -1;
      };
    })();
    vjs.TextTrackList = function(tracks) {
      var list = this,
          prop,
          i = 0;
      if (vjs.IS_IE8) {
        list = document.createElement('custom');
        for (prop in vjs.TextTrackList.prototype) {
          list[prop] = vjs.TextTrackList.prototype[prop];
        }
      }
      tracks = tracks || [];
      list.tracks_ = [];
      Object.defineProperty(list, 'length', {get: function() {
          return this.tracks_.length;
        }});
      for (; i < tracks.length; i++) {
        list.addTrack_(tracks[i]);
      }
      if (vjs.IS_IE8) {
        return list;
      }
    };
    vjs.TextTrackList.prototype = vjs.obj.create(vjs.EventEmitter.prototype);
    vjs.TextTrackList.prototype.constructor = vjs.TextTrackList;
    vjs.TextTrackList.prototype.allowedEvents_ = {
      'change': 'change',
      'addtrack': 'addtrack',
      'removetrack': 'removetrack'
    };
    (function() {
      var event;
      for (event in vjs.TextTrackList.prototype.allowedEvents_) {
        vjs.TextTrackList.prototype['on' + event] = null;
      }
    })();
    vjs.TextTrackList.prototype.addTrack_ = function(track) {
      var index = this.tracks_.length;
      if (!('' + index in this)) {
        Object.defineProperty(this, index, {get: function() {
            return this.tracks_[index];
          }});
      }
      track.addEventListener('modechange', vjs.bind(this, function() {
        this.trigger('change');
      }));
      this.tracks_.push(track);
      this.trigger({
        type: 'addtrack',
        track: track
      });
    };
    vjs.TextTrackList.prototype.removeTrack_ = function(rtrack) {
      var i = 0,
          l = this.length,
          result = null,
          track;
      for (; i < l; i++) {
        track = this[i];
        if (track === rtrack) {
          this.tracks_.splice(i, 1);
          break;
        }
      }
      this.trigger({
        type: 'removetrack',
        track: rtrack
      });
    };
    vjs.TextTrackList.prototype.getTrackById = function(id) {
      var i = 0,
          l = this.length,
          result = null,
          track;
      for (; i < l; i++) {
        track = this[i];
        if (track.id === id) {
          result = track;
          break;
        }
      }
      return result;
    };
    vjs.TextTrackCueList = function(cues) {
      var list = this,
          prop;
      if (vjs.IS_IE8) {
        list = document.createElement('custom');
        for (prop in vjs.TextTrackCueList.prototype) {
          list[prop] = vjs.TextTrackCueList.prototype[prop];
        }
      }
      vjs.TextTrackCueList.prototype.setCues_.call(list, cues);
      Object.defineProperty(list, 'length', {get: function() {
          return this.length_;
        }});
      if (vjs.IS_IE8) {
        return list;
      }
    };
    vjs.TextTrackCueList.prototype.setCues_ = function(cues) {
      var oldLength = this.length || 0,
          i = 0,
          l = cues.length,
          defineProp;
      this.cues_ = cues;
      this.length_ = cues.length;
      defineProp = function(i) {
        if (!('' + i in this)) {
          Object.defineProperty(this, '' + i, {get: function() {
              return this.cues_[i];
            }});
        }
      };
      if (oldLength < l) {
        i = oldLength;
        for (; i < l; i++) {
          defineProp.call(this, i);
        }
      }
    };
    vjs.TextTrackCueList.prototype.getCueById = function(id) {
      var i = 0,
          l = this.length,
          result = null,
          cue;
      for (; i < l; i++) {
        cue = this[i];
        if (cue.id === id) {
          result = cue;
          break;
        }
      }
      return result;
    };
    (function() {
      'use strict';
      vjs.TextTrackDisplay = vjs.Component.extend({init: function(player, options, ready) {
          vjs.Component.call(this, player, options, ready);
          player.on('loadstart', vjs.bind(this, this.toggleDisplay));
          player.ready(vjs.bind(this, function() {
            if (player.tech && player.tech['featuresNativeTextTracks']) {
              this.hide();
              return;
            }
            var i,
                tracks,
                track;
            player.on('fullscreenchange', vjs.bind(this, this.updateDisplay));
            tracks = player.options_['tracks'] || [];
            for (i = 0; i < tracks.length; i++) {
              track = tracks[i];
              this.player_.addRemoteTextTrack(track);
            }
          }));
        }});
      vjs.TextTrackDisplay.prototype.toggleDisplay = function() {
        if (this.player_.tech && this.player_.tech['featuresNativeTextTracks']) {
          this.hide();
        } else {
          this.show();
        }
      };
      vjs.TextTrackDisplay.prototype.createEl = function() {
        return vjs.Component.prototype.createEl.call(this, 'div', {className: 'vjs-text-track-display'});
      };
      vjs.TextTrackDisplay.prototype.clearDisplay = function() {
        if (typeof window['WebVTT'] === 'function') {
          window['WebVTT']['processCues'](window, [], this.el_);
        }
      };
      var constructColor = function(color, opacity) {
        return 'rgba(' + parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';
      };
      var darkGray = '#222';
      var lightGray = '#ccc';
      var fontMap = {
        monospace: 'monospace',
        sansSerif: 'sans-serif',
        serif: 'serif',
        monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
        monospaceSerif: '"Courier New", monospace',
        proportionalSansSerif: 'sans-serif',
        proportionalSerif: 'serif',
        casual: '"Comic Sans MS", Impact, fantasy',
        script: '"Monotype Corsiva", cursive',
        smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
      };
      var tryUpdateStyle = function(el, style, rule) {
        try {
          el.style[style] = rule;
        } catch (e) {}
      };
      vjs.TextTrackDisplay.prototype.updateDisplay = function() {
        var tracks = this.player_.textTracks(),
            i = 0,
            track;
        this.clearDisplay();
        if (!tracks) {
          return;
        }
        for (; i < tracks.length; i++) {
          track = tracks[i];
          if (track['mode'] === 'showing') {
            this.updateForTrack(track);
          }
        }
      };
      vjs.TextTrackDisplay.prototype.updateForTrack = function(track) {
        if (typeof window['WebVTT'] !== 'function' || !track['activeCues']) {
          return;
        }
        var i = 0,
            property,
            cueDiv,
            overrides = this.player_['textTrackSettings'].getValues(),
            fontSize,
            cues = [];
        for (; i < track['activeCues'].length; i++) {
          cues.push(track['activeCues'][i]);
        }
        window['WebVTT']['processCues'](window, track['activeCues'], this.el_);
        i = cues.length;
        while (i--) {
          cueDiv = cues[i].displayState;
          if (overrides.color) {
            cueDiv.firstChild.style.color = overrides.color;
          }
          if (overrides.textOpacity) {
            tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
          }
          if (overrides.backgroundColor) {
            cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
          }
          if (overrides.backgroundOpacity) {
            tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
          }
          if (overrides.windowColor) {
            if (overrides.windowOpacity) {
              tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
            } else {
              cueDiv.style.backgroundColor = overrides.windowColor;
            }
          }
          if (overrides.edgeStyle) {
            if (overrides.edgeStyle === 'dropshadow') {
              cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
            } else if (overrides.edgeStyle === 'raised') {
              cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
            } else if (overrides.edgeStyle === 'depressed') {
              cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
            } else if (overrides.edgeStyle === 'uniform') {
              cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
            }
          }
          if (overrides.fontPercent && overrides.fontPercent !== 1) {
            fontSize = window.parseFloat(cueDiv.style.fontSize);
            cueDiv.style.fontSize = (fontSize * overrides.fontPercent) + 'px';
            cueDiv.style.height = 'auto';
            cueDiv.style.top = 'auto';
            cueDiv.style.bottom = '2px';
          }
          if (overrides.fontFamily && overrides.fontFamily !== 'default') {
            if (overrides.fontFamily === 'small-caps') {
              cueDiv.firstChild.style.fontVariant = 'small-caps';
            } else {
              cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
            }
          }
        }
      };
      vjs.TextTrackMenuItem = vjs.MenuItem.extend({init: function(player, options) {
          var track = this.track = options['track'],
              tracks = player.textTracks(),
              changeHandler,
              event;
          if (tracks) {
            changeHandler = vjs.bind(this, function() {
              var selected = this.track['mode'] === 'showing',
                  track,
                  i,
                  l;
              if (this instanceof vjs.OffTextTrackMenuItem) {
                selected = true;
                i = 0, l = tracks.length;
                for (; i < l; i++) {
                  track = tracks[i];
                  if (track['kind'] === this.track['kind'] && track['mode'] === 'showing') {
                    selected = false;
                    break;
                  }
                }
              }
              this.selected(selected);
            });
            tracks.addEventListener('change', changeHandler);
            player.on('dispose', function() {
              tracks.removeEventListener('change', changeHandler);
            });
          }
          options['label'] = track['label'] || track['language'] || 'Unknown';
          options['selected'] = track['default'] || track['mode'] === 'showing';
          vjs.MenuItem.call(this, player, options);
          if (tracks && tracks.onchange === undefined) {
            this.on(['tap', 'click'], function() {
              if (typeof window.Event !== 'object') {
                try {
                  event = new window.Event('change');
                } catch (err) {}
              }
              if (!event) {
                event = document.createEvent('Event');
                event.initEvent('change', true, true);
              }
              tracks.dispatchEvent(event);
            });
          }
        }});
      vjs.TextTrackMenuItem.prototype.onClick = function() {
        var kind = this.track['kind'],
            tracks = this.player_.textTracks(),
            mode,
            track,
            i = 0;
        vjs.MenuItem.prototype.onClick.call(this);
        if (!tracks) {
          return;
        }
        for (; i < tracks.length; i++) {
          track = tracks[i];
          if (track['kind'] !== kind) {
            continue;
          }
          if (track === this.track) {
            track['mode'] = 'showing';
          } else {
            track['mode'] = 'disabled';
          }
        }
      };
      vjs.OffTextTrackMenuItem = vjs.TextTrackMenuItem.extend({init: function(player, options) {
          options['track'] = {
            'kind': options['kind'],
            'player': player,
            'label': options['kind'] + ' off',
            'default': false,
            'mode': 'disabled'
          };
          vjs.TextTrackMenuItem.call(this, player, options);
          this.selected(true);
        }});
      vjs.CaptionSettingsMenuItem = vjs.TextTrackMenuItem.extend({init: function(player, options) {
          options['track'] = {
            'kind': options['kind'],
            'player': player,
            'label': options['kind'] + ' settings',
            'default': false,
            mode: 'disabled'
          };
          vjs.TextTrackMenuItem.call(this, player, options);
          this.addClass('vjs-texttrack-settings');
        }});
      vjs.CaptionSettingsMenuItem.prototype.onClick = function() {
        this.player().getChild('textTrackSettings').show();
      };
      vjs.TextTrackButton = vjs.MenuButton.extend({init: function(player, options) {
          var tracks,
              updateHandler;
          vjs.MenuButton.call(this, player, options);
          tracks = this.player_.textTracks();
          if (this.items.length <= 1) {
            this.hide();
          }
          if (!tracks) {
            return;
          }
          updateHandler = vjs.bind(this, this.update);
          tracks.addEventListener('removetrack', updateHandler);
          tracks.addEventListener('addtrack', updateHandler);
          this.player_.on('dispose', function() {
            tracks.removeEventListener('removetrack', updateHandler);
            tracks.removeEventListener('addtrack', updateHandler);
          });
        }});
      vjs.TextTrackButton.prototype.createItems = function() {
        var items = [],
            track,
            tracks;
        if (this instanceof vjs.CaptionsButton && !(this.player().tech && this.player().tech['featuresNativeTextTracks'])) {
          items.push(new vjs.CaptionSettingsMenuItem(this.player_, {'kind': this.kind_}));
        }
        items.push(new vjs.OffTextTrackMenuItem(this.player_, {'kind': this.kind_}));
        tracks = this.player_.textTracks();
        if (!tracks) {
          return items;
        }
        for (var i = 0; i < tracks.length; i++) {
          track = tracks[i];
          if (track['kind'] === this.kind_) {
            items.push(new vjs.TextTrackMenuItem(this.player_, {'track': track}));
          }
        }
        return items;
      };
      vjs.CaptionsButton = vjs.TextTrackButton.extend({init: function(player, options, ready) {
          vjs.TextTrackButton.call(this, player, options, ready);
          this.el_.setAttribute('aria-label', 'Captions Menu');
        }});
      vjs.CaptionsButton.prototype.kind_ = 'captions';
      vjs.CaptionsButton.prototype.buttonText = 'Captions';
      vjs.CaptionsButton.prototype.className = 'vjs-captions-button';
      vjs.CaptionsButton.prototype.update = function() {
        var threshold = 2;
        vjs.TextTrackButton.prototype.update.call(this);
        if (this.player().tech && this.player().tech['featuresNativeTextTracks']) {
          threshold = 1;
        }
        if (this.items && this.items.length > threshold) {
          this.show();
        } else {
          this.hide();
        }
      };
      vjs.SubtitlesButton = vjs.TextTrackButton.extend({init: function(player, options, ready) {
          vjs.TextTrackButton.call(this, player, options, ready);
          this.el_.setAttribute('aria-label', 'Subtitles Menu');
        }});
      vjs.SubtitlesButton.prototype.kind_ = 'subtitles';
      vjs.SubtitlesButton.prototype.buttonText = 'Subtitles';
      vjs.SubtitlesButton.prototype.className = 'vjs-subtitles-button';
      vjs.ChaptersButton = vjs.TextTrackButton.extend({init: function(player, options, ready) {
          vjs.TextTrackButton.call(this, player, options, ready);
          this.el_.setAttribute('aria-label', 'Chapters Menu');
        }});
      vjs.ChaptersButton.prototype.kind_ = 'chapters';
      vjs.ChaptersButton.prototype.buttonText = 'Chapters';
      vjs.ChaptersButton.prototype.className = 'vjs-chapters-button';
      vjs.ChaptersButton.prototype.createItems = function() {
        var items = [],
            track,
            tracks;
        tracks = this.player_.textTracks();
        if (!tracks) {
          return items;
        }
        for (var i = 0; i < tracks.length; i++) {
          track = tracks[i];
          if (track['kind'] === this.kind_) {
            items.push(new vjs.TextTrackMenuItem(this.player_, {'track': track}));
          }
        }
        return items;
      };
      vjs.ChaptersButton.prototype.createMenu = function() {
        var tracks = this.player_.textTracks() || [],
            i = 0,
            l = tracks.length,
            track,
            chaptersTrack,
            items = this.items = [];
        for (; i < l; i++) {
          track = tracks[i];
          if (track['kind'] == this.kind_) {
            if (!track.cues) {
              track['mode'] = 'hidden';
              window.setTimeout(vjs.bind(this, function() {
                this.createMenu();
              }), 100);
            } else {
              chaptersTrack = track;
              break;
            }
          }
        }
        var menu = this.menu;
        if (menu === undefined) {
          menu = new vjs.Menu(this.player_);
          menu.contentEl().appendChild(vjs.createEl('li', {
            className: 'vjs-menu-title',
            innerHTML: vjs.capitalize(this.kind_),
            tabindex: -1
          }));
        }
        if (chaptersTrack) {
          var cues = chaptersTrack['cues'],
              cue,
              mi;
          i = 0;
          l = cues.length;
          for (; i < l; i++) {
            cue = cues[i];
            mi = new vjs.ChaptersTrackMenuItem(this.player_, {
              'track': chaptersTrack,
              'cue': cue
            });
            items.push(mi);
            menu.addChild(mi);
          }
          this.addChild(menu);
        }
        if (this.items.length > 0) {
          this.show();
        }
        return menu;
      };
      vjs.ChaptersTrackMenuItem = vjs.MenuItem.extend({init: function(player, options) {
          var track = this.track = options['track'],
              cue = this.cue = options['cue'],
              currentTime = player.currentTime();
          options['label'] = cue.text;
          options['selected'] = (cue['startTime'] <= currentTime && currentTime < cue['endTime']);
          vjs.MenuItem.call(this, player, options);
          track.addEventListener('cuechange', vjs.bind(this, this.update));
        }});
      vjs.ChaptersTrackMenuItem.prototype.onClick = function() {
        vjs.MenuItem.prototype.onClick.call(this);
        this.player_.currentTime(this.cue.startTime);
        this.update(this.cue.startTime);
      };
      vjs.ChaptersTrackMenuItem.prototype.update = function() {
        var cue = this.cue,
            currentTime = this.player_.currentTime();
        this.selected(cue['startTime'] <= currentTime && currentTime < cue['endTime']);
      };
    })();
    (function() {
      'use strict';
      vjs.TextTrackSettings = vjs.Component.extend({init: function(player, options) {
          vjs.Component.call(this, player, options);
          this.hide();
          vjs.on(this.el().querySelector('.vjs-done-button'), 'click', vjs.bind(this, function() {
            this.saveSettings();
            this.hide();
          }));
          vjs.on(this.el().querySelector('.vjs-default-button'), 'click', vjs.bind(this, function() {
            this.el().querySelector('.vjs-fg-color > select').selectedIndex = 0;
            this.el().querySelector('.vjs-bg-color > select').selectedIndex = 0;
            this.el().querySelector('.window-color > select').selectedIndex = 0;
            this.el().querySelector('.vjs-text-opacity > select').selectedIndex = 0;
            this.el().querySelector('.vjs-bg-opacity > select').selectedIndex = 0;
            this.el().querySelector('.vjs-window-opacity > select').selectedIndex = 0;
            this.el().querySelector('.vjs-edge-style select').selectedIndex = 0;
            this.el().querySelector('.vjs-font-family select').selectedIndex = 0;
            this.el().querySelector('.vjs-font-percent select').selectedIndex = 2;
            this.updateDisplay();
          }));
          vjs.on(this.el().querySelector('.vjs-fg-color > select'), 'change', vjs.bind(this, this.updateDisplay));
          vjs.on(this.el().querySelector('.vjs-bg-color > select'), 'change', vjs.bind(this, this.updateDisplay));
          vjs.on(this.el().querySelector('.window-color > select'), 'change', vjs.bind(this, this.updateDisplay));
          vjs.on(this.el().querySelector('.vjs-text-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
          vjs.on(this.el().querySelector('.vjs-bg-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
          vjs.on(this.el().querySelector('.vjs-window-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
          vjs.on(this.el().querySelector('.vjs-font-percent select'), 'change', vjs.bind(this, this.updateDisplay));
          vjs.on(this.el().querySelector('.vjs-edge-style select'), 'change', vjs.bind(this, this.updateDisplay));
          vjs.on(this.el().querySelector('.vjs-font-family select'), 'change', vjs.bind(this, this.updateDisplay));
          if (player.options()['persistTextTrackSettings']) {
            this.restoreSettings();
          }
        }});
      vjs.TextTrackSettings.prototype.createEl = function() {
        return vjs.Component.prototype.createEl.call(this, 'div', {
          className: 'vjs-caption-settings vjs-modal-overlay',
          innerHTML: captionOptionsMenuTemplate()
        });
      };
      vjs.TextTrackSettings.prototype.getValues = function() {
        var el,
            bgOpacity,
            textOpacity,
            windowOpacity,
            textEdge,
            fontFamily,
            fgColor,
            bgColor,
            windowColor,
            result,
            name,
            fontPercent;
        el = this.el();
        textEdge = getSelectedOptionValue(el.querySelector('.vjs-edge-style select'));
        fontFamily = getSelectedOptionValue(el.querySelector('.vjs-font-family select'));
        fgColor = getSelectedOptionValue(el.querySelector('.vjs-fg-color > select'));
        textOpacity = getSelectedOptionValue(el.querySelector('.vjs-text-opacity > select'));
        bgColor = getSelectedOptionValue(el.querySelector('.vjs-bg-color > select'));
        bgOpacity = getSelectedOptionValue(el.querySelector('.vjs-bg-opacity > select'));
        windowColor = getSelectedOptionValue(el.querySelector('.window-color > select'));
        windowOpacity = getSelectedOptionValue(el.querySelector('.vjs-window-opacity > select'));
        fontPercent = window['parseFloat'](getSelectedOptionValue(el.querySelector('.vjs-font-percent > select')));
        result = {
          'backgroundOpacity': bgOpacity,
          'textOpacity': textOpacity,
          'windowOpacity': windowOpacity,
          'edgeStyle': textEdge,
          'fontFamily': fontFamily,
          'color': fgColor,
          'backgroundColor': bgColor,
          'windowColor': windowColor,
          'fontPercent': fontPercent
        };
        for (name in result) {
          if (result[name] === '' || result[name] === 'none' || (name === 'fontPercent' && result[name] === 1.00)) {
            delete result[name];
          }
        }
        return result;
      };
      vjs.TextTrackSettings.prototype.setValues = function(values) {
        var el = this.el(),
            fontPercent;
        setSelectedOption(el.querySelector('.vjs-edge-style select'), values.edgeStyle);
        setSelectedOption(el.querySelector('.vjs-font-family select'), values.fontFamily);
        setSelectedOption(el.querySelector('.vjs-fg-color > select'), values.color);
        setSelectedOption(el.querySelector('.vjs-text-opacity > select'), values.textOpacity);
        setSelectedOption(el.querySelector('.vjs-bg-color > select'), values.backgroundColor);
        setSelectedOption(el.querySelector('.vjs-bg-opacity > select'), values.backgroundOpacity);
        setSelectedOption(el.querySelector('.window-color > select'), values.windowColor);
        setSelectedOption(el.querySelector('.vjs-window-opacity > select'), values.windowOpacity);
        fontPercent = values.fontPercent;
        if (fontPercent) {
          fontPercent = fontPercent.toFixed(2);
        }
        setSelectedOption(el.querySelector('.vjs-font-percent > select'), fontPercent);
      };
      vjs.TextTrackSettings.prototype.restoreSettings = function() {
        var values;
        try {
          values = JSON.parse(window.localStorage.getItem('vjs-text-track-settings'));
        } catch (e) {}
        if (values) {
          this.setValues(values);
        }
      };
      vjs.TextTrackSettings.prototype.saveSettings = function() {
        var values;
        if (!this.player_.options()['persistTextTrackSettings']) {
          return;
        }
        values = this.getValues();
        try {
          if (!vjs.isEmpty(values)) {
            window.localStorage.setItem('vjs-text-track-settings', JSON.stringify(values));
          } else {
            window.localStorage.removeItem('vjs-text-track-settings');
          }
        } catch (e) {}
      };
      vjs.TextTrackSettings.prototype.updateDisplay = function() {
        var ttDisplay = this.player_.getChild('textTrackDisplay');
        if (ttDisplay) {
          ttDisplay.updateDisplay();
        }
      };
      function getSelectedOptionValue(target) {
        var selectedOption;
        if (target.selectedOptions) {
          selectedOption = target.selectedOptions[0];
        } else if (target.options) {
          selectedOption = target.options[target.options.selectedIndex];
        }
        return selectedOption.value;
      }
      function setSelectedOption(target, value) {
        var i,
            option;
        if (!value) {
          return;
        }
        for (i = 0; i < target.options.length; i++) {
          option = target.options[i];
          if (option.value === value) {
            break;
          }
        }
        target.selectedIndex = i;
      }
      function captionOptionsMenuTemplate() {
        return '<div class="vjs-tracksettings">' + '<div class="vjs-tracksettings-colors">' + '<div class="vjs-fg-color vjs-tracksetting">' + '<label class="vjs-label">Foreground</label>' + '<select>' + '<option value="">---</option>' + '<option value="#FFF">White</option>' + '<option value="#000">Black</option>' + '<option value="#F00">Red</option>' + '<option value="#0F0">Green</option>' + '<option value="#00F">Blue</option>' + '<option value="#FF0">Yellow</option>' + '<option value="#F0F">Magenta</option>' + '<option value="#0FF">Cyan</option>' + '</select>' + '<span class="vjs-text-opacity vjs-opacity">' + '<select>' + '<option value="">---</option>' + '<option value="1">Opaque</option>' + '<option value="0.5">Semi-Opaque</option>' + '</select>' + '</span>' + '</div>' + '<div class="vjs-bg-color vjs-tracksetting">' + '<label class="vjs-label">Background</label>' + '<select>' + '<option value="">---</option>' + '<option value="#FFF">White</option>' + '<option value="#000">Black</option>' + '<option value="#F00">Red</option>' + '<option value="#0F0">Green</option>' + '<option value="#00F">Blue</option>' + '<option value="#FF0">Yellow</option>' + '<option value="#F0F">Magenta</option>' + '<option value="#0FF">Cyan</option>' + '</select>' + '<span class="vjs-bg-opacity vjs-opacity">' + '<select>' + '<option value="">---</option>' + '<option value="1">Opaque</option>' + '<option value="0.5">Semi-Transparent</option>' + '<option value="0">Transparent</option>' + '</select>' + '</span>' + '</div>' + '<div class="window-color vjs-tracksetting">' + '<label class="vjs-label">Window</label>' + '<select>' + '<option value="">---</option>' + '<option value="#FFF">White</option>' + '<option value="#000">Black</option>' + '<option value="#F00">Red</option>' + '<option value="#0F0">Green</option>' + '<option value="#00F">Blue</option>' + '<option value="#FF0">Yellow</option>' + '<option value="#F0F">Magenta</option>' + '<option value="#0FF">Cyan</option>' + '</select>' + '<span class="vjs-window-opacity vjs-opacity">' + '<select>' + '<option value="">---</option>' + '<option value="1">Opaque</option>' + '<option value="0.5">Semi-Transparent</option>' + '<option value="0">Transparent</option>' + '</select>' + '</span>' + '</div>' + '</div>' + '<div class="vjs-tracksettings-font">' + '<div class="vjs-font-percent vjs-tracksetting">' + '<label class="vjs-label">Font Size</label>' + '<select>' + '<option value="0.50">50%</option>' + '<option value="0.75">75%</option>' + '<option value="1.00" selected>100%</option>' + '<option value="1.25">125%</option>' + '<option value="1.50">150%</option>' + '<option value="1.75">175%</option>' + '<option value="2.00">200%</option>' + '<option value="3.00">300%</option>' + '<option value="4.00">400%</option>' + '</select>' + '</div>' + '<div class="vjs-edge-style vjs-tracksetting">' + '<label class="vjs-label">Text Edge Style</label>' + '<select>' + '<option value="none">None</option>' + '<option value="raised">Raised</option>' + '<option value="depressed">Depressed</option>' + '<option value="uniform">Uniform</option>' + '<option value="dropshadow">Dropshadow</option>' + '</select>' + '</div>' + '<div class="vjs-font-family vjs-tracksetting">' + '<label class="vjs-label">Font Family</label>' + '<select>' + '<option value="">Default</option>' + '<option value="monospaceSerif">Monospace Serif</option>' + '<option value="proportionalSerif">Proportional Serif</option>' + '<option value="monospaceSansSerif">Monospace Sans-Serif</option>' + '<option value="proportionalSansSerif">Proportional Sans-Serif</option>' + '<option value="casual">Casual</option>' + '<option value="script">Script</option>' + '<option value="small-caps">Small Caps</option>' + '</select>' + '</div>' + '</div>' + '</div>' + '<div class="vjs-tracksettings-controls">' + '<button class="vjs-default-button">Defaults</button>' + '<button class="vjs-done-button">Done</button>' + '</div>';
      }
    })();
    vjs.JSON;
    if (typeof window.JSON !== 'undefined' && typeof window.JSON.parse === 'function') {
      vjs.JSON = window.JSON;
    } else {
      vjs.JSON = {};
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      vjs.JSON.parse = function(text, reviver) {
        var j;
        function walk(holder, key) {
          var k,
              v,
              value = holder[key];
          if (value && typeof value === 'object') {
            for (k in value) {
              if (Object.prototype.hasOwnProperty.call(value, k)) {
                v = walk(value, k);
                if (v !== undefined) {
                  value[k] = v;
                } else {
                  delete value[k];
                }
              }
            }
          }
          return reviver.call(holder, key, value);
        }
        text = String(text);
        cx.lastIndex = 0;
        if (cx.test(text)) {
          text = text.replace(cx, function(a) {
            return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
          });
        }
        if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
          j = eval('(' + text + ')');
          return typeof reviver === 'function' ? walk({'': j}, '') : j;
        }
        throw new SyntaxError('JSON.parse(): invalid or malformed JSON data');
      };
    }
    vjs.autoSetup = function() {
      var options,
          mediaEl,
          player,
          i,
          e;
      var vids = document.getElementsByTagName('video');
      var audios = document.getElementsByTagName('audio');
      var mediaEls = [];
      if (vids && vids.length > 0) {
        for (i = 0, e = vids.length; i < e; i++) {
          mediaEls.push(vids[i]);
        }
      }
      if (audios && audios.length > 0) {
        for (i = 0, e = audios.length; i < e; i++) {
          mediaEls.push(audios[i]);
        }
      }
      if (mediaEls && mediaEls.length > 0) {
        for (i = 0, e = mediaEls.length; i < e; i++) {
          mediaEl = mediaEls[i];
          if (mediaEl && mediaEl.getAttribute) {
            if (mediaEl['player'] === undefined) {
              options = mediaEl.getAttribute('data-setup');
              if (options !== null) {
                player = videojs(mediaEl);
              }
            }
          } else {
            vjs.autoSetupTimeout(1);
            break;
          }
        }
      } else if (!vjs.windowLoaded) {
        vjs.autoSetupTimeout(1);
      }
    };
    vjs.autoSetupTimeout = function(wait) {
      setTimeout(vjs.autoSetup, wait);
    };
    if (document.readyState === 'complete') {
      vjs.windowLoaded = true;
    } else {
      vjs.one(window, 'load', function() {
        vjs.windowLoaded = true;
      });
    }
    vjs.autoSetupTimeout(1);
    vjs.plugin = function(name, init) {
      vjs.Player.prototype[name] = init;
    };
    (function(root) {
      var vttjs = root.vttjs = {};
      var cueShim = vttjs.VTTCue;
      var regionShim = vttjs.VTTRegion;
      var oldVTTCue = root.VTTCue;
      var oldVTTRegion = root.VTTRegion;
      vttjs.shim = function() {
        vttjs.VTTCue = cueShim;
        vttjs.VTTRegion = regionShim;
      };
      vttjs.restore = function() {
        vttjs.VTTCue = oldVTTCue;
        vttjs.VTTRegion = oldVTTRegion;
      };
    }(this));
    (function(root, vttjs) {
      var autoKeyword = "auto";
      var directionSetting = {
        "": true,
        "lr": true,
        "rl": true
      };
      var alignSetting = {
        "start": true,
        "middle": true,
        "end": true,
        "left": true,
        "right": true
      };
      function findDirectionSetting(value) {
        if (typeof value !== "string") {
          return false;
        }
        var dir = directionSetting[value.toLowerCase()];
        return dir ? value.toLowerCase() : false;
      }
      function findAlignSetting(value) {
        if (typeof value !== "string") {
          return false;
        }
        var align = alignSetting[value.toLowerCase()];
        return align ? value.toLowerCase() : false;
      }
      function extend(obj) {
        var i = 1;
        for (; i < arguments.length; i++) {
          var cobj = arguments[i];
          for (var p in cobj) {
            obj[p] = cobj[p];
          }
        }
        return obj;
      }
      function VTTCue(startTime, endTime, text) {
        var cue = this;
        var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
        var baseObj = {};
        if (isIE8) {
          cue = document.createElement('custom');
        } else {
          baseObj.enumerable = true;
        }
        cue.hasBeenReset = false;
        var _id = "";
        var _pauseOnExit = false;
        var _startTime = startTime;
        var _endTime = endTime;
        var _text = text;
        var _region = null;
        var _vertical = "";
        var _snapToLines = true;
        var _line = "auto";
        var _lineAlign = "start";
        var _position = 50;
        var _positionAlign = "middle";
        var _size = 50;
        var _align = "middle";
        Object.defineProperty(cue, "id", extend({}, baseObj, {
          get: function() {
            return _id;
          },
          set: function(value) {
            _id = "" + value;
          }
        }));
        Object.defineProperty(cue, "pauseOnExit", extend({}, baseObj, {
          get: function() {
            return _pauseOnExit;
          },
          set: function(value) {
            _pauseOnExit = !!value;
          }
        }));
        Object.defineProperty(cue, "startTime", extend({}, baseObj, {
          get: function() {
            return _startTime;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("Start time must be set to a number.");
            }
            _startTime = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "endTime", extend({}, baseObj, {
          get: function() {
            return _endTime;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("End time must be set to a number.");
            }
            _endTime = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "text", extend({}, baseObj, {
          get: function() {
            return _text;
          },
          set: function(value) {
            _text = "" + value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "region", extend({}, baseObj, {
          get: function() {
            return _region;
          },
          set: function(value) {
            _region = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "vertical", extend({}, baseObj, {
          get: function() {
            return _vertical;
          },
          set: function(value) {
            var setting = findDirectionSetting(value);
            if (setting === false) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _vertical = setting;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "snapToLines", extend({}, baseObj, {
          get: function() {
            return _snapToLines;
          },
          set: function(value) {
            _snapToLines = !!value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "line", extend({}, baseObj, {
          get: function() {
            return _line;
          },
          set: function(value) {
            if (typeof value !== "number" && value !== autoKeyword) {
              throw new SyntaxError("An invalid number or illegal string was specified.");
            }
            _line = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "lineAlign", extend({}, baseObj, {
          get: function() {
            return _lineAlign;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _lineAlign = setting;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "position", extend({}, baseObj, {
          get: function() {
            return _position;
          },
          set: function(value) {
            if (value < 0 || value > 100) {
              throw new Error("Position must be between 0 and 100.");
            }
            _position = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "positionAlign", extend({}, baseObj, {
          get: function() {
            return _positionAlign;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _positionAlign = setting;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "size", extend({}, baseObj, {
          get: function() {
            return _size;
          },
          set: function(value) {
            if (value < 0 || value > 100) {
              throw new Error("Size must be between 0 and 100.");
            }
            _size = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "align", extend({}, baseObj, {
          get: function() {
            return _align;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _align = setting;
            this.hasBeenReset = true;
          }
        }));
        cue.displayState = undefined;
        if (isIE8) {
          return cue;
        }
      }
      VTTCue.prototype.getCueAsHTML = function() {
        return WebVTT.convertCueToDOMTree(window, this.text);
      };
      root.VTTCue = root.VTTCue || VTTCue;
      vttjs.VTTCue = VTTCue;
    }(this, (this.vttjs || {})));
    (function(root, vttjs) {
      var scrollSetting = {
        "": true,
        "up": true
      };
      function findScrollSetting(value) {
        if (typeof value !== "string") {
          return false;
        }
        var scroll = scrollSetting[value.toLowerCase()];
        return scroll ? value.toLowerCase() : false;
      }
      function isValidPercentValue(value) {
        return typeof value === "number" && (value >= 0 && value <= 100);
      }
      function VTTRegion() {
        var _width = 100;
        var _lines = 3;
        var _regionAnchorX = 0;
        var _regionAnchorY = 100;
        var _viewportAnchorX = 0;
        var _viewportAnchorY = 100;
        var _scroll = "";
        Object.defineProperties(this, {
          "width": {
            enumerable: true,
            get: function() {
              return _width;
            },
            set: function(value) {
              if (!isValidPercentValue(value)) {
                throw new Error("Width must be between 0 and 100.");
              }
              _width = value;
            }
          },
          "lines": {
            enumerable: true,
            get: function() {
              return _lines;
            },
            set: function(value) {
              if (typeof value !== "number") {
                throw new TypeError("Lines must be set to a number.");
              }
              _lines = value;
            }
          },
          "regionAnchorY": {
            enumerable: true,
            get: function() {
              return _regionAnchorY;
            },
            set: function(value) {
              if (!isValidPercentValue(value)) {
                throw new Error("RegionAnchorX must be between 0 and 100.");
              }
              _regionAnchorY = value;
            }
          },
          "regionAnchorX": {
            enumerable: true,
            get: function() {
              return _regionAnchorX;
            },
            set: function(value) {
              if (!isValidPercentValue(value)) {
                throw new Error("RegionAnchorY must be between 0 and 100.");
              }
              _regionAnchorX = value;
            }
          },
          "viewportAnchorY": {
            enumerable: true,
            get: function() {
              return _viewportAnchorY;
            },
            set: function(value) {
              if (!isValidPercentValue(value)) {
                throw new Error("ViewportAnchorY must be between 0 and 100.");
              }
              _viewportAnchorY = value;
            }
          },
          "viewportAnchorX": {
            enumerable: true,
            get: function() {
              return _viewportAnchorX;
            },
            set: function(value) {
              if (!isValidPercentValue(value)) {
                throw new Error("ViewportAnchorX must be between 0 and 100.");
              }
              _viewportAnchorX = value;
            }
          },
          "scroll": {
            enumerable: true,
            get: function() {
              return _scroll;
            },
            set: function(value) {
              var setting = findScrollSetting(value);
              if (setting === false) {
                throw new SyntaxError("An invalid or illegal string was specified.");
              }
              _scroll = setting;
            }
          }
        });
      }
      root.VTTRegion = root.VTTRegion || VTTRegion;
      vttjs.VTTRegion = VTTRegion;
    }(this, (this.vttjs || {})));
    (function(global) {
      var _objCreate = Object.create || (function() {
        function F() {}
        return function(o) {
          if (arguments.length !== 1) {
            throw new Error('Object.create shim only accepts one parameter.');
          }
          F.prototype = o;
          return new F();
        };
      })();
      function ParsingError(errorData, message) {
        this.name = "ParsingError";
        this.code = errorData.code;
        this.message = message || errorData.message;
      }
      ParsingError.prototype = _objCreate(Error.prototype);
      ParsingError.prototype.constructor = ParsingError;
      ParsingError.Errors = {
        BadSignature: {
          code: 0,
          message: "Malformed WebVTT signature."
        },
        BadTimeStamp: {
          code: 1,
          message: "Malformed time stamp."
        }
      };
      function parseTimeStamp(input) {
        function computeSeconds(h, m, s, f) {
          return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
        }
        var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
        if (!m) {
          return null;
        }
        if (m[3]) {
          return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
        } else if (m[1] > 59) {
          return computeSeconds(m[1], m[2], 0, m[4]);
        } else {
          return computeSeconds(0, m[1], m[2], m[4]);
        }
      }
      function Settings() {
        this.values = _objCreate(null);
      }
      Settings.prototype = {
        set: function(k, v) {
          if (!this.get(k) && v !== "") {
            this.values[k] = v;
          }
        },
        get: function(k, dflt, defaultKey) {
          if (defaultKey) {
            return this.has(k) ? this.values[k] : dflt[defaultKey];
          }
          return this.has(k) ? this.values[k] : dflt;
        },
        has: function(k) {
          return k in this.values;
        },
        alt: function(k, v, a) {
          for (var n = 0; n < a.length; ++n) {
            if (v === a[n]) {
              this.set(k, v);
              break;
            }
          }
        },
        integer: function(k, v) {
          if (/^-?\d+$/.test(v)) {
            this.set(k, parseInt(v, 10));
          }
        },
        percent: function(k, v) {
          var m;
          if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
            v = parseFloat(v);
            if (v >= 0 && v <= 100) {
              this.set(k, v);
              return true;
            }
          }
          return false;
        }
      };
      function parseOptions(input, callback, keyValueDelim, groupDelim) {
        var groups = groupDelim ? input.split(groupDelim) : [input];
        for (var i in groups) {
          if (typeof groups[i] !== "string") {
            continue;
          }
          var kv = groups[i].split(keyValueDelim);
          if (kv.length !== 2) {
            continue;
          }
          var k = kv[0];
          var v = kv[1];
          callback(k, v);
        }
      }
      function parseCue(input, cue, regionList) {
        var oInput = input;
        function consumeTimeStamp() {
          var ts = parseTimeStamp(input);
          if (ts === null) {
            throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed timestamp: " + oInput);
          }
          input = input.replace(/^[^\sa-zA-Z-]+/, "");
          return ts;
        }
        function consumeCueSettings(input, cue) {
          var settings = new Settings();
          parseOptions(input, function(k, v) {
            switch (k) {
              case "region":
                for (var i = regionList.length - 1; i >= 0; i--) {
                  if (regionList[i].id === v) {
                    settings.set(k, regionList[i].region);
                    break;
                  }
                }
                break;
              case "vertical":
                settings.alt(k, v, ["rl", "lr"]);
                break;
              case "line":
                var vals = v.split(","),
                    vals0 = vals[0];
                settings.integer(k, vals0);
                settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
                settings.alt(k, vals0, ["auto"]);
                if (vals.length === 2) {
                  settings.alt("lineAlign", vals[1], ["start", "middle", "end"]);
                }
                break;
              case "position":
                vals = v.split(",");
                settings.percent(k, vals[0]);
                if (vals.length === 2) {
                  settings.alt("positionAlign", vals[1], ["start", "middle", "end"]);
                }
                break;
              case "size":
                settings.percent(k, v);
                break;
              case "align":
                settings.alt(k, v, ["start", "middle", "end", "left", "right"]);
                break;
            }
          }, /:/, /\s/);
          cue.region = settings.get("region", null);
          cue.vertical = settings.get("vertical", "");
          cue.line = settings.get("line", "auto");
          cue.lineAlign = settings.get("lineAlign", "start");
          cue.snapToLines = settings.get("snapToLines", true);
          cue.size = settings.get("size", 100);
          cue.align = settings.get("align", "middle");
          cue.position = settings.get("position", {
            start: 0,
            left: 0,
            middle: 50,
            end: 100,
            right: 100
          }, cue.align);
          cue.positionAlign = settings.get("positionAlign", {
            start: "start",
            left: "start",
            middle: "middle",
            end: "end",
            right: "end"
          }, cue.align);
        }
        function skipWhitespace() {
          input = input.replace(/^\s+/, "");
        }
        skipWhitespace();
        cue.startTime = consumeTimeStamp();
        skipWhitespace();
        if (input.substr(0, 3) !== "-->") {
          throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
        }
        input = input.substr(3);
        skipWhitespace();
        cue.endTime = consumeTimeStamp();
        skipWhitespace();
        consumeCueSettings(input, cue);
      }
      var ESCAPE = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&lrm;": "\u200e",
        "&rlm;": "\u200f",
        "&nbsp;": "\u00a0"
      };
      var TAG_NAME = {
        c: "span",
        i: "i",
        b: "b",
        u: "u",
        ruby: "ruby",
        rt: "rt",
        v: "span",
        lang: "span"
      };
      var TAG_ANNOTATION = {
        v: "title",
        lang: "lang"
      };
      var NEEDS_PARENT = {rt: "ruby"};
      function parseContent(window, input) {
        function nextToken() {
          if (!input) {
            return null;
          }
          function consume(result) {
            input = input.substr(result.length);
            return result;
          }
          var m = input.match(/^([^<]*)(<[^>]+>?)?/);
          return consume(m[1] ? m[1] : m[2]);
        }
        function unescape1(e) {
          return ESCAPE[e];
        }
        function unescape(s) {
          while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {
            s = s.replace(m[0], unescape1);
          }
          return s;
        }
        function shouldAdd(current, element) {
          return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current.localName;
        }
        function createElement(type, annotation) {
          var tagName = TAG_NAME[type];
          if (!tagName) {
            return null;
          }
          var element = window.document.createElement(tagName);
          element.localName = tagName;
          var name = TAG_ANNOTATION[type];
          if (name && annotation) {
            element[name] = annotation.trim();
          }
          return element;
        }
        var rootDiv = window.document.createElement("div"),
            current = rootDiv,
            t,
            tagStack = [];
        while ((t = nextToken()) !== null) {
          if (t[0] === '<') {
            if (t[1] === "/") {
              if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
                tagStack.pop();
                current = current.parentNode;
              }
              continue;
            }
            var ts = parseTimeStamp(t.substr(1, t.length - 2));
            var node;
            if (ts) {
              node = window.document.createProcessingInstruction("timestamp", ts);
              current.appendChild(node);
              continue;
            }
            var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
            if (!m) {
              continue;
            }
            node = createElement(m[1], m[3]);
            if (!node) {
              continue;
            }
            if (!shouldAdd(current, node)) {
              continue;
            }
            if (m[2]) {
              node.className = m[2].substr(1).replace('.', ' ');
            }
            tagStack.push(m[1]);
            current.appendChild(node);
            current = node;
            continue;
          }
          current.appendChild(window.document.createTextNode(unescape(t)));
        }
        return rootDiv;
      }
      var strongRTLChars = [0x05BE, 0x05C0, 0x05C3, 0x05C6, 0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF, 0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7, 0x05E8, 0x05E9, 0x05EA, 0x05F0, 0x05F1, 0x05F2, 0x05F3, 0x05F4, 0x0608, 0x060B, 0x060D, 0x061B, 0x061E, 0x061F, 0x0620, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627, 0x0628, 0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F, 0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637, 0x0638, 0x0639, 0x063A, 0x063B, 0x063C, 0x063D, 0x063E, 0x063F, 0x0640, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649, 0x064A, 0x066D, 0x066E, 0x066F, 0x0671, 0x0672, 0x0673, 0x0674, 0x0675, 0x0676, 0x0677, 0x0678, 0x0679, 0x067A, 0x067B, 0x067C, 0x067D, 0x067E, 0x067F, 0x0680, 0x0681, 0x0682, 0x0683, 0x0684, 0x0685, 0x0686, 0x0687, 0x0688, 0x0689, 0x068A, 0x068B, 0x068C, 0x068D, 0x068E, 0x068F, 0x0690, 0x0691, 0x0692, 0x0693, 0x0694, 0x0695, 0x0696, 0x0697, 0x0698, 0x0699, 0x069A, 0x069B, 0x069C, 0x069D, 0x069E, 0x069F, 0x06A0, 0x06A1, 0x06A2, 0x06A3, 0x06A4, 0x06A5, 0x06A6, 0x06A7, 0x06A8, 0x06A9, 0x06AA, 0x06AB, 0x06AC, 0x06AD, 0x06AE, 0x06AF, 0x06B0, 0x06B1, 0x06B2, 0x06B3, 0x06B4, 0x06B5, 0x06B6, 0x06B7, 0x06B8, 0x06B9, 0x06BA, 0x06BB, 0x06BC, 0x06BD, 0x06BE, 0x06BF, 0x06C0, 0x06C1, 0x06C2, 0x06C3, 0x06C4, 0x06C5, 0x06C6, 0x06C7, 0x06C8, 0x06C9, 0x06CA, 0x06CB, 0x06CC, 0x06CD, 0x06CE, 0x06CF, 0x06D0, 0x06D1, 0x06D2, 0x06D3, 0x06D4, 0x06D5, 0x06E5, 0x06E6, 0x06EE, 0x06EF, 0x06FA, 0x06FB, 0x06FC, 0x06FD, 0x06FE, 0x06FF, 0x0700, 0x0701, 0x0702, 0x0703, 0x0704, 0x0705, 0x0706, 0x0707, 0x0708, 0x0709, 0x070A, 0x070B, 0x070C, 0x070D, 0x070F, 0x0710, 0x0712, 0x0713, 0x0714, 0x0715, 0x0716, 0x0717, 0x0718, 0x0719, 0x071A, 0x071B, 0x071C, 0x071D, 0x071E, 0x071F, 0x0720, 0x0721, 0x0722, 0x0723, 0x0724, 0x0725, 0x0726, 0x0727, 0x0728, 0x0729, 0x072A, 0x072B, 0x072C, 0x072D, 0x072E, 0x072F, 0x074D, 0x074E, 0x074F, 0x0750, 0x0751, 0x0752, 0x0753, 0x0754, 0x0755, 0x0756, 0x0757, 0x0758, 0x0759, 0x075A, 0x075B, 0x075C, 0x075D, 0x075E, 0x075F, 0x0760, 0x0761, 0x0762, 0x0763, 0x0764, 0x0765, 0x0766, 0x0767, 0x0768, 0x0769, 0x076A, 0x076B, 0x076C, 0x076D, 0x076E, 0x076F, 0x0770, 0x0771, 0x0772, 0x0773, 0x0774, 0x0775, 0x0776, 0x0777, 0x0778, 0x0779, 0x077A, 0x077B, 0x077C, 0x077D, 0x077E, 0x077F, 0x0780, 0x0781, 0x0782, 0x0783, 0x0784, 0x0785, 0x0786, 0x0787, 0x0788, 0x0789, 0x078A, 0x078B, 0x078C, 0x078D, 0x078E, 0x078F, 0x0790, 0x0791, 0x0792, 0x0793, 0x0794, 0x0795, 0x0796, 0x0797, 0x0798, 0x0799, 0x079A, 0x079B, 0x079C, 0x079D, 0x079E, 0x079F, 0x07A0, 0x07A1, 0x07A2, 0x07A3, 0x07A4, 0x07A5, 0x07B1, 0x07C0, 0x07C1, 0x07C2, 0x07C3, 0x07C4, 0x07C5, 0x07C6, 0x07C7, 0x07C8, 0x07C9, 0x07CA, 0x07CB, 0x07CC, 0x07CD, 0x07CE, 0x07CF, 0x07D0, 0x07D1, 0x07D2, 0x07D3, 0x07D4, 0x07D5, 0x07D6, 0x07D7, 0x07D8, 0x07D9, 0x07DA, 0x07DB, 0x07DC, 0x07DD, 0x07DE, 0x07DF, 0x07E0, 0x07E1, 0x07E2, 0x07E3, 0x07E4, 0x07E5, 0x07E6, 0x07E7, 0x07E8, 0x07E9, 0x07EA, 0x07F4, 0x07F5, 0x07FA, 0x0800, 0x0801, 0x0802, 0x0803, 0x0804, 0x0805, 0x0806, 0x0807, 0x0808, 0x0809, 0x080A, 0x080B, 0x080C, 0x080D, 0x080E, 0x080F, 0x0810, 0x0811, 0x0812, 0x0813, 0x0814, 0x0815, 0x081A, 0x0824, 0x0828, 0x0830, 0x0831, 0x0832, 0x0833, 0x0834, 0x0835, 0x0836, 0x0837, 0x0838, 0x0839, 0x083A, 0x083B, 0x083C, 0x083D, 0x083E, 0x0840, 0x0841, 0x0842, 0x0843, 0x0844, 0x0845, 0x0846, 0x0847, 0x0848, 0x0849, 0x084A, 0x084B, 0x084C, 0x084D, 0x084E, 0x084F, 0x0850, 0x0851, 0x0852, 0x0853, 0x0854, 0x0855, 0x0856, 0x0857, 0x0858, 0x085E, 0x08A0, 0x08A2, 0x08A3, 0x08A4, 0x08A5, 0x08A6, 0x08A7, 0x08A8, 0x08A9, 0x08AA, 0x08AB, 0x08AC, 0x200F, 0xFB1D, 0xFB1F, 0xFB20, 0xFB21, 0xFB22, 0xFB23, 0xFB24, 0xFB25, 0xFB26, 0xFB27, 0xFB28, 0xFB2A, 0xFB2B, 0xFB2C, 0xFB2D, 0xFB2E, 0xFB2F, 0xFB30, 0xFB31, 0xFB32, 0xFB33, 0xFB34, 0xFB35, 0xFB36, 0xFB38, 0xFB39, 0xFB3A, 0xFB3B, 0xFB3C, 0xFB3E, 0xFB40, 0xFB41, 0xFB43, 0xFB44, 0xFB46, 0xFB47, 0xFB48, 0xFB49, 0xFB4A, 0xFB4B, 0xFB4C, 0xFB4D, 0xFB4E, 0xFB4F, 0xFB50, 0xFB51, 0xFB52, 0xFB53, 0xFB54, 0xFB55, 0xFB56, 0xFB57, 0xFB58, 0xFB59, 0xFB5A, 0xFB5B, 0xFB5C, 0xFB5D, 0xFB5E, 0xFB5F, 0xFB60, 0xFB61, 0xFB62, 0xFB63, 0xFB64, 0xFB65, 0xFB66, 0xFB67, 0xFB68, 0xFB69, 0xFB6A, 0xFB6B, 0xFB6C, 0xFB6D, 0xFB6E, 0xFB6F, 0xFB70, 0xFB71, 0xFB72, 0xFB73, 0xFB74, 0xFB75, 0xFB76, 0xFB77, 0xFB78, 0xFB79, 0xFB7A, 0xFB7B, 0xFB7C, 0xFB7D, 0xFB7E, 0xFB7F, 0xFB80, 0xFB81, 0xFB82, 0xFB83, 0xFB84, 0xFB85, 0xFB86, 0xFB87, 0xFB88, 0xFB89, 0xFB8A, 0xFB8B, 0xFB8C, 0xFB8D, 0xFB8E, 0xFB8F, 0xFB90, 0xFB91, 0xFB92, 0xFB93, 0xFB94, 0xFB95, 0xFB96, 0xFB97, 0xFB98, 0xFB99, 0xFB9A, 0xFB9B, 0xFB9C, 0xFB9D, 0xFB9E, 0xFB9F, 0xFBA0, 0xFBA1, 0xFBA2, 0xFBA3, 0xFBA4, 0xFBA5, 0xFBA6, 0xFBA7, 0xFBA8, 0xFBA9, 0xFBAA, 0xFBAB, 0xFBAC, 0xFBAD, 0xFBAE, 0xFBAF, 0xFBB0, 0xFBB1, 0xFBB2, 0xFBB3, 0xFBB4, 0xFBB5, 0xFBB6, 0xFBB7, 0xFBB8, 0xFBB9, 0xFBBA, 0xFBBB, 0xFBBC, 0xFBBD, 0xFBBE, 0xFBBF, 0xFBC0, 0xFBC1, 0xFBD3, 0xFBD4, 0xFBD5, 0xFBD6, 0xFBD7, 0xFBD8, 0xFBD9, 0xFBDA, 0xFBDB, 0xFBDC, 0xFBDD, 0xFBDE, 0xFBDF, 0xFBE0, 0xFBE1, 0xFBE2, 0xFBE3, 0xFBE4, 0xFBE5, 0xFBE6, 0xFBE7, 0xFBE8, 0xFBE9, 0xFBEA, 0xFBEB, 0xFBEC, 0xFBED, 0xFBEE, 0xFBEF, 0xFBF0, 0xFBF1, 0xFBF2, 0xFBF3, 0xFBF4, 0xFBF5, 0xFBF6, 0xFBF7, 0xFBF8, 0xFBF9, 0xFBFA, 0xFBFB, 0xFBFC, 0xFBFD, 0xFBFE, 0xFBFF, 0xFC00, 0xFC01, 0xFC02, 0xFC03, 0xFC04, 0xFC05, 0xFC06, 0xFC07, 0xFC08, 0xFC09, 0xFC0A, 0xFC0B, 0xFC0C, 0xFC0D, 0xFC0E, 0xFC0F, 0xFC10, 0xFC11, 0xFC12, 0xFC13, 0xFC14, 0xFC15, 0xFC16, 0xFC17, 0xFC18, 0xFC19, 0xFC1A, 0xFC1B, 0xFC1C, 0xFC1D, 0xFC1E, 0xFC1F, 0xFC20, 0xFC21, 0xFC22, 0xFC23, 0xFC24, 0xFC25, 0xFC26, 0xFC27, 0xFC28, 0xFC29, 0xFC2A, 0xFC2B, 0xFC2C, 0xFC2D, 0xFC2E, 0xFC2F, 0xFC30, 0xFC31, 0xFC32, 0xFC33, 0xFC34, 0xFC35, 0xFC36, 0xFC37, 0xFC38, 0xFC39, 0xFC3A, 0xFC3B, 0xFC3C, 0xFC3D, 0xFC3E, 0xFC3F, 0xFC40, 0xFC41, 0xFC42, 0xFC43, 0xFC44, 0xFC45, 0xFC46, 0xFC47, 0xFC48, 0xFC49, 0xFC4A, 0xFC4B, 0xFC4C, 0xFC4D, 0xFC4E, 0xFC4F, 0xFC50, 0xFC51, 0xFC52, 0xFC53, 0xFC54, 0xFC55, 0xFC56, 0xFC57, 0xFC58, 0xFC59, 0xFC5A, 0xFC5B, 0xFC5C, 0xFC5D, 0xFC5E, 0xFC5F, 0xFC60, 0xFC61, 0xFC62, 0xFC63, 0xFC64, 0xFC65, 0xFC66, 0xFC67, 0xFC68, 0xFC69, 0xFC6A, 0xFC6B, 0xFC6C, 0xFC6D, 0xFC6E, 0xFC6F, 0xFC70, 0xFC71, 0xFC72, 0xFC73, 0xFC74, 0xFC75, 0xFC76, 0xFC77, 0xFC78, 0xFC79, 0xFC7A, 0xFC7B, 0xFC7C, 0xFC7D, 0xFC7E, 0xFC7F, 0xFC80, 0xFC81, 0xFC82, 0xFC83, 0xFC84, 0xFC85, 0xFC86, 0xFC87, 0xFC88, 0xFC89, 0xFC8A, 0xFC8B, 0xFC8C, 0xFC8D, 0xFC8E, 0xFC8F, 0xFC90, 0xFC91, 0xFC92, 0xFC93, 0xFC94, 0xFC95, 0xFC96, 0xFC97, 0xFC98, 0xFC99, 0xFC9A, 0xFC9B, 0xFC9C, 0xFC9D, 0xFC9E, 0xFC9F, 0xFCA0, 0xFCA1, 0xFCA2, 0xFCA3, 0xFCA4, 0xFCA5, 0xFCA6, 0xFCA7, 0xFCA8, 0xFCA9, 0xFCAA, 0xFCAB, 0xFCAC, 0xFCAD, 0xFCAE, 0xFCAF, 0xFCB0, 0xFCB1, 0xFCB2, 0xFCB3, 0xFCB4, 0xFCB5, 0xFCB6, 0xFCB7, 0xFCB8, 0xFCB9, 0xFCBA, 0xFCBB, 0xFCBC, 0xFCBD, 0xFCBE, 0xFCBF, 0xFCC0, 0xFCC1, 0xFCC2, 0xFCC3, 0xFCC4, 0xFCC5, 0xFCC6, 0xFCC7, 0xFCC8, 0xFCC9, 0xFCCA, 0xFCCB, 0xFCCC, 0xFCCD, 0xFCCE, 0xFCCF, 0xFCD0, 0xFCD1, 0xFCD2, 0xFCD3, 0xFCD4, 0xFCD5, 0xFCD6, 0xFCD7, 0xFCD8, 0xFCD9, 0xFCDA, 0xFCDB, 0xFCDC, 0xFCDD, 0xFCDE, 0xFCDF, 0xFCE0, 0xFCE1, 0xFCE2, 0xFCE3, 0xFCE4, 0xFCE5, 0xFCE6, 0xFCE7, 0xFCE8, 0xFCE9, 0xFCEA, 0xFCEB, 0xFCEC, 0xFCED, 0xFCEE, 0xFCEF, 0xFCF0, 0xFCF1, 0xFCF2, 0xFCF3, 0xFCF4, 0xFCF5, 0xFCF6, 0xFCF7, 0xFCF8, 0xFCF9, 0xFCFA, 0xFCFB, 0xFCFC, 0xFCFD, 0xFCFE, 0xFCFF, 0xFD00, 0xFD01, 0xFD02, 0xFD03, 0xFD04, 0xFD05, 0xFD06, 0xFD07, 0xFD08, 0xFD09, 0xFD0A, 0xFD0B, 0xFD0C, 0xFD0D, 0xFD0E, 0xFD0F, 0xFD10, 0xFD11, 0xFD12, 0xFD13, 0xFD14, 0xFD15, 0xFD16, 0xFD17, 0xFD18, 0xFD19, 0xFD1A, 0xFD1B, 0xFD1C, 0xFD1D, 0xFD1E, 0xFD1F, 0xFD20, 0xFD21, 0xFD22, 0xFD23, 0xFD24, 0xFD25, 0xFD26, 0xFD27, 0xFD28, 0xFD29, 0xFD2A, 0xFD2B, 0xFD2C, 0xFD2D, 0xFD2E, 0xFD2F, 0xFD30, 0xFD31, 0xFD32, 0xFD33, 0xFD34, 0xFD35, 0xFD36, 0xFD37, 0xFD38, 0xFD39, 0xFD3A, 0xFD3B, 0xFD3C, 0xFD3D, 0xFD50, 0xFD51, 0xFD52, 0xFD53, 0xFD54, 0xFD55, 0xFD56, 0xFD57, 0xFD58, 0xFD59, 0xFD5A, 0xFD5B, 0xFD5C, 0xFD5D, 0xFD5E, 0xFD5F, 0xFD60, 0xFD61, 0xFD62, 0xFD63, 0xFD64, 0xFD65, 0xFD66, 0xFD67, 0xFD68, 0xFD69, 0xFD6A, 0xFD6B, 0xFD6C, 0xFD6D, 0xFD6E, 0xFD6F, 0xFD70, 0xFD71, 0xFD72, 0xFD73, 0xFD74, 0xFD75, 0xFD76, 0xFD77, 0xFD78, 0xFD79, 0xFD7A, 0xFD7B, 0xFD7C, 0xFD7D, 0xFD7E, 0xFD7F, 0xFD80, 0xFD81, 0xFD82, 0xFD83, 0xFD84, 0xFD85, 0xFD86, 0xFD87, 0xFD88, 0xFD89, 0xFD8A, 0xFD8B, 0xFD8C, 0xFD8D, 0xFD8E, 0xFD8F, 0xFD92, 0xFD93, 0xFD94, 0xFD95, 0xFD96, 0xFD97, 0xFD98, 0xFD99, 0xFD9A, 0xFD9B, 0xFD9C, 0xFD9D, 0xFD9E, 0xFD9F, 0xFDA0, 0xFDA1, 0xFDA2, 0xFDA3, 0xFDA4, 0xFDA5, 0xFDA6, 0xFDA7, 0xFDA8, 0xFDA9, 0xFDAA, 0xFDAB, 0xFDAC, 0xFDAD, 0xFDAE, 0xFDAF, 0xFDB0, 0xFDB1, 0xFDB2, 0xFDB3, 0xFDB4, 0xFDB5, 0xFDB6, 0xFDB7, 0xFDB8, 0xFDB9, 0xFDBA, 0xFDBB, 0xFDBC, 0xFDBD, 0xFDBE, 0xFDBF, 0xFDC0, 0xFDC1, 0xFDC2, 0xFDC3, 0xFDC4, 0xFDC5, 0xFDC6, 0xFDC7, 0xFDF0, 0xFDF1, 0xFDF2, 0xFDF3, 0xFDF4, 0xFDF5, 0xFDF6, 0xFDF7, 0xFDF8, 0xFDF9, 0xFDFA, 0xFDFB, 0xFDFC, 0xFE70, 0xFE71, 0xFE72, 0xFE73, 0xFE74, 0xFE76, 0xFE77, 0xFE78, 0xFE79, 0xFE7A, 0xFE7B, 0xFE7C, 0xFE7D, 0xFE7E, 0xFE7F, 0xFE80, 0xFE81, 0xFE82, 0xFE83, 0xFE84, 0xFE85, 0xFE86, 0xFE87, 0xFE88, 0xFE89, 0xFE8A, 0xFE8B, 0xFE8C, 0xFE8D, 0xFE8E, 0xFE8F, 0xFE90, 0xFE91, 0xFE92, 0xFE93, 0xFE94, 0xFE95, 0xFE96, 0xFE97, 0xFE98, 0xFE99, 0xFE9A, 0xFE9B, 0xFE9C, 0xFE9D, 0xFE9E, 0xFE9F, 0xFEA0, 0xFEA1, 0xFEA2, 0xFEA3, 0xFEA4, 0xFEA5, 0xFEA6, 0xFEA7, 0xFEA8, 0xFEA9, 0xFEAA, 0xFEAB, 0xFEAC, 0xFEAD, 0xFEAE, 0xFEAF, 0xFEB0, 0xFEB1, 0xFEB2, 0xFEB3, 0xFEB4, 0xFEB5, 0xFEB6, 0xFEB7, 0xFEB8, 0xFEB9, 0xFEBA, 0xFEBB, 0xFEBC, 0xFEBD, 0xFEBE, 0xFEBF, 0xFEC0, 0xFEC1, 0xFEC2, 0xFEC3, 0xFEC4, 0xFEC5, 0xFEC6, 0xFEC7, 0xFEC8, 0xFEC9, 0xFECA, 0xFECB, 0xFECC, 0xFECD, 0xFECE, 0xFECF, 0xFED0, 0xFED1, 0xFED2, 0xFED3, 0xFED4, 0xFED5, 0xFED6, 0xFED7, 0xFED8, 0xFED9, 0xFEDA, 0xFEDB, 0xFEDC, 0xFEDD, 0xFEDE, 0xFEDF, 0xFEE0, 0xFEE1, 0xFEE2, 0xFEE3, 0xFEE4, 0xFEE5, 0xFEE6, 0xFEE7, 0xFEE8, 0xFEE9, 0xFEEA, 0xFEEB, 0xFEEC, 0xFEED, 0xFEEE, 0xFEEF, 0xFEF0, 0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4, 0xFEF5, 0xFEF6, 0xFEF7, 0xFEF8, 0xFEF9, 0xFEFA, 0xFEFB, 0xFEFC, 0x10800, 0x10801, 0x10802, 0x10803, 0x10804, 0x10805, 0x10808, 0x1080A, 0x1080B, 0x1080C, 0x1080D, 0x1080E, 0x1080F, 0x10810, 0x10811, 0x10812, 0x10813, 0x10814, 0x10815, 0x10816, 0x10817, 0x10818, 0x10819, 0x1081A, 0x1081B, 0x1081C, 0x1081D, 0x1081E, 0x1081F, 0x10820, 0x10821, 0x10822, 0x10823, 0x10824, 0x10825, 0x10826, 0x10827, 0x10828, 0x10829, 0x1082A, 0x1082B, 0x1082C, 0x1082D, 0x1082E, 0x1082F, 0x10830, 0x10831, 0x10832, 0x10833, 0x10834, 0x10835, 0x10837, 0x10838, 0x1083C, 0x1083F, 0x10840, 0x10841, 0x10842, 0x10843, 0x10844, 0x10845, 0x10846, 0x10847, 0x10848, 0x10849, 0x1084A, 0x1084B, 0x1084C, 0x1084D, 0x1084E, 0x1084F, 0x10850, 0x10851, 0x10852, 0x10853, 0x10854, 0x10855, 0x10857, 0x10858, 0x10859, 0x1085A, 0x1085B, 0x1085C, 0x1085D, 0x1085E, 0x1085F, 0x10900, 0x10901, 0x10902, 0x10903, 0x10904, 0x10905, 0x10906, 0x10907, 0x10908, 0x10909, 0x1090A, 0x1090B, 0x1090C, 0x1090D, 0x1090E, 0x1090F, 0x10910, 0x10911, 0x10912, 0x10913, 0x10914, 0x10915, 0x10916, 0x10917, 0x10918, 0x10919, 0x1091A, 0x1091B, 0x10920, 0x10921, 0x10922, 0x10923, 0x10924, 0x10925, 0x10926, 0x10927, 0x10928, 0x10929, 0x1092A, 0x1092B, 0x1092C, 0x1092D, 0x1092E, 0x1092F, 0x10930, 0x10931, 0x10932, 0x10933, 0x10934, 0x10935, 0x10936, 0x10937, 0x10938, 0x10939, 0x1093F, 0x10980, 0x10981, 0x10982, 0x10983, 0x10984, 0x10985, 0x10986, 0x10987, 0x10988, 0x10989, 0x1098A, 0x1098B, 0x1098C, 0x1098D, 0x1098E, 0x1098F, 0x10990, 0x10991, 0x10992, 0x10993, 0x10994, 0x10995, 0x10996, 0x10997, 0x10998, 0x10999, 0x1099A, 0x1099B, 0x1099C, 0x1099D, 0x1099E, 0x1099F, 0x109A0, 0x109A1, 0x109A2, 0x109A3, 0x109A4, 0x109A5, 0x109A6, 0x109A7, 0x109A8, 0x109A9, 0x109AA, 0x109AB, 0x109AC, 0x109AD, 0x109AE, 0x109AF, 0x109B0, 0x109B1, 0x109B2, 0x109B3, 0x109B4, 0x109B5, 0x109B6, 0x109B7, 0x109BE, 0x109BF, 0x10A00, 0x10A10, 0x10A11, 0x10A12, 0x10A13, 0x10A15, 0x10A16, 0x10A17, 0x10A19, 0x10A1A, 0x10A1B, 0x10A1C, 0x10A1D, 0x10A1E, 0x10A1F, 0x10A20, 0x10A21, 0x10A22, 0x10A23, 0x10A24, 0x10A25, 0x10A26, 0x10A27, 0x10A28, 0x10A29, 0x10A2A, 0x10A2B, 0x10A2C, 0x10A2D, 0x10A2E, 0x10A2F, 0x10A30, 0x10A31, 0x10A32, 0x10A33, 0x10A40, 0x10A41, 0x10A42, 0x10A43, 0x10A44, 0x10A45, 0x10A46, 0x10A47, 0x10A50, 0x10A51, 0x10A52, 0x10A53, 0x10A54, 0x10A55, 0x10A56, 0x10A57, 0x10A58, 0x10A60, 0x10A61, 0x10A62, 0x10A63, 0x10A64, 0x10A65, 0x10A66, 0x10A67, 0x10A68, 0x10A69, 0x10A6A, 0x10A6B, 0x10A6C, 0x10A6D, 0x10A6E, 0x10A6F, 0x10A70, 0x10A71, 0x10A72, 0x10A73, 0x10A74, 0x10A75, 0x10A76, 0x10A77, 0x10A78, 0x10A79, 0x10A7A, 0x10A7B, 0x10A7C, 0x10A7D, 0x10A7E, 0x10A7F, 0x10B00, 0x10B01, 0x10B02, 0x10B03, 0x10B04, 0x10B05, 0x10B06, 0x10B07, 0x10B08, 0x10B09, 0x10B0A, 0x10B0B, 0x10B0C, 0x10B0D, 0x10B0E, 0x10B0F, 0x10B10, 0x10B11, 0x10B12, 0x10B13, 0x10B14, 0x10B15, 0x10B16, 0x10B17, 0x10B18, 0x10B19, 0x10B1A, 0x10B1B, 0x10B1C, 0x10B1D, 0x10B1E, 0x10B1F, 0x10B20, 0x10B21, 0x10B22, 0x10B23, 0x10B24, 0x10B25, 0x10B26, 0x10B27, 0x10B28, 0x10B29, 0x10B2A, 0x10B2B, 0x10B2C, 0x10B2D, 0x10B2E, 0x10B2F, 0x10B30, 0x10B31, 0x10B32, 0x10B33, 0x10B34, 0x10B35, 0x10B40, 0x10B41, 0x10B42, 0x10B43, 0x10B44, 0x10B45, 0x10B46, 0x10B47, 0x10B48, 0x10B49, 0x10B4A, 0x10B4B, 0x10B4C, 0x10B4D, 0x10B4E, 0x10B4F, 0x10B50, 0x10B51, 0x10B52, 0x10B53, 0x10B54, 0x10B55, 0x10B58, 0x10B59, 0x10B5A, 0x10B5B, 0x10B5C, 0x10B5D, 0x10B5E, 0x10B5F, 0x10B60, 0x10B61, 0x10B62, 0x10B63, 0x10B64, 0x10B65, 0x10B66, 0x10B67, 0x10B68, 0x10B69, 0x10B6A, 0x10B6B, 0x10B6C, 0x10B6D, 0x10B6E, 0x10B6F, 0x10B70, 0x10B71, 0x10B72, 0x10B78, 0x10B79, 0x10B7A, 0x10B7B, 0x10B7C, 0x10B7D, 0x10B7E, 0x10B7F, 0x10C00, 0x10C01, 0x10C02, 0x10C03, 0x10C04, 0x10C05, 0x10C06, 0x10C07, 0x10C08, 0x10C09, 0x10C0A, 0x10C0B, 0x10C0C, 0x10C0D, 0x10C0E, 0x10C0F, 0x10C10, 0x10C11, 0x10C12, 0x10C13, 0x10C14, 0x10C15, 0x10C16, 0x10C17, 0x10C18, 0x10C19, 0x10C1A, 0x10C1B, 0x10C1C, 0x10C1D, 0x10C1E, 0x10C1F, 0x10C20, 0x10C21, 0x10C22, 0x10C23, 0x10C24, 0x10C25, 0x10C26, 0x10C27, 0x10C28, 0x10C29, 0x10C2A, 0x10C2B, 0x10C2C, 0x10C2D, 0x10C2E, 0x10C2F, 0x10C30, 0x10C31, 0x10C32, 0x10C33, 0x10C34, 0x10C35, 0x10C36, 0x10C37, 0x10C38, 0x10C39, 0x10C3A, 0x10C3B, 0x10C3C, 0x10C3D, 0x10C3E, 0x10C3F, 0x10C40, 0x10C41, 0x10C42, 0x10C43, 0x10C44, 0x10C45, 0x10C46, 0x10C47, 0x10C48, 0x1EE00, 0x1EE01, 0x1EE02, 0x1EE03, 0x1EE05, 0x1EE06, 0x1EE07, 0x1EE08, 0x1EE09, 0x1EE0A, 0x1EE0B, 0x1EE0C, 0x1EE0D, 0x1EE0E, 0x1EE0F, 0x1EE10, 0x1EE11, 0x1EE12, 0x1EE13, 0x1EE14, 0x1EE15, 0x1EE16, 0x1EE17, 0x1EE18, 0x1EE19, 0x1EE1A, 0x1EE1B, 0x1EE1C, 0x1EE1D, 0x1EE1E, 0x1EE1F, 0x1EE21, 0x1EE22, 0x1EE24, 0x1EE27, 0x1EE29, 0x1EE2A, 0x1EE2B, 0x1EE2C, 0x1EE2D, 0x1EE2E, 0x1EE2F, 0x1EE30, 0x1EE31, 0x1EE32, 0x1EE34, 0x1EE35, 0x1EE36, 0x1EE37, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE4D, 0x1EE4E, 0x1EE4F, 0x1EE51, 0x1EE52, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, 0x1EE67, 0x1EE68, 0x1EE69, 0x1EE6A, 0x1EE6C, 0x1EE6D, 0x1EE6E, 0x1EE6F, 0x1EE70, 0x1EE71, 0x1EE72, 0x1EE74, 0x1EE75, 0x1EE76, 0x1EE77, 0x1EE79, 0x1EE7A, 0x1EE7B, 0x1EE7C, 0x1EE7E, 0x1EE80, 0x1EE81, 0x1EE82, 0x1EE83, 0x1EE84, 0x1EE85, 0x1EE86, 0x1EE87, 0x1EE88, 0x1EE89, 0x1EE8B, 0x1EE8C, 0x1EE8D, 0x1EE8E, 0x1EE8F, 0x1EE90, 0x1EE91, 0x1EE92, 0x1EE93, 0x1EE94, 0x1EE95, 0x1EE96, 0x1EE97, 0x1EE98, 0x1EE99, 0x1EE9A, 0x1EE9B, 0x1EEA1, 0x1EEA2, 0x1EEA3, 0x1EEA5, 0x1EEA6, 0x1EEA7, 0x1EEA8, 0x1EEA9, 0x1EEAB, 0x1EEAC, 0x1EEAD, 0x1EEAE, 0x1EEAF, 0x1EEB0, 0x1EEB1, 0x1EEB2, 0x1EEB3, 0x1EEB4, 0x1EEB5, 0x1EEB6, 0x1EEB7, 0x1EEB8, 0x1EEB9, 0x1EEBA, 0x1EEBB, 0x10FFFD];
      function determineBidi(cueDiv) {
        var nodeStack = [],
            text = "",
            charCode;
        if (!cueDiv || !cueDiv.childNodes) {
          return "ltr";
        }
        function pushNodes(nodeStack, node) {
          for (var i = node.childNodes.length - 1; i >= 0; i--) {
            nodeStack.push(node.childNodes[i]);
          }
        }
        function nextTextNode(nodeStack) {
          if (!nodeStack || !nodeStack.length) {
            return null;
          }
          var node = nodeStack.pop(),
              text = node.textContent || node.innerText;
          if (text) {
            var m = text.match(/^.*(\n|\r)/);
            if (m) {
              nodeStack.length = 0;
              return m[0];
            }
            return text;
          }
          if (node.tagName === "ruby") {
            return nextTextNode(nodeStack);
          }
          if (node.childNodes) {
            pushNodes(nodeStack, node);
            return nextTextNode(nodeStack);
          }
        }
        pushNodes(nodeStack, cueDiv);
        while ((text = nextTextNode(nodeStack))) {
          for (var i = 0; i < text.length; i++) {
            charCode = text.charCodeAt(i);
            for (var j = 0; j < strongRTLChars.length; j++) {
              if (strongRTLChars[j] === charCode) {
                return "rtl";
              }
            }
          }
        }
        return "ltr";
      }
      function computeLinePos(cue) {
        if (typeof cue.line === "number" && (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {
          return cue.line;
        }
        if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {
          return -1;
        }
        var track = cue.track,
            trackList = track.textTrackList,
            count = 0;
        for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
          if (trackList[i].mode === "showing") {
            count++;
          }
        }
        return ++count * -1;
      }
      function StyleBox() {}
      StyleBox.prototype.applyStyles = function(styles, div) {
        div = div || this.div;
        for (var prop in styles) {
          if (styles.hasOwnProperty(prop)) {
            div.style[prop] = styles[prop];
          }
        }
      };
      StyleBox.prototype.formatStyle = function(val, unit) {
        return val === 0 ? 0 : val + unit;
      };
      function CueStyleBox(window, cue, styleOptions) {
        var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
        var color = "rgba(255, 255, 255, 1)";
        var backgroundColor = "rgba(0, 0, 0, 0.8)";
        if (isIE8) {
          color = "rgb(255, 255, 255)";
          backgroundColor = "rgb(0, 0, 0)";
        }
        StyleBox.call(this);
        this.cue = cue;
        this.cueDiv = parseContent(window, cue.text);
        var styles = {
          color: color,
          backgroundColor: backgroundColor,
          position: "relative",
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          display: "inline"
        };
        if (!isIE8) {
          styles.writingMode = cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl";
          styles.unicodeBidi = "plaintext";
        }
        this.applyStyles(styles, this.cueDiv);
        this.div = window.document.createElement("div");
        styles = {
          textAlign: cue.align === "middle" ? "center" : cue.align,
          font: styleOptions.font,
          whiteSpace: "pre-line",
          position: "absolute"
        };
        if (!isIE8) {
          styles.direction = determineBidi(this.cueDiv);
          styles.writingMode = cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl".stylesunicodeBidi = "plaintext";
        }
        this.applyStyles(styles);
        this.div.appendChild(this.cueDiv);
        var textPos = 0;
        switch (cue.positionAlign) {
          case "start":
            textPos = cue.position;
            break;
          case "middle":
            textPos = cue.position - (cue.size / 2);
            break;
          case "end":
            textPos = cue.position - cue.size;
            break;
        }
        if (cue.vertical === "") {
          this.applyStyles({
            left: this.formatStyle(textPos, "%"),
            width: this.formatStyle(cue.size, "%")
          });
        } else {
          this.applyStyles({
            top: this.formatStyle(textPos, "%"),
            height: this.formatStyle(cue.size, "%")
          });
        }
        this.move = function(box) {
          this.applyStyles({
            top: this.formatStyle(box.top, "px"),
            bottom: this.formatStyle(box.bottom, "px"),
            left: this.formatStyle(box.left, "px"),
            right: this.formatStyle(box.right, "px"),
            height: this.formatStyle(box.height, "px"),
            width: this.formatStyle(box.width, "px")
          });
        };
      }
      CueStyleBox.prototype = _objCreate(StyleBox.prototype);
      CueStyleBox.prototype.constructor = CueStyleBox;
      function BoxPosition(obj) {
        var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
        var lh,
            height,
            width,
            top;
        if (obj.div) {
          height = obj.div.offsetHeight;
          width = obj.div.offsetWidth;
          top = obj.div.offsetTop;
          var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
          obj = obj.div.getBoundingClientRect();
          lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length) : 0;
        }
        this.left = obj.left;
        this.right = obj.right;
        this.top = obj.top || top;
        this.height = obj.height || height;
        this.bottom = obj.bottom || (top + (obj.height || height));
        this.width = obj.width || width;
        this.lineHeight = lh !== undefined ? lh : obj.lineHeight;
        if (isIE8 && !this.lineHeight) {
          this.lineHeight = 13;
        }
      }
      BoxPosition.prototype.move = function(axis, toMove) {
        toMove = toMove !== undefined ? toMove : this.lineHeight;
        switch (axis) {
          case "+x":
            this.left += toMove;
            this.right += toMove;
            break;
          case "-x":
            this.left -= toMove;
            this.right -= toMove;
            break;
          case "+y":
            this.top += toMove;
            this.bottom += toMove;
            break;
          case "-y":
            this.top -= toMove;
            this.bottom -= toMove;
            break;
        }
      };
      BoxPosition.prototype.overlaps = function(b2) {
        return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
      };
      BoxPosition.prototype.overlapsAny = function(boxes) {
        for (var i = 0; i < boxes.length; i++) {
          if (this.overlaps(boxes[i])) {
            return true;
          }
        }
        return false;
      };
      BoxPosition.prototype.within = function(container) {
        return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;
      };
      BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
        switch (axis) {
          case "+x":
            return this.left < container.left;
          case "-x":
            return this.right > container.right;
          case "+y":
            return this.top < container.top;
          case "-y":
            return this.bottom > container.bottom;
        }
      };
      BoxPosition.prototype.intersectPercentage = function(b2) {
        var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),
            y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),
            intersectArea = x * y;
        return intersectArea / (this.height * this.width);
      };
      BoxPosition.prototype.toCSSCompatValues = function(reference) {
        return {
          top: this.top - reference.top,
          bottom: reference.bottom - this.bottom,
          left: this.left - reference.left,
          right: reference.right - this.right,
          height: this.height,
          width: this.width
        };
      };
      BoxPosition.getSimpleBoxPosition = function(obj) {
        var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
        var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
        var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;
        obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;
        var ret = {
          left: obj.left,
          right: obj.right,
          top: obj.top || top,
          height: obj.height || height,
          bottom: obj.bottom || (top + (obj.height || height)),
          width: obj.width || width
        };
        return ret;
      };
      function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {
        function findBestPosition(b, axis) {
          var bestPosition,
              specifiedPosition = new BoxPosition(b),
              percentage = 1;
          for (var i = 0; i < axis.length; i++) {
            while (b.overlapsOppositeAxis(containerBox, axis[i]) || (b.within(containerBox) && b.overlapsAny(boxPositions))) {
              b.move(axis[i]);
            }
            if (b.within(containerBox)) {
              return b;
            }
            var p = b.intersectPercentage(containerBox);
            if (percentage > p) {
              bestPosition = new BoxPosition(b);
              percentage = p;
            }
            b = new BoxPosition(specifiedPosition);
          }
          return bestPosition || specifiedPosition;
        }
        var boxPosition = new BoxPosition(styleBox),
            cue = styleBox.cue,
            linePos = computeLinePos(cue),
            axis = [];
        if (cue.snapToLines) {
          var size;
          switch (cue.vertical) {
            case "":
              axis = ["+y", "-y"];
              size = "height";
              break;
            case "rl":
              axis = ["+x", "-x"];
              size = "width";
              break;
            case "lr":
              axis = ["-x", "+x"];
              size = "width";
              break;
          }
          var step = boxPosition.lineHeight,
              position = step * Math.round(linePos),
              maxPosition = containerBox[size] + step,
              initialAxis = axis[0];
          if (Math.abs(position) > maxPosition) {
            position = position < 0 ? -1 : 1;
            position *= Math.ceil(maxPosition / step) * step;
          }
          if (linePos < 0) {
            position += cue.vertical === "" ? containerBox.height : containerBox.width;
            axis = axis.reverse();
          }
          boxPosition.move(initialAxis, position);
        } else {
          var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;
          switch (cue.lineAlign) {
            case "middle":
              linePos -= (calculatedPercentage / 2);
              break;
            case "end":
              linePos -= calculatedPercentage;
              break;
          }
          switch (cue.vertical) {
            case "":
              styleBox.applyStyles({top: styleBox.formatStyle(linePos, "%")});
              break;
            case "rl":
              styleBox.applyStyles({left: styleBox.formatStyle(linePos, "%")});
              break;
            case "lr":
              styleBox.applyStyles({right: styleBox.formatStyle(linePos, "%")});
              break;
          }
          axis = ["+y", "-x", "+x", "-y"];
          boxPosition = new BoxPosition(styleBox);
        }
        var bestPosition = findBestPosition(boxPosition, axis);
        styleBox.move(bestPosition.toCSSCompatValues(containerBox));
      }
      function WebVTT() {}
      WebVTT.StringDecoder = function() {
        return {decode: function(data) {
            if (!data) {
              return "";
            }
            if (typeof data !== "string") {
              throw new Error("Error - expected string data.");
            }
            return decodeURIComponent(encodeURIComponent(data));
          }};
      };
      WebVTT.convertCueToDOMTree = function(window, cuetext) {
        if (!window || !cuetext) {
          return null;
        }
        return parseContent(window, cuetext);
      };
      var FONT_SIZE_PERCENT = 0.05;
      var FONT_STYLE = "sans-serif";
      var CUE_BACKGROUND_PADDING = "1.5%";
      WebVTT.processCues = function(window, cues, overlay) {
        if (!window || !cues || !overlay) {
          return null;
        }
        while (overlay.firstChild) {
          overlay.removeChild(overlay.firstChild);
        }
        var paddedOverlay = window.document.createElement("div");
        paddedOverlay.style.position = "absolute";
        paddedOverlay.style.left = "0";
        paddedOverlay.style.right = "0";
        paddedOverlay.style.top = "0";
        paddedOverlay.style.bottom = "0";
        paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
        overlay.appendChild(paddedOverlay);
        function shouldCompute(cues) {
          for (var i = 0; i < cues.length; i++) {
            if (cues[i].hasBeenReset || !cues[i].displayState) {
              return true;
            }
          }
          return false;
        }
        if (!shouldCompute(cues)) {
          for (var i = 0; i < cues.length; i++) {
            paddedOverlay.appendChild(cues[i].displayState);
          }
          return;
        }
        var boxPositions = [],
            containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),
            fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
        var styleOptions = {font: fontSize + "px " + FONT_STYLE};
        (function() {
          var styleBox,
              cue;
          for (var i = 0; i < cues.length; i++) {
            cue = cues[i];
            styleBox = new CueStyleBox(window, cue, styleOptions);
            paddedOverlay.appendChild(styleBox.div);
            moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);
            cue.displayState = styleBox.div;
            boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
          }
        })();
      };
      WebVTT.Parser = function(window, vttjs, decoder) {
        if (!decoder) {
          decoder = vttjs;
          vttjs = {};
        }
        if (!vttjs) {
          vttjs = {};
        }
        this.window = window;
        this.vttjs = vttjs;
        this.state = "INITIAL";
        this.buffer = "";
        this.decoder = decoder || new TextDecoder("utf8");
        this.regionList = [];
      };
      WebVTT.Parser.prototype = {
        reportOrThrowError: function(e) {
          if (e instanceof ParsingError) {
            this.onparsingerror && this.onparsingerror(e);
          } else {
            throw e;
          }
        },
        parse: function(data) {
          var self = this;
          if (data) {
            self.buffer += self.decoder.decode(data, {stream: true});
          }
          function collectNextLine() {
            var buffer = self.buffer;
            var pos = 0;
            while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
              ++pos;
            }
            var line = buffer.substr(0, pos);
            if (buffer[pos] === '\r') {
              ++pos;
            }
            if (buffer[pos] === '\n') {
              ++pos;
            }
            self.buffer = buffer.substr(pos);
            return line;
          }
          function parseRegion(input) {
            var settings = new Settings();
            parseOptions(input, function(k, v) {
              switch (k) {
                case "id":
                  settings.set(k, v);
                  break;
                case "width":
                  settings.percent(k, v);
                  break;
                case "lines":
                  settings.integer(k, v);
                  break;
                case "regionanchor":
                case "viewportanchor":
                  var xy = v.split(',');
                  if (xy.length !== 2) {
                    break;
                  }
                  var anchor = new Settings();
                  anchor.percent("x", xy[0]);
                  anchor.percent("y", xy[1]);
                  if (!anchor.has("x") || !anchor.has("y")) {
                    break;
                  }
                  settings.set(k + "X", anchor.get("x"));
                  settings.set(k + "Y", anchor.get("y"));
                  break;
                case "scroll":
                  settings.alt(k, v, ["up"]);
                  break;
              }
            }, /=/, /\s/);
            if (settings.has("id")) {
              var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();
              region.width = settings.get("width", 100);
              region.lines = settings.get("lines", 3);
              region.regionAnchorX = settings.get("regionanchorX", 0);
              region.regionAnchorY = settings.get("regionanchorY", 100);
              region.viewportAnchorX = settings.get("viewportanchorX", 0);
              region.viewportAnchorY = settings.get("viewportanchorY", 100);
              region.scroll = settings.get("scroll", "");
              self.onregion && self.onregion(region);
              self.regionList.push({
                id: settings.get("id"),
                region: region
              });
            }
          }
          function parseHeader(input) {
            parseOptions(input, function(k, v) {
              switch (k) {
                case "Region":
                  parseRegion(v);
                  break;
              }
            }, /:/);
          }
          try {
            var line;
            if (self.state === "INITIAL") {
              if (!/\r\n|\n/.test(self.buffer)) {
                return this;
              }
              line = collectNextLine();
              var m = line.match(/^WEBVTT([ \t].*)?$/);
              if (!m || !m[0]) {
                throw new ParsingError(ParsingError.Errors.BadSignature);
              }
              self.state = "HEADER";
            }
            var alreadyCollectedLine = false;
            while (self.buffer) {
              if (!/\r\n|\n/.test(self.buffer)) {
                return this;
              }
              if (!alreadyCollectedLine) {
                line = collectNextLine();
              } else {
                alreadyCollectedLine = false;
              }
              switch (self.state) {
                case "HEADER":
                  if (/:/.test(line)) {
                    parseHeader(line);
                  } else if (!line) {
                    self.state = "ID";
                  }
                  continue;
                case "NOTE":
                  if (!line) {
                    self.state = "ID";
                  }
                  continue;
                case "ID":
                  if (/^NOTE($|[ \t])/.test(line)) {
                    self.state = "NOTE";
                    break;
                  }
                  if (!line) {
                    continue;
                  }
                  self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
                  self.state = "CUE";
                  if (line.indexOf("-->") === -1) {
                    self.cue.id = line;
                    continue;
                  }
                case "CUE":
                  try {
                    parseCue(line, self.cue, self.regionList);
                  } catch (e) {
                    self.reportOrThrowError(e);
                    self.cue = null;
                    self.state = "BADCUE";
                    continue;
                  }
                  self.state = "CUETEXT";
                  continue;
                case "CUETEXT":
                  var hasSubstring = line.indexOf("-->") !== -1;
                  if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                    self.oncue && self.oncue(self.cue);
                    self.cue = null;
                    self.state = "ID";
                    continue;
                  }
                  if (self.cue.text) {
                    self.cue.text += "\n";
                  }
                  self.cue.text += line;
                  continue;
                case "BADCUE":
                  if (!line) {
                    self.state = "ID";
                  }
                  continue;
              }
            }
          } catch (e) {
            self.reportOrThrowError(e);
            if (self.state === "CUETEXT" && self.cue && self.oncue) {
              self.oncue(self.cue);
            }
            self.cue = null;
            self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
          }
          return this;
        },
        flush: function() {
          var self = this;
          try {
            self.buffer += self.decoder.decode();
            if (self.cue || self.state === "HEADER") {
              self.buffer += "\n\n";
              self.parse();
            }
            if (self.state === "INITIAL") {
              throw new ParsingError(ParsingError.Errors.BadSignature);
            }
          } catch (e) {
            self.reportOrThrowError(e);
          }
          self.onflush && self.onflush();
          return this;
        }
      };
      global.WebVTT = WebVTT;
    }(this, (this.vttjs || {})));
  })(require("github:jspm/nodelibs-buffer@0.1.0.js").Buffer, require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/index.js", ["github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      var undefined;
      var VERSION = '3.10.1';
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
      var LARGE_ARRAY_SIZE = 200;
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var PLACEHOLDER = '__lodash_placeholder__';
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
      var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
      var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reHasHexPrefix = /^0[xX]/;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^\d+$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
      var contextProps = ['Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number', 'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite', 'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcC': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xeC': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss'
      };
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
      var objectTypes = {
        'function': true,
        'object': true
      };
      var regexpEscapes = {
        '0': 'x30',
        '1': 'x31',
        '2': 'x32',
        '3': 'x33',
        '4': 'x34',
        '5': 'x35',
        '6': 'x36',
        '7': 'x37',
        '8': 'x38',
        '9': 'x39',
        'A': 'x41',
        'B': 'x42',
        'C': 'x43',
        'D': 'x44',
        'E': 'x45',
        'F': 'x46',
        'a': 'x61',
        'b': 'x62',
        'c': 'x63',
        'd': 'x64',
        'e': 'x65',
        'f': 'x66',
        'n': 'x6e',
        'r': 'x72',
        't': 'x74',
        'u': 'x75',
        'v': 'x76',
        'x': 'x78'
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
      var freeSelf = objectTypes[typeof self] && self && self.Object && self;
      var freeWindow = objectTypes[typeof window] && window && window.Object && window;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;
          var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;
          if ((value > other && !othIsNull) || !valIsReflexive || (valIsNull && !othIsUndef && othIsReflexive) || (valIsUndef && othIsReflexive)) {
            return 1;
          }
          if ((value < other && !valIsNull) || !othIsReflexive || (othIsNull && !valIsUndef && valIsReflexive) || (othIsUndef && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsFunction(value) {
        return typeof value == 'function' || false;
      }
      function baseToString(value) {
        return value == null ? '' : (value + '');
      }
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * ((order === 'asc' || order === true) ? 1 : -1);
          }
        }
        return object.index - other.index;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
        if (leadingChar) {
          chr = regexpEscapes[chr];
        } else if (whitespaceChar) {
          chr = stringEscapes[chr];
        }
        return '\\' + chr;
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 || (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;
        var fnToString = Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = root._;
        var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = context.ArrayBuffer,
            clearTimeout = context.clearTimeout,
            parseFloat = context.parseFloat,
            pow = Math.pow,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = context.Uint8Array,
            WeakMap = getNative(context, 'WeakMap');
        var nativeCeil = Math.ceil,
            nativeCreate = getNative(Object, 'create'),
            nativeFloor = Math.floor,
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var metaMap = WeakMap && new WeakMap;
        var realNames = {};
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = [];
        }
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = arrayCopy(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = arrayCopy(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = arrayCopy(this.__views__);
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
          }
          var result = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
                value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
        function MapCache() {
          this.__data__ = {};
        }
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
        function SetCache(values) {
          var length = values ? values.length : 0;
          this.data = {
            'hash': nativeCreate(null),
            'set': new Set
          };
          while (length--) {
            this.push(values[length]);
          }
        }
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
          return result ? 0 : -1;
        }
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
        function arrayConcat(array, other) {
          var index = -1,
              length = array.length,
              othIndex = -1,
              othLength = other.length,
              result = Array(length + othLength);
          while (++index < length) {
            result[index] = array[index];
          }
          while (++othIndex < othLength) {
            result[index++] = other[othIndex];
          }
          return result;
        }
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayExtremum(array, iteratee, comparator, exValue) {
          var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;
          while (++index < length) {
            var value = array[index],
                current = +iteratee(value);
            if (comparator(current, computed)) {
              computed = current;
              result = value;
            }
          }
          return result;
        }
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1,
              length = values.length,
              offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function arraySum(array, iteratee) {
          var length = array.length,
              result = 0;
          while (length--) {
            result += +iteratee(array[length]) || 0;
          }
          return result;
        }
        function assignDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (objectValue === undefined || !hasOwnProperty.call(object, key)) ? sourceValue : objectValue;
        }
        function assignWith(object, source, customizer) {
          var index = -1,
              props = keys(source),
              length = props.length;
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
            if ((result === result ? (result !== value) : (value === value)) || (value === undefined && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
        function baseAssign(object, source) {
          return source == null ? object : baseCopy(source, keys(source), object);
        }
        function baseAt(collection, props) {
          var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);
          while (++index < propsLength) {
            var key = props[index];
            if (isArr) {
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = isNil ? undefined : collection[key];
            }
          }
          return result;
        }
        function baseCopy(source, props, object) {
          object || (object = {});
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseAssign(result, value);
              }
            } else {
              return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : (object ? value : {});
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
        var baseCreate = (function() {
          function object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              object.prototype = prototype;
              var result = new object;
              object.prototype = undefined;
            }
            return result || {};
          };
        }());
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined, args);
          }, wait);
        }
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
              valuesLength = values.length;
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer: while (++index < length) {
            var value = array[index];
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (indexOf(values, value, 0) < 0) {
              result.push(value);
            }
          }
          return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseExtremum(collection, iteratee, comparator, exValue) {
          var computed = exValue,
              result = computed;
          baseEach(collection, function(value, index, collection) {
            var current = +iteratee(value, index, collection);
            if (comparator(current, computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end >>> 0);
          start >>>= 0;
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
        function baseFlatten(array, isDeep, isStrict, result) {
          result || (result = []);
          var index = -1,
              length = array.length;
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
              if (isDeep) {
                baseFlatten(value, isDeep, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
        function baseGet(object, path, pathKey) {
          if (object == null) {
            return;
          }
          if (pathKey !== undefined && pathKey in toObject(object)) {
            path = [pathKey];
          }
          var index = 0,
              length = path.length;
          while (object != null && index < length) {
            object = object[path[index++]];
          }
          return (index && index == length) ? object : undefined;
        }
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          if (!isLoose) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          stackA.push(object);
          stackB.push(other);
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
          stackA.pop();
          stackB.pop();
          return result;
        }
        function baseIsMatch(object, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = toObject(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            var key = matchData[0][0],
                value = matchData[0][1];
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === value && (value !== undefined || (key in toObject(object)));
            };
          }
          return function(object) {
            return baseIsMatch(object, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            if (object == null) {
              return false;
            }
            var key = pathKey;
            object = toObject(object);
            if ((isArr || !isCommon) && !(key in object)) {
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              key = last(path);
              object = toObject(object);
            }
            return object[key] === srcValue ? (srcValue !== undefined || (key in object)) : baseIsEqual(srcValue, object[key], undefined, true);
          };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? undefined : keys(source);
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            } else {
              var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;
              if (isCommon) {
                result = srcValue;
              }
              if ((result !== undefined || (isSrcArr && !(key in object))) && (isCommon || (result === result ? (result !== value) : (value === value)))) {
                object[key] = result;
              }
            }
          });
          return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;
          if (isCommon) {
            result = srcValue;
            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value) ? value : (isArrayLike(value) ? arrayCopy(value) : []);
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value) ? toPlainObject(value) : (isPlainObject(value) ? value : {});
            } else {
              isCommon = false;
            }
          }
          stackA.push(srcValue);
          stackB.push(result);
          if (isCommon) {
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? (result !== value) : (value === value)) {
            object[key] = result;
          }
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
        function basePropertyDeep(path) {
          var pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            return baseGet(object, path, pathKey);
          };
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          while (length--) {
            var index = indexes[length];
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return array;
        }
        function baseRandom(min, max) {
          return min + nativeFloor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSortByOrder(collection, iteratees, orders) {
          var callback = getCallback(),
              index = -1;
          iteratees = arrayMap(iteratees, function(iteratee) {
            return callback(iteratee);
          });
          var result = baseMap(collection, function(value) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return {
              'criteria': criteria,
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function baseSum(collection, iteratee) {
          var result = 0;
          baseEach(collection, function(value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
          });
          return result;
        }
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
              seen = isLarge ? createCache() : null,
              result = [];
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (indexOf(seen, computed, 0) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
          while (++index < length) {
            var action = actions[index];
            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
          }
          return result;
        }
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
              if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsNull) {
              setLow = isReflexive && isDef && (retHighest || computed != null);
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || isDef);
            } else if (computed == null) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (thisArg === undefined) {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            case 5:
              return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
        function bufferClone(buffer) {
          var result = new ArrayBuffer(buffer.byteLength),
              view = new Uint8Array(result);
          view.set(new Uint8Array(buffer));
          return result;
        }
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(leftLength + argsLength);
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createAssigner(assigner) {
          return restParam(function(object, sources) {
            var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;
            if (typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = typeof thisArg == 'function' ? thisArg : undefined;
              length -= (customizer ? 1 : 0);
            }
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              return eachFunc(collection, iteratee);
            }
            var index = fromRight ? length : -1,
                iterable = toObject(collection);
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length)) {
              var key = props[index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
        function createCache(values) {
          return (nativeCreate && Set) ? new SetCache(values) : null;
        }
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
        function createCtorWrapper(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor;
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createCurry(flag) {
          function curryFunc(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
              arity = undefined;
            }
            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryFunc.placeholder;
            return result;
          }
          return curryFunc;
        }
        function createDefaults(assigner, customizer) {
          return restParam(function(args) {
            var object = args[0];
            if (object == null) {
              return object;
            }
            args.push(customizer);
            return assigner.apply(undefined, args);
          });
        }
        function createExtremum(comparator, exValue) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            if (iteratee.length == 1) {
              collection = isArray(collection) ? collection : toIterable(collection);
              var result = arrayExtremum(collection, iteratee, comparator, exValue);
              if (!(collection.length && result === exValue)) {
                return result;
              }
            }
            return baseExtremum(collection, iteratee, comparator, exValue);
          };
        }
        function createFind(eachFunc, fromRight) {
          return function(collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
              var index = baseFindIndex(collection, predicate, fromRight);
              return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, eachFunc);
          };
        }
        function createFindIndex(fromRight) {
          return function(array, predicate, thisArg) {
            if (!(array && array.length)) {
              return -1;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFindIndex(array, predicate, fromRight);
          };
        }
        function createFindKey(objectFunc) {
          return function(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
          };
        }
        function createFlow(fromRight) {
          return function() {
            var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);
            while ((fromRight ? index-- : ++index < length)) {
              var func = funcs[leftIndex++] = arguments[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? -1 : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
              if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];
              if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
        function createForEach(arrayFunc, eachFunc) {
          return function(collection, iteratee, thisArg) {
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
          };
        }
        function createForIn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee, keysIn);
          };
        }
        function createForOwn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee);
          };
        }
        function createObjectMapper(isMapKeys) {
          return function(object, iteratee, thisArg) {
            var result = {};
            iteratee = getCallback(iteratee, thisArg, 3);
            baseForOwn(object, function(value, key, object) {
              var mapped = iteratee(value, key, object);
              key = isMapKeys ? mapped : key;
              value = isMapKeys ? value : mapped;
              result[key] = value;
            });
            return result;
          };
        }
        function createPadDir(fromRight) {
          return function(string, length, chars) {
            string = baseToString(string);
            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
          };
        }
        function createPartial(flag) {
          var partialFunc = restParam(function(func, partials) {
            var holders = replaceHolders(partials, partialFunc.placeholder);
            return createWrapper(func, flag, undefined, partials, holders);
          });
          return partialFunc;
        }
        function createReduce(arrayFunc, eachFunc) {
          return function(collection, iteratee, accumulator, thisArg) {
            var initFromArray = arguments.length < 3;
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
          };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);
          function wrapper() {
            var length = arguments.length,
                index = length,
                args = Array(length);
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : undefined,
                    newHoldersRight = isCurry ? undefined : argsHolders,
                    newPartials = isCurry ? args : undefined,
                    newPartialsRight = isCurry ? undefined : args;
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(func);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPadding(string, length, chars) {
          var strLength = string.length;
          length = +length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength);
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            precision = precision === undefined ? 0 : (+precision || 0);
            if (precision) {
              precision = pow(10, precision);
              return func(number * precision) / precision;
            }
            return func(number);
          };
        }
        function createSortedIndex(retHighest) {
          return function(array, value, iteratee, thisArg) {
            var callback = getCallback(iteratee);
            return (iteratee == null && callback === baseCallback) ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
          };
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
          if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null ? (isBindKey ? 0 : func.length) : (nativeMax(arity - length, 0) || 0);
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length;
          if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
            return false;
          }
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
            if (result !== undefined) {
              if (result) {
                continue;
              }
              return false;
            }
            if (isLoose) {
              if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
                return false;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
              return false;
            }
          }
          return true;
        }
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              return +object == +other;
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case numberTag:
              return (object != +object) ? other != +other : object == +other;
            case regexpTag:
            case stringTag:
              return object == (other + '');
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
          if (objLength != othLength && !isLoose) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var skipCtor = isLoose;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
              return false;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (!skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result = func.name,
              array = realNames[result],
              length = array ? array.length : 0;
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
        var getLength = baseProperty('length');
        function getMatchData(object) {
          var result = pairs(object),
              length = result.length;
          while (length--) {
            result[length][2] = isStrictComparable(result[length][1]);
          }
          return result;
        }
        function getNative(object, key) {
          var value = object == null ? undefined : object[key];
          return isNative(value) ? value : undefined;
        }
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
        function invokePath(object, path, args) {
          if (object != null && !isKey(path, object)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            path = last(path);
          }
          var func = object == null ? object : object[path];
          return func == null ? undefined : func.apply(object, args);
        }
        function isArrayLike(value) {
          return value != null && isLength(getLength(value));
        }
        function isIndex(value, length) {
          value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
          }
          return false;
        }
        function isKey(value, object) {
          var type = typeof value;
          if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
            return true;
          }
          if (isArray(value)) {
            return false;
          }
          var result = !reIsDeepProp.test(value);
          return result || (object != null && value in toObject(object));
        }
        function isLaziable(func) {
          var funcName = getFuncName(func);
          if (!(funcName in LazyWrapper.prototype)) {
            return false;
          }
          var other = lodash[funcName];
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;
          var isCombo = (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) || (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) || (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function mergeDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
        }
        function pickByArray(object, props) {
          object = toObject(object);
          var index = -1,
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;
          var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
          var index = -1,
              result = [];
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isArrayLike(value)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
        function toPath(value) {
          if (isArray(value)) {
            return value;
          }
          var result = [];
          baseToString(value).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        }
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(nativeFloor(size) || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(nativeCeil(length / size));
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        var difference = restParam(function(array, values) {
          return (isObjectLike(array) && isArrayLike(array)) ? baseDifference(array, baseFlatten(values, false, true)) : [];
        });
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
        }
        function dropWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        var findIndex = createFindIndex();
        var findLastIndex = createFindIndex(true);
        function first(array) {
          return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value);
            if (index < length && (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        var intersection = restParam(function(arrays) {
          var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              result = [];
          while (othIndex--) {
            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
          }
          var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];
          outer: while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
              var othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        });
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull() {
          var args = arguments,
              array = args[0];
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = args.length;
          while (++index < length) {
            var fromIndex = 0,
                value = args[index];
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        var pullAt = restParam(function(array, indexes) {
          indexes = baseFlatten(indexes);
          var result = baseAt(array, indexes);
          basePullAt(array, indexes.sort(baseCompareAscending));
          return result;
        });
        function remove(array, predicate, thisArg) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
        function rest(array) {
          return drop(array, 1);
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
        var sortedIndex = createSortedIndex();
        var sortedLastIndex = createSortedIndex(true);
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
        }
        function takeWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
        }
        var union = restParam(function(arrays) {
          return baseUniq(baseFlatten(arrays, false, true));
        });
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
            isSorted = false;
          }
          var callback = getCallback();
          if (!(iteratee == null && callback === baseCallback)) {
            iteratee = callback(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var index = -1,
              length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLike(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          var result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
        function unzipWith(array, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          iteratee = bindCallback(iteratee, thisArg, 4);
          return arrayMap(result, function(group) {
            return arrayReduce(group, iteratee, undefined, true);
          });
        }
        var without = restParam(function(array, values) {
          return isArrayLike(array) ? baseDifference(array, values) : [];
        });
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArrayLike(array)) {
              var result = result ? arrayPush(baseDifference(result, array), baseDifference(array, result)) : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
        var zip = restParam(unzip);
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        var zipWith = restParam(function(arrays) {
          var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;
          if (length > 2 && typeof iteratee == 'function') {
            length -= 2;
          } else {
            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
            thisArg = undefined;
          }
          arrays.length = length;
          return unzipWith(arrays, iteratee, thisArg);
        });
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        var wrapperConcat = restParam(function(values) {
          values = baseFlatten(values);
          return this.thru(function(array) {
            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
          });
        });
        function wrapperPlant(value) {
          var result,
              parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          var interceptor = function(value) {
            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
          };
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(interceptor);
        }
        function wrapperToString() {
          return (this.value() + '');
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var at = restParam(function(collection, props) {
          return baseAt(collection, baseFlatten(props));
        });
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
        var find = createFind(baseEach);
        var findLast = createFind(baseEachRight, true);
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
        var forEach = createForEach(arrayEach, baseEach);
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function includes(collection, target, fromIndex, guard) {
          var length = collection ? getLength(collection) : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
            fromIndex = 0;
          } else {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1) : (!!length && getIndexOf(collection, target, fromIndex) > -1);
        }
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        var invoke = restParam(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
          });
          return result;
        });
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function pluck(collection, path) {
          return map(collection, property(path));
        }
        var reduce = createReduce(arrayReduce, baseEach);
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
          n = nativeMin(n < 0 ? 0 : (+n || 0), length);
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
        function shuffle(collection) {
          return sample(collection, POSITIVE_INFINITY);
        }
        function size(collection) {
          var length = collection ? getLength(collection) : 0;
          return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          var index = -1;
          iteratee = getCallback(iteratee, thisArg, 3);
          var result = baseMap(collection, function(value, key, collection) {
            return {
              'criteria': iteratee(value, key, collection),
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, compareAscending);
        }
        var sortByAll = restParam(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var guard = iteratees[2];
          if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
            iteratees.length = 1;
          }
          return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
        function sortByOrder(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(iteratees, orders, guard)) {
            orders = undefined;
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, iteratees, orders);
        }
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
          return new Date().getTime();
        };
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = undefined;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }
        var bind = restParam(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindAll = restParam(function(object, methodNames) {
          methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
          var index = -1,
              length = methodNames.length;
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        });
        var bindKey = restParam(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
        var curry = createCurry(CURRY_FLAG);
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = !!options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            lastCalled = 0;
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
          function complete(isCalled, id) {
            if (id) {
              clearTimeout(id);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (isCalled) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = undefined;
              }
            }
          }
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              complete(trailingCall, maxTimeoutId);
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
          function maxDelayed() {
            complete(trailing, timeoutId);
          }
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = undefined;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
        var defer = restParam(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = restParam(function(func, wait, args) {
          return baseDelay(func, wait, args);
        });
        var flow = createFlow();
        var flowRight = createFlow(true);
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
        var modArgs = restParam(function(func, transforms) {
          transforms = baseFlatten(transforms);
          if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = transforms.length;
          return restParam(function(args) {
            var index = nativeMin(args.length, length);
            while (index--) {
              args[index] = transforms[index](args[index]);
            }
            return func.apply(this, args);
          });
        });
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var partial = createPartial(PARTIAL_FLAG);
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
        var rearg = restParam(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
        });
        function restParam(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);
            while (++index < length) {
              rest[index] = args[start + index];
            }
            switch (start) {
              case 0:
                return func.call(this, rest);
              case 1:
                return func.call(this, args[0], rest);
              case 2:
                return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
          };
        }
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': +wait,
            'trailing': trailing
          });
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          } else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          return typeof customizer == 'function' ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1)) : baseClone(value, isDeep);
        }
        function cloneDeep(value, customizer, thisArg) {
          return typeof customizer == 'function' ? baseClone(value, true, bindCallback(customizer, thisArg, 1)) : baseClone(value, true);
        }
        function gt(value, other) {
          return value > other;
        }
        function gte(value, other) {
          return value >= other;
        }
        function isArguments(value) {
          return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        }
        var isArray = nativeIsArray || function(value) {
          return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
        }
        function isDate(value) {
          return isObjectLike(value) && objToString.call(value) == dateTag;
        }
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
            return !value.length;
          }
          return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }
        function isFunction(value) {
          return isObject(value) && objToString.call(value) == funcTag;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
        function isMatch(object, source, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          return baseIsMatch(object, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (isFunction(value)) {
            return reIsNative.test(fnToString.call(value));
          }
          return isObjectLike(value) && reIsHostCtor.test(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }
        function isPlainObject(value) {
          var Ctor;
          if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) || (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          var result;
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
        function isRegExp(value) {
          return isObject(value) && objToString.call(value) == regexpTag;
        }
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
        function isUndefined(value) {
          return value === undefined;
        }
        function lt(value, other) {
          return value < other;
        }
        function lte(value, other) {
          return value <= other;
        }
        function toArray(value) {
          var length = value ? getLength(value) : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
        var merge = createAssigner(baseMerge);
        var assign = createAssigner(function(object, source, customizer) {
          return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
        });
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = undefined;
          }
          return properties ? baseAssign(result, properties) : result;
        }
        var defaults = createDefaults(assign, assignDefaults);
        var defaultsDeep = createDefaults(merge, mergeDefaults);
        var findKey = createFindKey(baseForOwn);
        var findLastKey = createFindKey(baseForOwnRight);
        var forIn = createForIn(baseFor);
        var forInRight = createForIn(baseForRight);
        var forOwn = createForOwn(baseForOwn);
        var forOwnRight = createForOwn(baseForOwnRight);
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
          return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
          if (object == null) {
            return false;
          }
          var result = hasOwnProperty.call(object, path);
          if (!result && !isKey(path)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            if (object == null) {
              return false;
            }
            path = last(path);
            result = hasOwnProperty.call(object, path);
          }
          return result || (isLength(object.length) && isIndex(path, object.length) && (isArray(object) || isArguments(object)));
        }
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = undefined;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index],
                value = object[key];
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            } else {
              result[value] = key;
            }
          }
          return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
          var Ctor = object == null ? undefined : object.constructor;
          if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && isArrayLike(object))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) && (isArray(object) || isArguments(object)) && length) || 0;
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        var mapKeys = createObjectMapper(true);
        var mapValues = createObjectMapper();
        var omit = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          if (typeof props[0] != 'function') {
            var props = arrayMap(baseFlatten(props), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          var predicate = bindCallback(props[0], props[1], 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        });
        function pairs(object) {
          object = toObject(object);
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        var pick = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          return typeof props[0] == 'function' ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
        });
        function result(object, path, defaultValue) {
          var result = object == null ? undefined : object[path];
          if (result === undefined) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              result = object == null ? undefined : object[last(path)];
            }
            result = result === undefined ? defaultValue : result;
          }
          return isFunction(result) ? result.call(object) : result;
        }
        function set(object, path, value) {
          if (object == null) {
            return object;
          }
          var pathKey = (path + '');
          path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
          while (nested != null && ++index < length) {
            var key = path[index];
            if (isObject(nested)) {
              if (index == lastIndex) {
                nested[key] = value;
              } else if (nested[key] == null) {
                nested[key] = isIndex(path[index + 1]) ? [] : {};
              }
            }
            nested = nested[key];
          }
          return object;
        }
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          return baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
          start = +start || 0;
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = undefined;
          }
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            } else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
          var length = string.length;
          position = position === undefined ? length : nativeMin(position < 0 ? 0 : (+position || 0), length);
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string)) ? string.replace(reRegExpChars, escapeRegExpChar) : (string || '(?:)');
        }
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = nativeFloor(mid),
              rightLength = nativeCeil(mid);
          chars = createPadding('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
        var padLeft = createPadDir();
        var padRight = createPadDir(true);
        function parseInt(string, radix, guard) {
          if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = trim(string);
          return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            string += string;
          } while (n);
          return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
          return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
          var settings = lodash.templateSettings;
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = undefined;
          }
          string = baseToString(string);
          options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
          var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? (+options.length || 0) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = undefined;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
        var attempt = restParam(function(func, args) {
          try {
            return func.apply(undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = undefined;
          }
          return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
        var method = restParam(function(path, args) {
          return function(object) {
            return invokePath(object, path, args);
          };
        });
        var methodOf = restParam(function(object, args) {
          return function(path) {
            return invokePath(object, path, args);
          };
        });
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj ? keys(source) : undefined,
                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);
                    actions.push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }(func));
            }
          }
          return object;
        }
        function noConflict() {
          root._ = oldDash;
          return this;
        }
        function noop() {}
        function property(path) {
          return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return baseGet(object, toPath(path), path + '');
          };
        }
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = undefined;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function times(n, iteratee, thisArg) {
          n = nativeFloor(n);
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
        function add(augend, addend) {
          return (+augend || 0) + (+addend || 0);
        }
        var ceil = createRound('ceil');
        var floor = createRound('floor');
        var max = createExtremum(gt, NEGATIVE_INFINITY);
        var min = createExtremum(lt, POSITIVE_INFINITY);
        var round = createRound('round');
        function sum(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          return iteratee.length == 1 ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee) : baseSum(collection, iteratee);
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.modArgs = modArgs;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.floor = floor;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.eq = isEqual;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
        lodash.VERSION = VERSION;
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__;
            if (filtered && !index) {
              return new LazyWrapper(this);
            }
            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);
            var result = this.clone();
            if (filtered) {
              result.__takeCount__ = nativeMin(result.__takeCount__, n);
            } else {
              result.__views__.push({
                'size': n,
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type != LAZY_MAP_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getCallback(iteratee, thisArg, 1),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
          return this.reverse().takeWhile(predicate, thisArg).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(POSITIVE_INFINITY);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName),
              lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var args = retUnwrapped ? [1] : arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              isLazy = useLazy = false;
            }
            var interceptor = function(value) {
              return (retUnwrapped && chainAll) ? lodashFunc(value, 1)[0] : lodashFunc.apply(undefined, arrayPush([value], args));
            };
            var action = {
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            },
                onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              if (onlyLazy) {
                value = value.clone();
                value.__actions__.push(action);
                return func.call(value);
              }
              return lodashFunc.call(undefined, this.value())[0];
            }
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push(action);
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
        arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
          var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name,
                names = realNames[key] || (realNames[key] = []);
            names.push({
              'name': methodName,
              'func': lodashFunc
            });
          }
        });
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.concat = wrapperConcat;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:uuid@2.0.1.js", ["npm:uuid@2.0.1/uuid.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:uuid@2.0.1/uuid.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:bluebird@2.9.34.js", ["npm:bluebird@2.9.34/js/browser/bluebird.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:bluebird@2.9.34/js/browser/bluebird.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:url@0.10.3.js", ["npm:url@0.10.3/url.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:url@0.10.3/url.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xml2js@0.4.10.js", ["npm:xml2js@0.4.10/lib/xml2js.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:xml2js@0.4.10/lib/xml2js.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("client/lib/uri.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function addServerUriProperty(server) {
    server.uri = '/system/players/' + server.address;
  }
  function addDirectoryUriProperty(parentUrl, directory) {
    if (parentUrl[parentUrl.length - 1] !== '/') {
      parentUrl += '/';
    }
    if (directory.key[0] === '/') {
      parentUrl = '';
    }
    directory.uri = parentUrl + directory.key;
  }
  var uriResolvers = {
    directory: function directory(parentUrl, dir) {
      addDirectoryUriProperty(parentUrl, dir);
    },
    server: function server(parentUrl, srv) {
      addServerUriProperty(srv);
    }
  };
  function attach(parentUrl) {
    return function resolveAndAttachUris(result) {
      var children = result._children || [];
      children.forEach(function(child) {
        var childType = child._elementType.toLowerCase();
        var resolver = uriResolvers[childType];
        if (resolver) {
          resolver(parentUrl, child);
        }
      });
      return result;
    };
  }
  exports.attach = attach;
  ;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("client/lib/credentials.js", ["npm:plex-api-headers@1.1.0.js", "npm:util@0.10.3.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var headers = require("npm:plex-api-headers@1.1.0.js");
  var rxAuthToken = /authenticationToken="([^"]+)"/;
  var util = require("npm:util@0.10.3.js");
  var CredentialsAuthenticator = (function() {
    function CredentialsAuthenticator(username, password) {
      this.username = username;
      this.password = password;
    }
    CredentialsAuthenticator.prototype.authenticate = function(plexApi, callback) {
      if (typeof plexApi !== 'object') {
        throw new TypeError('First argument should be the plex-api object to perform authentication for');
      }
      if (typeof callback !== 'function') {
        throw new TypeError('Second argument should be a callback function to be called when authentication has finished');
      }
      window.fetch('https://plex.tv/users/sign_in.xml', {
        method: 'POST',
        headers: headers(plexApi, {Authorization: authHeaderVal(this.username, this.password)})
      }).then(function(response) {
        if (response.status !== 201) {
          return callback(new Error('Invalid status code in authentication response from Plex.tv, expected 201 but got ' + response.status));
        }
        var token = extractAuthToken(response.text());
        if (!token) {
          return callback(new Error('Couldnt not find authentication token in response from Plex.tv :('));
        }
        callback(null, token);
      });
    };
    return CredentialsAuthenticator;
  })();
  function extractAuthToken(xmlBody) {
    return xmlBody.match(rxAuthToken)[1];
  }
  function authHeaderVal(username, password) {
    var authString = username + ':' + password;
    var buffer = new Buffer(authString.toString(), 'binary');
    return 'Basic ' + buffer.toString('base64');
  }
  function default_1(options) {
    if (typeof(options) !== 'object') {
      throw new TypeError('An options object containing .username and .password is required');
    }
    if (typeof(options.username) !== 'string') {
      throw new TypeError('Options object requires a .username property as a string');
    }
    if (typeof(options.password) !== 'string') {
      throw new TypeError('Options object requires a .password property as a string');
    }
    return new CredentialsAuthenticator(options.username, options.password);
  }
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.default = default_1;
  ;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.aggregates.js", ["npm:rx@3.0.1/dist/rx.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(['rx'], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        CompositeDisposable = Rx.CompositeDisposable,
        AnonymousObservable = Rx.AnonymousObservable,
        AbstractObserver = Rx.internals.AbstractObserver,
        disposableEmpty = Rx.Disposable.empty,
        isEqual = Rx.internals.isEqual,
        helpers = Rx.helpers,
        not = helpers.not,
        defaultComparer = helpers.defaultComparer,
        identity = helpers.identity,
        defaultSubComparer = helpers.defaultSubComparer,
        isFunction = helpers.isFunction,
        isPromise = helpers.isPromise,
        isArrayLike = helpers.isArrayLike,
        isIterable = helpers.isIterable,
        inherits = Rx.internals.inherits,
        observableFromPromise = Observable.fromPromise,
        observableFrom = Observable.from,
        bindCallback = Rx.internals.bindCallback,
        EmptyError = Rx.EmptyError,
        ObservableBase = Rx.ObservableBase,
        ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function extremaBy(source, keySelector, comparer) {
      return new AnonymousObservable(function(o) {
        var hasValue = false,
            lastKey = null,
            list = [];
        return source.subscribe(function(x) {
          var comparison,
              key;
          try {
            key = keySelector(x);
          } catch (ex) {
            o.onError(ex);
            return;
          }
          comparison = 0;
          if (!hasValue) {
            hasValue = true;
            lastKey = key;
          } else {
            try {
              comparison = comparer(key, lastKey);
            } catch (ex1) {
              o.onError(ex1);
              return;
            }
          }
          if (comparison > 0) {
            lastKey = key;
            list = [];
          }
          if (comparison >= 0) {
            list.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(list);
          o.onCompleted();
        });
      }, source);
    }
    function firstOnly(x) {
      if (x.length === 0) {
        throw new EmptyError();
      }
      return x[0];
    }
    var ReduceObservable = (function(__super__) {
      inherits(ReduceObservable, __super__);
      function ReduceObservable(source, acc, hasSeed, seed) {
        this.source = source;
        this.acc = acc;
        this.hasSeed = hasSeed;
        this.seed = seed;
        __super__.call(this);
      }
      ReduceObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new InnerObserver(observer, this));
      };
      function InnerObserver(o, parent) {
        this.o = o;
        this.acc = parent.acc;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.result = null;
        this.hasValue = false;
        this.isStopped = false;
      }
      InnerObserver.prototype.onNext = function(x) {
        if (this.isStopped) {
          return;
        }
        !this.hasValue && (this.hasValue = true);
        if (this.hasAccumulation) {
          this.result = tryCatch(this.acc)(this.result, x);
        } else {
          this.result = this.hasSeed ? tryCatch(this.acc)(this.seed, x) : x;
          this.hasAccumulation = true;
        }
        if (this.result === errorObj) {
          this.o.onError(this.result.e);
        }
      };
      InnerObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      InnerObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.hasValue && this.o.onNext(this.result);
          !this.hasValue && this.hasSeed && this.o.onNext(this.seed);
          !this.hasValue && !this.hasSeed && this.o.onError(new EmptyError());
          this.o.onCompleted();
        }
      };
      InnerObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      InnerObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      return ReduceObservable;
    }(ObservableBase));
    observableProto.reduce = function(accumulator) {
      var hasSeed = false;
      if (arguments.length === 2) {
        hasSeed = true;
        var seed = arguments[1];
      }
      return new ReduceObservable(this, accumulator, hasSeed, seed);
    };
    var SomeObserver = (function(__super__) {
      inherits(SomeObserver, __super__);
      function SomeObserver(o, fn, s) {
        this._o = o;
        this._fn = fn;
        this._s = s;
        this._i = 0;
        __super__.call(this);
      }
      SomeObserver.prototype.next = function(x) {
        var result = tryCatch(this._fn)(x, this._i++, this._s);
        if (result === errorObj) {
          return this._o.onError(result.e);
        }
        if (Boolean(result)) {
          this._o.onNext(true);
          this._o.onCompleted();
        }
      };
      SomeObserver.prototype.error = function(e) {
        this._o.onError(e);
      };
      SomeObserver.prototype.completed = function() {
        this._o.onNext(false);
        this._o.onCompleted();
      };
      return SomeObserver;
    }(AbstractObserver));
    observableProto.some = function(predicate, thisArg) {
      var source = this,
          fn = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        return source.subscribe(new SomeObserver(o, fn, source));
      });
    };
    var IsEmptyObserver = (function(__super__) {
      inherits(IsEmptyObserver, __super__);
      function IsEmptyObserver(o) {
        this._o = o;
        __super__.call(this);
      }
      IsEmptyObserver.prototype.next = function() {
        this._o.onNext(false);
        this._o.onCompleted();
      };
      IsEmptyObserver.prototype.error = function(e) {
        this._o.onError(e);
      };
      IsEmptyObserver.prototype.completed = function() {
        this._o.onNext(true);
        this._o.onCompleted();
      };
      return IsEmptyObserver;
    }(AbstractObserver));
    observableProto.isEmpty = function() {
      var source = this;
      return new AnonymousObservable(function(o) {
        return source.subscribe(new IsEmptyObserver(o));
      }, source);
    };
    var EveryObserver = (function(__super__) {
      inherits(EveryObserver, __super__);
      function EveryObserver(o, fn, s) {
        this._o = o;
        this._fn = fn;
        this._s = s;
        this._i = 0;
        __super__.call(this);
      }
      EveryObserver.prototype.next = function(x) {
        var result = tryCatch(this._fn)(x, this._i++, this._s);
        if (result === errorObj) {
          return this._o.onError(result.e);
        }
        if (!Boolean(result)) {
          this._o.onNext(false);
          this._o.onCompleted();
        }
      };
      EveryObserver.prototype.error = function(e) {
        this._o.onError(e);
      };
      EveryObserver.prototype.completed = function() {
        this._o.onNext(true);
        this._o.onCompleted();
      };
      return EveryObserver;
    }(AbstractObserver));
    observableProto.every = function(predicate, thisArg) {
      var source = this,
          fn = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        return source.subscribe(new EveryObserver(o, fn, source));
      }, this);
    };
    observableProto.includes = function(searchElement, fromIndex) {
      var source = this;
      function comparer(a, b) {
        return (a === 0 && b === 0) || (a === b || (isNaN(a) && isNaN(b)));
      }
      return new AnonymousObservable(function(o) {
        var i = 0,
            n = +fromIndex || 0;
        Math.abs(n) === Infinity && (n = 0);
        if (n < 0) {
          o.onNext(false);
          o.onCompleted();
          return disposableEmpty;
        }
        return source.subscribe(function(x) {
          if (i++ >= n && comparer(x, searchElement)) {
            o.onNext(true);
            o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(false);
          o.onCompleted();
        });
      }, this);
    };
    observableProto.contains = function(searchElement, fromIndex) {
      observableProto.includes(searchElement, fromIndex);
    };
    observableProto.count = function(predicate, thisArg) {
      return predicate ? this.filter(predicate, thisArg).count() : this.reduce(function(count) {
        return count + 1;
      }, 0);
    };
    observableProto.indexOf = function(searchElement, fromIndex) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var i = 0,
            n = +fromIndex || 0;
        Math.abs(n) === Infinity && (n = 0);
        if (n < 0) {
          o.onNext(-1);
          o.onCompleted();
          return disposableEmpty;
        }
        return source.subscribe(function(x) {
          if (i >= n && x === searchElement) {
            o.onNext(i);
            o.onCompleted();
          }
          i++;
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(-1);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.sum = function(keySelector, thisArg) {
      return keySelector && isFunction(keySelector) ? this.map(keySelector, thisArg).sum() : this.reduce(function(prev, curr) {
        return prev + curr;
      }, 0);
    };
    observableProto.minBy = function(keySelector, comparer) {
      comparer || (comparer = defaultSubComparer);
      return extremaBy(this, keySelector, function(x, y) {
        return comparer(x, y) * -1;
      });
    };
    observableProto.min = function(comparer) {
      return this.minBy(identity, comparer).map(function(x) {
        return firstOnly(x);
      });
    };
    observableProto.maxBy = function(keySelector, comparer) {
      comparer || (comparer = defaultSubComparer);
      return extremaBy(this, keySelector, comparer);
    };
    observableProto.max = function(comparer) {
      return this.maxBy(identity, comparer).map(function(x) {
        return firstOnly(x);
      });
    };
    var AverageObserver = (function(__super__) {
      inherits(AverageObserver, __super__);
      function AverageObserver(o, fn, s) {
        this._o = o;
        this._fn = fn;
        this._s = s;
        this._c = 0;
        this._t = 0;
        __super__.call(this);
      }
      AverageObserver.prototype.next = function(x) {
        if (this._fn) {
          var r = tryCatch(this._fn)(x, this._c++, this._s);
          if (r === errorObj) {
            return this._o.onError(r.e);
          }
          this._t += r;
        } else {
          this._c++;
          this._t += x;
        }
      };
      AverageObserver.prototype.error = function(e) {
        this._o.onError(e);
      };
      AverageObserver.prototype.completed = function() {
        if (this._c === 0) {
          return this._o.onError(new EmptyError());
        }
        this._o.onNext(this._t / this._c);
        this._o.onCompleted();
      };
      return AverageObserver;
    }(AbstractObserver));
    observableProto.average = function(keySelector, thisArg) {
      var source = this,
          fn;
      if (isFunction(keySelector)) {
        fn = bindCallback(keySelector, thisArg, 3);
      }
      return new AnonymousObservable(function(o) {
        return source.subscribe(new AverageObserver(o, fn, source));
      }, source);
    };
    observableProto.sequenceEqual = function(second, comparer) {
      var first = this;
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(o) {
        var donel = false,
            doner = false,
            ql = [],
            qr = [];
        var subscription1 = first.subscribe(function(x) {
          var equal,
              v;
          if (qr.length > 0) {
            v = qr.shift();
            try {
              equal = comparer(v, x);
            } catch (e) {
              o.onError(e);
              return;
            }
            if (!equal) {
              o.onNext(false);
              o.onCompleted();
            }
          } else if (doner) {
            o.onNext(false);
            o.onCompleted();
          } else {
            ql.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          donel = true;
          if (ql.length === 0) {
            if (qr.length > 0) {
              o.onNext(false);
              o.onCompleted();
            } else if (doner) {
              o.onNext(true);
              o.onCompleted();
            }
          }
        });
        (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));
        isPromise(second) && (second = observableFromPromise(second));
        var subscription2 = second.subscribe(function(x) {
          var equal;
          if (ql.length > 0) {
            var v = ql.shift();
            try {
              equal = comparer(v, x);
            } catch (exception) {
              o.onError(exception);
              return;
            }
            if (!equal) {
              o.onNext(false);
              o.onCompleted();
            }
          } else if (donel) {
            o.onNext(false);
            o.onCompleted();
          } else {
            qr.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          doner = true;
          if (qr.length === 0) {
            if (ql.length > 0) {
              o.onNext(false);
              o.onCompleted();
            } else if (donel) {
              o.onNext(true);
              o.onCompleted();
            }
          }
        });
        return new CompositeDisposable(subscription1, subscription2);
      }, first);
    };
    observableProto.elementAt = function(index, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var i = index;
        return source.subscribe(function(x) {
          if (i-- === 0) {
            o.onNext(x);
            o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          if (defaultValue === undefined) {
            o.onError(new ArgumentOutOfRangeError());
          } else {
            o.onNext(defaultValue);
            o.onCompleted();
          }
        });
      }, source);
    };
    observableProto.single = function(predicate, thisArg) {
      if (isFunction(predicate)) {
        return this.filter(predicate, thisArg).single();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var value,
            seenValue = false;
        return source.subscribe(function(x) {
          if (seenValue) {
            o.onError(new Error('Sequence contains more than one element'));
          } else {
            value = x;
            seenValue = true;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(value);
          o.onCompleted();
        });
      }, source);
    };
    var FirstObserver = (function(__super__) {
      inherits(FirstObserver, __super__);
      function FirstObserver(o, obj, s) {
        this._o = o;
        this._obj = obj;
        this._s = s;
        this._i = 0;
        __super__.call(this);
      }
      FirstObserver.prototype.next = function(x) {
        if (this._obj.predicate) {
          var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
          if (res === errorObj) {
            return this._o.onError(res.e);
          }
          if (Boolean(res)) {
            this._o.onNext(x);
            this._o.onCompleted();
          }
        } else if (!this._obj.predicate) {
          this._o.onNext(x);
          this._o.onCompleted();
        }
      };
      FirstObserver.prototype.error = function(e) {
        this._o.onError(e);
      };
      FirstObserver.prototype.completed = function() {
        if (this._obj.defaultValue === undefined) {
          this._o.onError(new EmptyError());
        } else {
          this._o.onNext(this._obj.defaultValue);
          this._o.onCompleted();
        }
      };
      return FirstObserver;
    }(AbstractObserver));
    observableProto.first = function() {
      var obj = {},
          source = this;
      if (typeof arguments[0] === 'object') {
        obj = arguments[0];
      } else {
        obj = {
          predicate: arguments[0],
          thisArg: arguments[1],
          defaultValue: arguments[2]
        };
      }
      if (isFunction(obj.predicate)) {
        var fn = obj.predicate;
        obj.predicate = bindCallback(fn, obj.thisArg, 3);
      }
      return new AnonymousObservable(function(o) {
        return source.subscribe(new FirstObserver(o, obj, source));
      }, source);
    };
    observableProto.last = function() {
      var obj = {},
          source = this;
      if (typeof arguments[0] === 'object') {
        obj = arguments[0];
      } else {
        obj = {
          predicate: arguments[0],
          thisArg: arguments[1],
          defaultValue: arguments[2]
        };
      }
      if (isFunction(obj.predicate)) {
        var fn = obj.predicate;
        obj.predicate = bindCallback(fn, obj.thisArg, 3);
      }
      return new AnonymousObservable(function(o) {
        var value,
            seenValue = false,
            i = 0;
        return source.subscribe(function(x) {
          if (obj.predicate) {
            var res = tryCatch(obj.predicate)(x, i++, source);
            if (res === errorObj) {
              return o.onError(res.e);
            }
            if (res) {
              seenValue = true;
              value = x;
            }
          } else if (!obj.predicate) {
            seenValue = true;
            value = x;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          if (seenValue) {
            o.onNext(value);
            o.onCompleted();
          } else if (obj.defaultValue === undefined) {
            o.onError(new EmptyError());
          } else {
            o.onNext(obj.defaultValue);
            o.onCompleted();
          }
        });
      }, source);
    };
    function findValue(source, predicate, thisArg, yieldIndex) {
      var callback = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        var i = 0;
        return source.subscribe(function(x) {
          var shouldRun;
          try {
            shouldRun = callback(x, i, source);
          } catch (e) {
            o.onError(e);
            return;
          }
          if (shouldRun) {
            o.onNext(yieldIndex ? i : x);
            o.onCompleted();
          } else {
            i++;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(yieldIndex ? -1 : undefined);
          o.onCompleted();
        });
      }, source);
    }
    observableProto.find = function(predicate, thisArg) {
      return findValue(this, predicate, thisArg, false);
    };
    observableProto.findIndex = function(predicate, thisArg) {
      return findValue(this, predicate, thisArg, true);
    };
    observableProto.toSet = function() {
      if (typeof root.Set === 'undefined') {
        throw new TypeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var s = new root.Set();
        return source.subscribe(function(x) {
          s.add(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(s);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.toMap = function(keySelector, elementSelector) {
      if (typeof root.Map === 'undefined') {
        throw new TypeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var m = new root.Map();
        return source.subscribe(function(x) {
          var key;
          try {
            key = keySelector(x);
          } catch (e) {
            o.onError(e);
            return;
          }
          var element = x;
          if (elementSelector) {
            try {
              element = elementSelector(x);
            } catch (e) {
              o.onError(e);
              return;
            }
          }
          m.set(key, element);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(m);
          o.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.backpressure.js", ["npm:rx@3.0.1/dist/rx.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(['rx'], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        AbstractObserver = Rx.internals.AbstractObserver,
        CompositeDisposable = Rx.CompositeDisposable,
        Notification = Rx.Notification,
        Subject = Rx.Subject,
        Observer = Rx.Observer,
        disposableEmpty = Rx.Disposable.empty,
        disposableCreate = Rx.Disposable.create,
        inherits = Rx.internals.inherits,
        addProperties = Rx.internals.addProperties,
        timeoutScheduler = Rx.Scheduler.timeout,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        identity = Rx.helpers.identity,
        isScheduler = Rx.Scheduler.isScheduler,
        isFunction = Rx.helpers.isFunction,
        checkDisposed = Rx.Disposable.checkDisposed;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    Rx.Pauser = (function(__super__) {
      inherits(Pauser, __super__);
      function Pauser() {
        __super__.call(this);
      }
      Pauser.prototype.pause = function() {
        this.onNext(false);
      };
      Pauser.prototype.resume = function() {
        this.onNext(true);
      };
      return Pauser;
    }(Subject));
    var PausableObservable = (function(__super__) {
      inherits(PausableObservable, __super__);
      function subscribe(observer) {
        var conn = this.source.publish(),
            subscription = conn.subscribe(observer),
            connection = disposableEmpty;
        var pausable = this.pauser.distinctUntilChanged().subscribe(function(b) {
          if (b) {
            connection = conn.connect();
          } else {
            connection.dispose();
            connection = disposableEmpty;
          }
        });
        return new CompositeDisposable(subscription, connection, pausable);
      }
      function PausableObservable(source, pauser) {
        this.source = source;
        this.controller = new Subject();
        if (pauser && pauser.subscribe) {
          this.pauser = this.controller.merge(pauser);
        } else {
          this.pauser = this.controller;
        }
        __super__.call(this, subscribe, source);
      }
      PausableObservable.prototype.pause = function() {
        this.controller.onNext(false);
      };
      PausableObservable.prototype.resume = function() {
        this.controller.onNext(true);
      };
      return PausableObservable;
    }(Observable));
    observableProto.pausable = function(pauser) {
      return new PausableObservable(this, pauser);
    };
    function combineLatestSource(source, subject, resultSelector) {
      return new AnonymousObservable(function(o) {
        var hasValue = [false, false],
            hasValueAll = false,
            isDone = false,
            values = new Array(2),
            err;
        function next(x, i) {
          values[i] = x;
          hasValue[i] = true;
          if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
            if (err) {
              return o.onError(err);
            }
            var res = tryCatch(resultSelector).apply(null, values);
            if (res === errorObj) {
              return o.onError(res.e);
            }
            o.onNext(res);
          }
          isDone && values[1] && o.onCompleted();
        }
        return new CompositeDisposable(source.subscribe(function(x) {
          next(x, 0);
        }, function(e) {
          if (values[1]) {
            o.onError(e);
          } else {
            err = e;
          }
        }, function() {
          isDone = true;
          values[1] && o.onCompleted();
        }), subject.subscribe(function(x) {
          next(x, 1);
        }, function(e) {
          o.onError(e);
        }, function() {
          isDone = true;
          next(true, 1);
        }));
      }, source);
    }
    var PausableBufferedObservable = (function(__super__) {
      inherits(PausableBufferedObservable, __super__);
      function subscribe(o) {
        var q = [],
            previousShouldFire;
        function drainQueue() {
          while (q.length > 0) {
            o.onNext(q.shift());
          }
        }
        var subscription = combineLatestSource(this.source, this.pauser.startWith(false).distinctUntilChanged(), function(data, shouldFire) {
          return {
            data: data,
            shouldFire: shouldFire
          };
        }).subscribe(function(results) {
          if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) {
            previousShouldFire = results.shouldFire;
            if (results.shouldFire) {
              drainQueue();
            }
          } else {
            previousShouldFire = results.shouldFire;
            if (results.shouldFire) {
              o.onNext(results.data);
            } else {
              q.push(results.data);
            }
          }
        }, function(err) {
          drainQueue();
          o.onError(err);
        }, function() {
          drainQueue();
          o.onCompleted();
        });
        return subscription;
      }
      function PausableBufferedObservable(source, pauser) {
        this.source = source;
        this.controller = new Subject();
        if (pauser && pauser.subscribe) {
          this.pauser = this.controller.merge(pauser);
        } else {
          this.pauser = this.controller;
        }
        __super__.call(this, subscribe, source);
      }
      PausableBufferedObservable.prototype.pause = function() {
        this.controller.onNext(false);
      };
      PausableBufferedObservable.prototype.resume = function() {
        this.controller.onNext(true);
      };
      return PausableBufferedObservable;
    }(Observable));
    observableProto.pausableBuffered = function(subject) {
      return new PausableBufferedObservable(this, subject);
    };
    var ControlledObservable = (function(__super__) {
      inherits(ControlledObservable, __super__);
      function subscribe(observer) {
        return this.source.subscribe(observer);
      }
      function ControlledObservable(source, enableQueue, scheduler) {
        __super__.call(this, subscribe, source);
        this.subject = new ControlledSubject(enableQueue, scheduler);
        this.source = source.multicast(this.subject).refCount();
      }
      ControlledObservable.prototype.request = function(numberOfItems) {
        return this.subject.request(numberOfItems == null ? -1 : numberOfItems);
      };
      return ControlledObservable;
    }(Observable));
    var ControlledSubject = (function(__super__) {
      function subscribe(observer) {
        return this.subject.subscribe(observer);
      }
      inherits(ControlledSubject, __super__);
      function ControlledSubject(enableQueue, scheduler) {
        enableQueue == null && (enableQueue = true);
        __super__.call(this, subscribe);
        this.subject = new Subject();
        this.enableQueue = enableQueue;
        this.queue = enableQueue ? [] : null;
        this.requestedCount = 0;
        this.requestedDisposable = null;
        this.error = null;
        this.hasFailed = false;
        this.hasCompleted = false;
        this.scheduler = scheduler || currentThreadScheduler;
      }
      addProperties(ControlledSubject.prototype, Observer, {
        onCompleted: function() {
          this.hasCompleted = true;
          if (!this.enableQueue || this.queue.length === 0) {
            this.subject.onCompleted();
            this.disposeCurrentRequest();
          } else {
            this.queue.push(Notification.createOnCompleted());
          }
        },
        onError: function(error) {
          this.hasFailed = true;
          this.error = error;
          if (!this.enableQueue || this.queue.length === 0) {
            this.subject.onError(error);
            this.disposeCurrentRequest();
          } else {
            this.queue.push(Notification.createOnError(error));
          }
        },
        onNext: function(value) {
          if (this.requestedCount <= 0) {
            this.enableQueue && this.queue.push(Notification.createOnNext(value));
          } else {
            (this.requestedCount-- === 0) && this.disposeCurrentRequest();
            this.subject.onNext(value);
          }
        },
        _processRequest: function(numberOfItems) {
          if (this.enableQueue) {
            while (this.queue.length > 0 && (numberOfItems > 0 || this.queue[0].kind !== 'N')) {
              var first = this.queue.shift();
              first.accept(this.subject);
              if (first.kind === 'N') {
                numberOfItems--;
              } else {
                this.disposeCurrentRequest();
                this.queue = [];
              }
            }
          }
          return numberOfItems;
        },
        request: function(number) {
          this.disposeCurrentRequest();
          var self = this;
          this.requestedDisposable = this.scheduler.scheduleWithState(number, function(s, i) {
            var remaining = self._processRequest(i);
            var stopped = self.hasCompleted || self.hasFailed;
            if (!stopped && remaining > 0) {
              self.requestedCount = remaining;
              return disposableCreate(function() {
                self.requestedCount = 0;
              });
            }
          });
          return this.requestedDisposable;
        },
        disposeCurrentRequest: function() {
          if (this.requestedDisposable) {
            this.requestedDisposable.dispose();
            this.requestedDisposable = null;
          }
        }
      });
      return ControlledSubject;
    }(Observable));
    observableProto.controlled = function(enableQueue, scheduler) {
      if (enableQueue && isScheduler(enableQueue)) {
        scheduler = enableQueue;
        enableQueue = true;
      }
      if (enableQueue == null) {
        enableQueue = true;
      }
      return new ControlledObservable(this, enableQueue, scheduler);
    };
    var StopAndWaitObservable = (function(__super__) {
      function subscribe(observer) {
        this.subscription = this.source.subscribe(new StopAndWaitObserver(observer, this, this.subscription));
        var self = this;
        timeoutScheduler.schedule(function() {
          self.source.request(1);
        });
        return this.subscription;
      }
      inherits(StopAndWaitObservable, __super__);
      function StopAndWaitObservable(source) {
        __super__.call(this, subscribe, source);
        this.source = source;
      }
      var StopAndWaitObserver = (function(__sub__) {
        inherits(StopAndWaitObserver, __sub__);
        function StopAndWaitObserver(observer, observable, cancel) {
          __sub__.call(this);
          this.observer = observer;
          this.observable = observable;
          this.cancel = cancel;
        }
        var stopAndWaitObserverProto = StopAndWaitObserver.prototype;
        stopAndWaitObserverProto.completed = function() {
          this.observer.onCompleted();
          this.dispose();
        };
        stopAndWaitObserverProto.error = function(error) {
          this.observer.onError(error);
          this.dispose();
        };
        stopAndWaitObserverProto.next = function(value) {
          this.observer.onNext(value);
          var self = this;
          timeoutScheduler.schedule(function() {
            self.observable.source.request(1);
          });
        };
        stopAndWaitObserverProto.dispose = function() {
          this.observer = null;
          if (this.cancel) {
            this.cancel.dispose();
            this.cancel = null;
          }
          __sub__.prototype.dispose.call(this);
        };
        return StopAndWaitObserver;
      }(AbstractObserver));
      return StopAndWaitObservable;
    }(Observable));
    ControlledObservable.prototype.stopAndWait = function() {
      return new StopAndWaitObservable(this);
    };
    var WindowedObservable = (function(__super__) {
      function subscribe(observer) {
        this.subscription = this.source.subscribe(new WindowedObserver(observer, this, this.subscription));
        var self = this;
        timeoutScheduler.schedule(function() {
          self.source.request(self.windowSize);
        });
        return this.subscription;
      }
      inherits(WindowedObservable, __super__);
      function WindowedObservable(source, windowSize) {
        __super__.call(this, subscribe, source);
        this.source = source;
        this.windowSize = windowSize;
      }
      var WindowedObserver = (function(__sub__) {
        inherits(WindowedObserver, __sub__);
        function WindowedObserver(observer, observable, cancel) {
          this.observer = observer;
          this.observable = observable;
          this.cancel = cancel;
          this.received = 0;
        }
        var windowedObserverPrototype = WindowedObserver.prototype;
        windowedObserverPrototype.completed = function() {
          this.observer.onCompleted();
          this.dispose();
        };
        windowedObserverPrototype.error = function(error) {
          this.observer.onError(error);
          this.dispose();
        };
        windowedObserverPrototype.next = function(value) {
          this.observer.onNext(value);
          this.received = ++this.received % this.observable.windowSize;
          if (this.received === 0) {
            var self = this;
            timeoutScheduler.schedule(function() {
              self.observable.source.request(self.observable.windowSize);
            });
          }
        };
        windowedObserverPrototype.dispose = function() {
          this.observer = null;
          if (this.cancel) {
            this.cancel.dispose();
            this.cancel = null;
          }
          __sub__.prototype.dispose.call(this);
        };
        return WindowedObserver;
      }(AbstractObserver));
      return WindowedObservable;
    }(Observable));
    ControlledObservable.prototype.windowed = function(windowSize) {
      return new WindowedObservable(this, windowSize);
    };
    observableProto.pipe = function(dest) {
      var source = this.pausableBuffered();
      function onDrain() {
        source.resume();
      }
      dest.addListener('drain', onDrain);
      source.subscribe(function(x) {
        !dest.write(String(x)) && source.pause();
      }, function(err) {
        dest.emit('error', err);
      }, function() {
        !dest._isStdio && dest.end();
        dest.removeListener('drain', onDrain);
      });
      source.resume();
      return dest;
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.async.js", ["npm:rx@3.0.1/dist/rx.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(factory) {
      var objectTypes = {
        'function': true,
        'object': true
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
          freeSelf = objectTypes[typeof self] && self.Object && self,
          freeWindow = objectTypes[typeof window] && window && window.Object && window,
          freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
          moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
          freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
      var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
      if (typeof define === 'function' && define.amd) {
        define(['rx.binding', 'exports'], function(Rx, exports) {
          root.Rx = factory(root, exports, Rx);
          return root.Rx;
        });
      } else if (typeof module === 'object' && module && module.exports === freeExports) {
        module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
      } else {
        root.Rx = factory(root, {}, root.Rx);
      }
    }.call(this, function(root, exp, Rx, undefined) {
      var Observable = Rx.Observable,
          observableProto = Observable.prototype,
          observableFromPromise = Observable.fromPromise,
          observableThrow = Observable.throwError,
          AnonymousObservable = Rx.AnonymousObservable,
          AsyncSubject = Rx.AsyncSubject,
          disposableCreate = Rx.Disposable.create,
          CompositeDisposable = Rx.CompositeDisposable,
          immediateScheduler = Rx.Scheduler.immediate,
          timeoutScheduler = Rx.Scheduler['default'],
          isScheduler = Rx.Scheduler.isScheduler,
          isPromise = Rx.helpers.isPromise,
          isFunction = Rx.helpers.isFunction;
      var errorObj = {e: {}};
      var tryCatchTarget;
      function tryCatcher() {
        try {
          return tryCatchTarget.apply(this, arguments);
        } catch (e) {
          errorObj.e = e;
          return errorObj;
        }
      }
      function tryCatch(fn) {
        if (!isFunction(fn)) {
          throw new TypeError('fn must be a function');
        }
        tryCatchTarget = fn;
        return tryCatcher;
      }
      function thrower(e) {
        throw e;
      }
      var wrap = Observable.wrap = function(fn) {
        createObservable.__generatorFunction__ = fn;
        return createObservable;
        function createObservable() {
          return Observable.spawn.call(this, fn.apply(this, arguments));
        }
      };
      var spawn = Observable.spawn = function() {
        var gen = arguments[0],
            self = this,
            args = [];
        for (var i = 1,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        return new AnonymousObservable(function(o) {
          var g = new CompositeDisposable();
          if (isFunction(gen)) {
            gen = gen.apply(self, args);
          }
          if (!gen || !isFunction(gen.next)) {
            o.onNext(gen);
            return o.onCompleted();
          }
          processGenerator();
          function processGenerator(res) {
            var ret = tryCatch(gen.next).call(gen, res);
            if (ret === errorObj) {
              return o.onError(ret.e);
            }
            next(ret);
          }
          function onError(err) {
            var ret = tryCatch(gen.next).call(gen, err);
            if (ret === errorObj) {
              return o.onError(ret.e);
            }
            next(ret);
          }
          function next(ret) {
            if (ret.done) {
              o.onNext(ret.value);
              o.onCompleted();
              return;
            }
            var value = toObservable.call(self, ret.value);
            if (Observable.isObservable(value)) {
              g.add(value.subscribe(processGenerator, onError));
            } else {
              onError(new TypeError('type not supported'));
            }
          }
          return g;
        });
      };
      function toObservable(obj) {
        if (!obj) {
          return obj;
        }
        if (Observable.isObservable(obj)) {
          return obj;
        }
        if (isPromise(obj)) {
          return Observable.fromPromise(obj);
        }
        if (isGeneratorFunction(obj) || isGenerator(obj)) {
          return spawn.call(this, obj);
        }
        if (isFunction(obj)) {
          return thunkToObservable.call(this, obj);
        }
        if (isArrayLike(obj) || isIterable(obj)) {
          return arrayToObservable.call(this, obj);
        }
        if (isObject(obj)) {
          return objectToObservable.call(this, obj);
        }
        return obj;
      }
      function arrayToObservable(obj) {
        return Observable.from(obj).flatMap(toObservable).toArray();
      }
      function objectToObservable(obj) {
        var results = new obj.constructor(),
            keys = Object.keys(obj),
            observables = [];
        for (var i = 0,
            len = keys.length; i < len; i++) {
          var key = keys[i];
          var observable = toObservable.call(this, obj[key]);
          if (observable && Observable.isObservable(observable)) {
            defer(observable, key);
          } else {
            results[key] = obj[key];
          }
        }
        return Observable.forkJoin.apply(Observable, observables).map(function() {
          return results;
        });
        function defer(observable, key) {
          results[key] = undefined;
          observables.push(observable.map(function(next) {
            results[key] = next;
          }));
        }
      }
      function thunkToObservable(fn) {
        var self = this;
        return new AnonymousObservable(function(o) {
          fn.call(self, function() {
            var err = arguments[0],
                res = arguments[1];
            if (err) {
              return o.onError(err);
            }
            if (arguments.length > 2) {
              var args = [];
              for (var i = 1,
                  len = arguments.length; i < len; i++) {
                args.push(arguments[i]);
              }
              res = args;
            }
            o.onNext(res);
            o.onCompleted();
          });
        });
      }
      function isGenerator(obj) {
        return isFunction(obj.next) && isFunction(obj.throw);
      }
      function isGeneratorFunction(obj) {
        var ctor = obj.constructor;
        if (!ctor) {
          return false;
        }
        if (ctor.name === 'GeneratorFunction' || ctor.displayName === 'GeneratorFunction') {
          return true;
        }
        return isGenerator(ctor.prototype);
      }
      Observable.start = function(func, context, scheduler) {
        return observableToAsync(func, context, scheduler)();
      };
      var observableToAsync = Observable.toAsync = function(func, context, scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return function() {
          var args = arguments,
              subject = new AsyncSubject();
          scheduler.schedule(function() {
            var result;
            try {
              result = func.apply(context, args);
            } catch (e) {
              subject.onError(e);
              return;
            }
            subject.onNext(result);
            subject.onCompleted();
          });
          return subject.asObservable();
        };
      };
      function createCbObservable(fn, ctx, selector, args) {
        var o = new AsyncSubject();
        args.push(createCbHandler(o, ctx, selector));
        fn.apply(ctx, args);
        return o.asObservable();
      }
      function createCbHandler(o, ctx, selector) {
        return function handler() {
          var len = arguments.length,
              results = new Array(len);
          for (var i = 0; i < len; i++) {
            results[i] = arguments[i];
          }
          if (isFunction(selector)) {
            results = tryCatch(selector).apply(ctx, results);
            if (results === errorObj) {
              return o.onError(results.e);
            }
            o.onNext(results);
          } else {
            if (results.length <= 1) {
              o.onNext(results[0]);
            } else {
              o.onNext(results);
            }
          }
          o.onCompleted();
        };
      }
      Observable.fromCallback = function(fn, ctx, selector) {
        return function() {
          typeof ctx === 'undefined' && (ctx = this);
          var len = arguments.length,
              args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
          return createCbObservable(fn, ctx, selector, args);
        };
      };
      function createNodeObservable(fn, ctx, selector, args) {
        var o = new AsyncSubject();
        args.push(createNodeHandler(o, ctx, selector));
        fn.apply(ctx, args);
        return o.asObservable();
      }
      function createNodeHandler(o, ctx, selector) {
        return function handler() {
          var err = arguments[0];
          if (err) {
            return o.onError(err);
          }
          var len = arguments.length,
              results = [];
          for (var i = 1; i < len; i++) {
            results[i - 1] = arguments[i];
          }
          if (isFunction(selector)) {
            var results = tryCatch(selector).apply(ctx, results);
            if (results === errorObj) {
              return o.onError(results.e);
            }
            o.onNext(results);
          } else {
            if (results.length <= 1) {
              o.onNext(results[0]);
            } else {
              o.onNext(results);
            }
          }
          o.onCompleted();
        };
      }
      Observable.fromNodeCallback = function(fn, ctx, selector) {
        return function() {
          typeof ctx === 'undefined' && (ctx = this);
          var len = arguments.length,
              args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
          return createNodeObservable(fn, ctx, selector, args);
        };
      };
      function ListenDisposable(e, n, fn) {
        this._e = e;
        this._n = n;
        this._fn = fn;
        this._e.addEventListener(this._n, this._fn, false);
        this.isDisposed = false;
      }
      ListenDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this._e.removeEventListener(this._n, this._fn, false);
          this.isDisposed = true;
        }
      };
      function createEventListener(el, eventName, handler) {
        var disposables = new CompositeDisposable();
        var elemToString = Object.prototype.toString.call(el);
        if (elemToString === '[object NodeList]' || elemToString === '[object HTMLCollection]') {
          for (var i = 0,
              len = el.length; i < len; i++) {
            disposables.add(createEventListener(el.item(i), eventName, handler));
          }
        } else if (el) {
          disposables.add(new ListenDisposable(el, eventName, handler));
        }
        return disposables;
      }
      Rx.config.useNativeEvents = false;
      function eventHandler(o, selector) {
        return function handler() {
          var results = arguments[0];
          if (isFunction(selector)) {
            results = tryCatch(selector).apply(null, arguments);
            if (results === errorObj) {
              return o.onError(results.e);
            }
          }
          o.onNext(results);
        };
      }
      Observable.fromEvent = function(element, eventName, selector) {
        if (element.addListener) {
          return fromEventPattern(function(h) {
            element.addListener(eventName, h);
          }, function(h) {
            element.removeListener(eventName, h);
          }, selector);
        }
        if (!Rx.config.useNativeEvents) {
          if (typeof element.on === 'function' && typeof element.off === 'function') {
            return fromEventPattern(function(h) {
              element.on(eventName, h);
            }, function(h) {
              element.off(eventName, h);
            }, selector);
          }
        }
        return new AnonymousObservable(function(o) {
          return createEventListener(element, eventName, eventHandler(o, selector));
        }).publish().refCount();
      };
      var fromEventPattern = Observable.fromEventPattern = function(addHandler, removeHandler, selector, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new AnonymousObservable(function(o) {
          function innerHandler() {
            var result = arguments[0];
            if (isFunction(selector)) {
              result = tryCatch(selector).apply(null, arguments);
              if (result === errorObj) {
                return o.onError(result.e);
              }
            }
            o.onNext(result);
          }
          var returnValue = addHandler(innerHandler);
          return disposableCreate(function() {
            isFunction(removeHandler) && removeHandler(innerHandler, returnValue);
          });
        }).publish().refCount();
      };
      Observable.startAsync = function(functionAsync) {
        var promise;
        try {
          promise = functionAsync();
        } catch (e) {
          return observableThrow(e);
        }
        return observableFromPromise(promise);
      };
      return Rx;
    }));
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.coincidence.js", ["npm:rx@3.0.1/dist/rx.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(['rx'], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        CompositeDisposable = Rx.CompositeDisposable,
        RefCountDisposable = Rx.RefCountDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        SerialDisposable = Rx.SerialDisposable,
        Subject = Rx.Subject,
        observableProto = Observable.prototype,
        observableEmpty = Observable.empty,
        observableNever = Observable.never,
        AnonymousObservable = Rx.AnonymousObservable,
        observerCreate = Rx.Observer.create,
        addRef = Rx.internals.addRef,
        defaultComparer = Rx.internals.isEqual,
        inherits = Rx.internals.inherits,
        noop = Rx.helpers.noop,
        identity = Rx.helpers.identity,
        isPromise = Rx.helpers.isPromise,
        isFunction = Rx.helpers.isFunction,
        bindCallback = Rx.internals.bindCallback,
        observableFromPromise = Observable.fromPromise,
        ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    var Map = root.Map || (function() {
      function Map() {
        this.size = 0;
        this._values = [];
        this._keys = [];
      }
      Map.prototype['delete'] = function(key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
          return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
      };
      Map.prototype.get = function(key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
      };
      Map.prototype.set = function(key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
          this._keys.push(key);
          this._values.push(value);
          this.size++;
        } else {
          this._values[i] = value;
        }
        return this;
      };
      Map.prototype.forEach = function(cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
          cb.call(thisArg, this._values[i], this._keys[i]);
        }
      };
      return Map;
    }());
    observableProto.join = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {
      var left = this;
      return new AnonymousObservable(function(o) {
        var group = new CompositeDisposable();
        var leftDone = false,
            rightDone = false;
        var leftId = 0,
            rightId = 0;
        var leftMap = new Map(),
            rightMap = new Map();
        var handleError = function(e) {
          o.onError(e);
        };
        group.add(left.subscribe(function(value) {
          var id = leftId++,
              md = new SingleAssignmentDisposable();
          leftMap.set(id, value);
          group.add(md);
          var duration = tryCatch(leftDurationSelector)(value);
          if (duration === errorObj) {
            return o.onError(duration.e);
          }
          md.setDisposable(duration.take(1).subscribe(noop, handleError, function() {
            leftMap['delete'](id) && leftMap.size === 0 && leftDone && o.onCompleted();
            group.remove(md);
          }));
          rightMap.forEach(function(v) {
            var result = tryCatch(resultSelector)(value, v);
            if (result === errorObj) {
              return o.onError(result.e);
            }
            o.onNext(result);
          });
        }, handleError, function() {
          leftDone = true;
          (rightDone || leftMap.size === 0) && o.onCompleted();
        }));
        group.add(right.subscribe(function(value) {
          var id = rightId++,
              md = new SingleAssignmentDisposable();
          rightMap.set(id, value);
          group.add(md);
          var duration = tryCatch(rightDurationSelector)(value);
          if (duration === errorObj) {
            return o.onError(duration.e);
          }
          md.setDisposable(duration.take(1).subscribe(noop, handleError, function() {
            rightMap['delete'](id) && rightMap.size === 0 && rightDone && o.onCompleted();
            group.remove(md);
          }));
          leftMap.forEach(function(v) {
            var result = tryCatch(resultSelector)(v, value);
            if (result === errorObj) {
              return o.onError(result.e);
            }
            o.onNext(result);
          });
        }, handleError, function() {
          rightDone = true;
          (leftDone || rightMap.size === 0) && o.onCompleted();
        }));
        return group;
      }, left);
    };
    observableProto.groupJoin = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {
      var left = this;
      return new AnonymousObservable(function(o) {
        var group = new CompositeDisposable();
        var r = new RefCountDisposable(group);
        var leftMap = new Map(),
            rightMap = new Map();
        var leftId = 0,
            rightId = 0;
        var handleError = function(e) {
          return function(v) {
            v.onError(e);
          };
        };
        function handleError(e) {}
        ;
        group.add(left.subscribe(function(value) {
          var s = new Subject();
          var id = leftId++;
          leftMap.set(id, s);
          var result = tryCatch(resultSelector)(value, addRef(s, r));
          if (result === errorObj) {
            leftMap.forEach(handleError(result.e));
            return o.onError(result.e);
          }
          o.onNext(result);
          rightMap.forEach(function(v) {
            s.onNext(v);
          });
          var md = new SingleAssignmentDisposable();
          group.add(md);
          var duration = tryCatch(leftDurationSelector)(value);
          if (duration === errorObj) {
            leftMap.forEach(handleError(duration.e));
            return o.onError(duration.e);
          }
          md.setDisposable(duration.take(1).subscribe(noop, function(e) {
            leftMap.forEach(handleError(e));
            o.onError(e);
          }, function() {
            leftMap['delete'](id) && s.onCompleted();
            group.remove(md);
          }));
        }, function(e) {
          leftMap.forEach(handleError(e));
          o.onError(e);
        }, function() {
          o.onCompleted();
        }));
        group.add(right.subscribe(function(value) {
          var id = rightId++;
          rightMap.set(id, value);
          var md = new SingleAssignmentDisposable();
          group.add(md);
          var duration = tryCatch(rightDurationSelector)(value);
          if (duration === errorObj) {
            leftMap.forEach(handleError(duration.e));
            return o.onError(duration.e);
          }
          md.setDisposable(duration.take(1).subscribe(noop, function(e) {
            leftMap.forEach(handleError(e));
            o.onError(e);
          }, function() {
            rightMap['delete'](id);
            group.remove(md);
          }));
          leftMap.forEach(function(v) {
            v.onNext(value);
          });
        }, function(e) {
          leftMap.forEach(handleError(e));
          o.onError(e);
        }));
        return r;
      }, left);
    };
    function toArray(x) {
      return x.toArray();
    }
    observableProto.buffer = function() {
      return this.window.apply(this, arguments).flatMap(toArray);
    };
    observableProto.window = function(windowOpeningsOrClosingSelector, windowClosingSelector) {
      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
        return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);
      }
      return typeof windowOpeningsOrClosingSelector === 'function' ? observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) : observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
    };
    function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
      return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function(_, win) {
        return win;
      });
    }
    function observableWindowWithBoundaries(windowBoundaries) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var win = new Subject(),
            d = new CompositeDisposable(),
            r = new RefCountDisposable(d);
        observer.onNext(addRef(win, r));
        d.add(source.subscribe(function(x) {
          win.onNext(x);
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));
        d.add(windowBoundaries.subscribe(function(w) {
          win.onCompleted();
          win = new Subject();
          observer.onNext(addRef(win, r));
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        return r;
      }, source);
    }
    function observableWindowWithClosingSelector(windowClosingSelector) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var m = new SerialDisposable(),
            d = new CompositeDisposable(m),
            r = new RefCountDisposable(d),
            win = new Subject();
        observer.onNext(addRef(win, r));
        d.add(source.subscribe(function(x) {
          win.onNext(x);
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        function createWindowClose() {
          var windowClose;
          try {
            windowClose = windowClosingSelector();
          } catch (e) {
            observer.onError(e);
            return;
          }
          isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));
          var m1 = new SingleAssignmentDisposable();
          m.setDisposable(m1);
          m1.setDisposable(windowClose.take(1).subscribe(noop, function(err) {
            win.onError(err);
            observer.onError(err);
          }, function() {
            win.onCompleted();
            win = new Subject();
            observer.onNext(addRef(win, r));
            createWindowClose();
          }));
        }
        createWindowClose();
        return r;
      }, source);
    }
    observableProto.pairwise = function() {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var previous,
            hasPrevious = false;
        return source.subscribe(function(x) {
          if (hasPrevious) {
            observer.onNext([previous, x]);
          } else {
            hasPrevious = true;
          }
          previous = x;
        }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
      }, source);
    };
    observableProto.partition = function(predicate, thisArg) {
      return [this.filter(predicate, thisArg), this.filter(function(x, i, o) {
        return !predicate.call(thisArg, x, i, o);
      })];
    };
    observableProto.groupBy = function(keySelector, elementSelector) {
      return this.groupByUntil(keySelector, elementSelector, observableNever);
    };
    observableProto.groupByUntil = function(keySelector, elementSelector, durationSelector) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var map = new Map(),
            groupDisposable = new CompositeDisposable(),
            refCountDisposable = new RefCountDisposable(groupDisposable),
            handleError = function(e) {
              return function(item) {
                item.onError(e);
              };
            };
        groupDisposable.add(source.subscribe(function(x) {
          var key = tryCatch(keySelector)(x);
          if (key === errorObj) {
            map.forEach(handleError(key.e));
            return o.onError(key.e);
          }
          var fireNewMapEntry = false,
              writer = map.get(key);
          if (writer === undefined) {
            writer = new Subject();
            map.set(key, writer);
            fireNewMapEntry = true;
          }
          if (fireNewMapEntry) {
            var group = new GroupedObservable(key, writer, refCountDisposable),
                durationGroup = new GroupedObservable(key, writer);
            var duration = tryCatch(durationSelector)(durationGroup);
            if (duration === errorObj) {
              map.forEach(handleError(duration.e));
              return o.onError(duration.e);
            }
            o.onNext(group);
            var md = new SingleAssignmentDisposable();
            groupDisposable.add(md);
            md.setDisposable(duration.take(1).subscribe(noop, function(e) {
              map.forEach(handleError(e));
              o.onError(e);
            }, function() {
              if (map['delete'](key)) {
                writer.onCompleted();
              }
              groupDisposable.remove(md);
            }));
          }
          var element = x;
          if (isFunction(elementSelector)) {
            element = tryCatch(elementSelector)(x);
            if (element === errorObj) {
              map.forEach(handleError(element.e));
              return o.onError(element.e);
            }
          }
          writer.onNext(element);
        }, function(e) {
          map.forEach(handleError(e));
          o.onError(e);
        }, function() {
          map.forEach(function(item) {
            item.onCompleted();
          });
          o.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    var GroupedObservable = (function(__super__) {
      inherits(GroupedObservable, __super__);
      function subscribe(observer) {
        return this.underlyingObservable.subscribe(observer);
      }
      function GroupedObservable(key, underlyingObservable, mergedDisposable) {
        __super__.call(this, subscribe);
        this.key = key;
        this.underlyingObservable = !mergedDisposable ? underlyingObservable : new AnonymousObservable(function(observer) {
          return new CompositeDisposable(mergedDisposable.getDisposable(), underlyingObservable.subscribe(observer));
        });
      }
      return GroupedObservable;
    }(Observable));
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.experimental.js", ["npm:rx@3.0.1/dist/rx.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(['rx'], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableConcat = Observable.concat,
        observableDefer = Observable.defer,
        observableEmpty = Observable.empty,
        disposableEmpty = Rx.Disposable.empty,
        CompositeDisposable = Rx.CompositeDisposable,
        SerialDisposable = Rx.SerialDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        Enumerator = Rx.internals.Enumerator,
        Enumerable = Rx.internals.Enumerable,
        enumerableOf = Enumerable.of,
        immediateScheduler = Rx.Scheduler.immediate,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        slice = Array.prototype.slice,
        AsyncSubject = Rx.AsyncSubject,
        Observer = Rx.Observer,
        inherits = Rx.internals.inherits,
        bindCallback = Rx.internals.bindCallback,
        addProperties = Rx.internals.addProperties,
        helpers = Rx.helpers,
        noop = helpers.noop,
        isPromise = helpers.isPromise,
        isFunction = helpers.isFunction,
        isScheduler = Rx.Scheduler.isScheduler,
        observableFromPromise = Observable.fromPromise;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
    if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
      $iterator$ = '@@iterator';
    }
    var doneEnumerator = Rx.doneEnumerator = {
      done: true,
      value: undefined
    };
    var isIterable = Rx.helpers.isIterable = function(o) {
      return o[$iterator$] !== undefined;
    };
    var isArrayLike = Rx.helpers.isArrayLike = function(o) {
      return o && o.length !== undefined;
    };
    Rx.helpers.iterator = $iterator$;
    var WhileEnumerable = (function(__super__) {
      inherits(WhileEnumerable, __super__);
      function WhileEnumerable(c, s) {
        this.c = c;
        this.s = s;
      }
      WhileEnumerable.prototype[$iterator$] = function() {
        var self = this;
        return {next: function() {
            return self.c() ? {
              done: false,
              value: self.s
            } : {
              done: true,
              value: void 0
            };
          }};
      };
      return WhileEnumerable;
    }(Enumerable));
    function enumerableWhile(condition, source) {
      return new WhileEnumerable(condition, source);
    }
    observableProto.letBind = observableProto['let'] = function(func) {
      return func(this);
    };
    Observable['if'] = function(condition, thenSource, elseSourceOrScheduler) {
      return observableDefer(function() {
        elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());
        isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
        isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));
        typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
        return condition() ? thenSource : elseSourceOrScheduler;
      });
    };
    Observable['for'] = Observable.forIn = function(sources, resultSelector, thisArg) {
      return enumerableOf(sources, resultSelector, thisArg).concat();
    };
    var observableWhileDo = Observable['while'] = Observable.whileDo = function(condition, source) {
      isPromise(source) && (source = observableFromPromise(source));
      return enumerableWhile(condition, source).concat();
    };
    observableProto.doWhile = function(condition) {
      return observableConcat([this, observableWhileDo(condition, this)]);
    };
    Observable['case'] = function(selector, sources, defaultSourceOrScheduler) {
      return observableDefer(function() {
        isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
        defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());
        isScheduler(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));
        var result = sources[selector()];
        isPromise(result) && (result = observableFromPromise(result));
        return result || defaultSourceOrScheduler;
      });
    };
    observableProto.expand = function(selector, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      var source = this;
      return new AnonymousObservable(function(observer) {
        var q = [],
            m = new SerialDisposable(),
            d = new CompositeDisposable(m),
            activeCount = 0,
            isAcquired = false;
        var ensureActive = function() {
          var isOwner = false;
          if (q.length > 0) {
            isOwner = !isAcquired;
            isAcquired = true;
          }
          if (isOwner) {
            m.setDisposable(scheduler.scheduleRecursive(function(self) {
              var work;
              if (q.length > 0) {
                work = q.shift();
              } else {
                isAcquired = false;
                return;
              }
              var m1 = new SingleAssignmentDisposable();
              d.add(m1);
              m1.setDisposable(work.subscribe(function(x) {
                observer.onNext(x);
                var result = null;
                try {
                  result = selector(x);
                } catch (e) {
                  observer.onError(e);
                }
                q.push(result);
                activeCount++;
                ensureActive();
              }, observer.onError.bind(observer), function() {
                d.remove(m1);
                activeCount--;
                if (activeCount === 0) {
                  observer.onCompleted();
                }
              }));
              self();
            }));
          }
        };
        q.push(source);
        activeCount++;
        ensureActive();
        return d;
      }, this);
    };
    Observable.forkJoin = function() {
      var allSources = [];
      if (Array.isArray(arguments[0])) {
        allSources = arguments[0];
      } else {
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          allSources.push(arguments[i]);
        }
      }
      return new AnonymousObservable(function(subscriber) {
        var count = allSources.length;
        if (count === 0) {
          subscriber.onCompleted();
          return disposableEmpty;
        }
        var group = new CompositeDisposable(),
            finished = false,
            hasResults = new Array(count),
            hasCompleted = new Array(count),
            results = new Array(count);
        for (var idx = 0; idx < count; idx++) {
          (function(i) {
            var source = allSources[i];
            isPromise(source) && (source = observableFromPromise(source));
            group.add(source.subscribe(function(value) {
              if (!finished) {
                hasResults[i] = true;
                results[i] = value;
              }
            }, function(e) {
              finished = true;
              subscriber.onError(e);
              group.dispose();
            }, function() {
              if (!finished) {
                if (!hasResults[i]) {
                  subscriber.onCompleted();
                  return;
                }
                hasCompleted[i] = true;
                for (var ix = 0; ix < count; ix++) {
                  if (!hasCompleted[ix]) {
                    return;
                  }
                }
                finished = true;
                subscriber.onNext(results);
                subscriber.onCompleted();
              }
            }));
          })(idx);
        }
        return group;
      });
    };
    observableProto.forkJoin = function(second, resultSelector) {
      var first = this;
      return new AnonymousObservable(function(observer) {
        var leftStopped = false,
            rightStopped = false,
            hasLeft = false,
            hasRight = false,
            lastLeft,
            lastRight,
            leftSubscription = new SingleAssignmentDisposable(),
            rightSubscription = new SingleAssignmentDisposable();
        isPromise(second) && (second = observableFromPromise(second));
        leftSubscription.setDisposable(first.subscribe(function(left) {
          hasLeft = true;
          lastLeft = left;
        }, function(err) {
          rightSubscription.dispose();
          observer.onError(err);
        }, function() {
          leftStopped = true;
          if (rightStopped) {
            if (!hasLeft) {
              observer.onCompleted();
            } else if (!hasRight) {
              observer.onCompleted();
            } else {
              var result;
              try {
                result = resultSelector(lastLeft, lastRight);
              } catch (e) {
                observer.onError(e);
                return;
              }
              observer.onNext(result);
              observer.onCompleted();
            }
          }
        }));
        rightSubscription.setDisposable(second.subscribe(function(right) {
          hasRight = true;
          lastRight = right;
        }, function(err) {
          leftSubscription.dispose();
          observer.onError(err);
        }, function() {
          rightStopped = true;
          if (leftStopped) {
            if (!hasLeft) {
              observer.onCompleted();
            } else if (!hasRight) {
              observer.onCompleted();
            } else {
              var result;
              try {
                result = resultSelector(lastLeft, lastRight);
              } catch (e) {
                observer.onError(e);
                return;
              }
              observer.onNext(result);
              observer.onCompleted();
            }
          }
        }));
        return new CompositeDisposable(leftSubscription, rightSubscription);
      }, first);
    };
    observableProto.manySelect = observableProto.extend = function(selector, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      var source = this;
      return observableDefer(function() {
        var chain;
        return source.map(function(x) {
          var curr = new ChainObservable(x);
          chain && chain.onNext(x);
          chain = curr;
          return curr;
        }).tap(noop, function(e) {
          chain && chain.onError(e);
        }, function() {
          chain && chain.onCompleted();
        }).observeOn(scheduler).map(selector);
      }, source);
    };
    var ChainObservable = (function(__super__) {
      function subscribe(observer) {
        var self = this,
            g = new CompositeDisposable();
        g.add(currentThreadScheduler.schedule(function() {
          observer.onNext(self.head);
          g.add(self.tail.mergeAll().subscribe(observer));
        }));
        return g;
      }
      inherits(ChainObservable, __super__);
      function ChainObservable(head) {
        __super__.call(this, subscribe);
        this.head = head;
        this.tail = new AsyncSubject();
      }
      addProperties(ChainObservable.prototype, Observer, {
        onCompleted: function() {
          this.onNext(Observable.empty());
        },
        onError: function(e) {
          this.onNext(Observable['throw'](e));
        },
        onNext: function(v) {
          this.tail.onNext(v);
          this.tail.onCompleted();
        }
      });
      return ChainObservable;
    }(Observable));
    observableProto.switchFirst = function() {
      var sources = this;
      return new AnonymousObservable(function(o) {
        var hasCurrent = false,
            isStopped = false,
            m = new SingleAssignmentDisposable(),
            g = new CompositeDisposable();
        g.add(m);
        m.setDisposable(sources.subscribe(function(innerSource) {
          if (!hasCurrent) {
            hasCurrent = true;
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            var innerSubscription = new SingleAssignmentDisposable();
            g.add(innerSubscription);
            innerSubscription.setDisposable(innerSource.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              o.onError(e);
            }, function() {
              g.remove(innerSubscription);
              hasCurrent = false;
              isStopped && g.length === 1 && o.onCompleted();
            }));
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          isStopped = true;
          !hasCurrent && g.length === 1 && o.onCompleted();
        }));
        return g;
      }, this);
    };
    observableProto.flatMapFirst = observableProto.selectManyFirst = function(selector, resultSelector, thisArg) {
      return new FlatMapObservable(this, selector, resultSelector, thisArg).switchFirst();
    };
    Rx.Observable.prototype.flatMapWithMaxConcurrent = function(limit, selector, resultSelector, thisArg) {
      return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.binding.js", ["npm:rx@3.0.1/dist/rx.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(['rx'], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        Subject = Rx.Subject,
        AsyncSubject = Rx.AsyncSubject,
        Observer = Rx.Observer,
        ScheduledObserver = Rx.internals.ScheduledObserver,
        disposableCreate = Rx.Disposable.create,
        disposableEmpty = Rx.Disposable.empty,
        CompositeDisposable = Rx.CompositeDisposable,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        isFunction = Rx.helpers.isFunction,
        inherits = Rx.internals.inherits,
        addProperties = Rx.internals.addProperties,
        checkDisposed = Rx.Disposable.checkDisposed;
    function cloneArray(arr) {
      var len = arr.length,
          a = new Array(len);
      for (var i = 0; i < len; i++) {
        a[i] = arr[i];
      }
      return a;
    }
    observableProto.multicast = function(subjectOrSubjectSelector, selector) {
      var source = this;
      return typeof subjectOrSubjectSelector === 'function' ? new AnonymousObservable(function(observer) {
        var connectable = source.multicast(subjectOrSubjectSelector());
        return new CompositeDisposable(selector(connectable).subscribe(observer), connectable.connect());
      }, source) : new ConnectableObservable(source, subjectOrSubjectSelector);
    };
    observableProto.publish = function(selector) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new Subject();
      }, selector) : this.multicast(new Subject());
    };
    observableProto.share = function() {
      return this.publish().refCount();
    };
    observableProto.publishLast = function(selector) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new AsyncSubject();
      }, selector) : this.multicast(new AsyncSubject());
    };
    observableProto.publishValue = function(initialValueOrSelector, initialValue) {
      return arguments.length === 2 ? this.multicast(function() {
        return new BehaviorSubject(initialValue);
      }, initialValueOrSelector) : this.multicast(new BehaviorSubject(initialValueOrSelector));
    };
    observableProto.shareValue = function(initialValue) {
      return this.publishValue(initialValue).refCount();
    };
    observableProto.replay = function(selector, bufferSize, windowSize, scheduler) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new ReplaySubject(bufferSize, windowSize, scheduler);
      }, selector) : this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));
    };
    observableProto.shareReplay = function(bufferSize, windowSize, scheduler) {
      return this.replay(null, bufferSize, windowSize, scheduler).refCount();
    };
    var InnerSubscription = function(subject, observer) {
      this.subject = subject;
      this.observer = observer;
    };
    InnerSubscription.prototype.dispose = function() {
      if (!this.subject.isDisposed && this.observer !== null) {
        var idx = this.subject.observers.indexOf(this.observer);
        this.subject.observers.splice(idx, 1);
        this.observer = null;
      }
    };
    var BehaviorSubject = Rx.BehaviorSubject = (function(__super__) {
      function subscribe(observer) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(observer);
          observer.onNext(this.value);
          return new InnerSubscription(this, observer);
        }
        if (this.hasError) {
          observer.onError(this.error);
        } else {
          observer.onCompleted();
        }
        return disposableEmpty;
      }
      inherits(BehaviorSubject, __super__);
      function BehaviorSubject(value) {
        __super__.call(this, subscribe);
        this.value = value, this.observers = [], this.isDisposed = false, this.isStopped = false, this.hasError = false;
      }
      addProperties(BehaviorSubject.prototype, Observer, {
        getValue: function() {
          checkDisposed(this);
          if (this.hasError) {
            throw this.error;
          }
          return this.value;
        },
        hasObservers: function() {
          return this.observers.length > 0;
        },
        onCompleted: function() {
          checkDisposed(this);
          if (this.isStopped) {
            return;
          }
          this.isStopped = true;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onCompleted();
          }
          this.observers.length = 0;
        },
        onError: function(error) {
          checkDisposed(this);
          if (this.isStopped) {
            return;
          }
          this.isStopped = true;
          this.hasError = true;
          this.error = error;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onError(error);
          }
          this.observers.length = 0;
        },
        onNext: function(value) {
          checkDisposed(this);
          if (this.isStopped) {
            return;
          }
          this.value = value;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onNext(value);
          }
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
          this.value = null;
          this.exception = null;
        }
      });
      return BehaviorSubject;
    }(Observable));
    var ReplaySubject = Rx.ReplaySubject = (function(__super__) {
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function createRemovableDisposable(subject, observer) {
        return disposableCreate(function() {
          observer.dispose();
          !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
        });
      }
      function subscribe(observer) {
        var so = new ScheduledObserver(this.scheduler, observer),
            subscription = createRemovableDisposable(this, so);
        checkDisposed(this);
        this._trim(this.scheduler.now());
        this.observers.push(so);
        for (var i = 0,
            len = this.q.length; i < len; i++) {
          so.onNext(this.q[i].value);
        }
        if (this.hasError) {
          so.onError(this.error);
        } else if (this.isStopped) {
          so.onCompleted();
        }
        so.ensureActive();
        return subscription;
      }
      inherits(ReplaySubject, __super__);
      function ReplaySubject(bufferSize, windowSize, scheduler) {
        this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
        this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
        this.scheduler = scheduler || currentThreadScheduler;
        this.q = [];
        this.observers = [];
        this.isStopped = false;
        this.isDisposed = false;
        this.hasError = false;
        this.error = null;
        __super__.call(this, subscribe);
      }
      addProperties(ReplaySubject.prototype, Observer.prototype, {
        hasObservers: function() {
          return this.observers.length > 0;
        },
        _trim: function(now) {
          while (this.q.length > this.bufferSize) {
            this.q.shift();
          }
          while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) {
            this.q.shift();
          }
        },
        onNext: function(value) {
          checkDisposed(this);
          if (this.isStopped) {
            return;
          }
          var now = this.scheduler.now();
          this.q.push({
            interval: now,
            value: value
          });
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onNext(value);
            observer.ensureActive();
          }
        },
        onError: function(error) {
          checkDisposed(this);
          if (this.isStopped) {
            return;
          }
          this.isStopped = true;
          this.error = error;
          this.hasError = true;
          var now = this.scheduler.now();
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onError(error);
            observer.ensureActive();
          }
          this.observers.length = 0;
        },
        onCompleted: function() {
          checkDisposed(this);
          if (this.isStopped) {
            return;
          }
          this.isStopped = true;
          var now = this.scheduler.now();
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onCompleted();
            observer.ensureActive();
          }
          this.observers.length = 0;
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
        }
      });
      return ReplaySubject;
    }(Observable));
    var ConnectableObservable = Rx.ConnectableObservable = (function(__super__) {
      inherits(ConnectableObservable, __super__);
      function ConnectableObservable(source, subject) {
        var hasSubscription = false,
            subscription,
            sourceObservable = source.asObservable();
        this.connect = function() {
          if (!hasSubscription) {
            hasSubscription = true;
            subscription = new CompositeDisposable(sourceObservable.subscribe(subject), disposableCreate(function() {
              hasSubscription = false;
            }));
          }
          return subscription;
        };
        __super__.call(this, function(o) {
          return subject.subscribe(o);
        });
      }
      ConnectableObservable.prototype.refCount = function() {
        var connectableSubscription,
            count = 0,
            source = this;
        return new AnonymousObservable(function(observer) {
          var shouldConnect = ++count === 1,
              subscription = source.subscribe(observer);
          shouldConnect && (connectableSubscription = source.connect());
          return function() {
            subscription.dispose();
            --count === 0 && connectableSubscription.dispose();
          };
        });
      };
      return ConnectableObservable;
    }(Observable));
    observableProto.singleInstance = function() {
      var source = this,
          hasObservable = false,
          observable;
      function getObservable() {
        if (!hasObservable) {
          hasObservable = true;
          observable = source.finally(function() {
            hasObservable = false;
          }).publish().refCount();
        }
        return observable;
      }
      ;
      return new AnonymousObservable(function(o) {
        return getObservable().subscribe(o);
      });
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.sorting.js", ["npm:rx@3.0.1/dist/rx.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(['rx'], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableNever = Observable.never,
        isEqual = Rx.internals.isEqual,
        defaultSubComparer = Rx.helpers.defaultSubComparer;
    observableProto.jortSort = function() {
      return this.jortSortUntil(observableNever());
    };
    observableProto.jortSortUntil = function(other) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var arr = [];
        return source.takeUntil(other).subscribe(arr.push.bind(arr), observer.onError.bind(observer), function() {
          var sorted = arr.slice(0).sort(defaultSubComparer);
          observer.onNext(isEqual(arr, sorted));
          observer.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.joinpatterns.js", ["npm:rx@3.0.1/dist/rx.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(['rx'], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableThrow = Observable.throwError,
        observerCreate = Rx.Observer.create,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        CompositeDisposable = Rx.CompositeDisposable,
        AbstractObserver = Rx.internals.AbstractObserver,
        noop = Rx.helpers.noop,
        defaultComparer = Rx.internals.isEqual,
        inherits = Rx.internals.inherits,
        Enumerable = Rx.internals.Enumerable,
        Enumerator = Rx.internals.Enumerator,
        $iterator$ = Rx.iterator,
        doneEnumerator = Rx.doneEnumerator,
        bindCallback = Rx.internals.bindCallback;
    var Map = root.Map || (function() {
      function Map() {
        this.size = 0;
        this._values = [];
        this._keys = [];
      }
      Map.prototype['delete'] = function(key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
          return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
      };
      Map.prototype.get = function(key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
      };
      Map.prototype.set = function(key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
          this._keys.push(key);
          this._values.push(value);
          this.size++;
        } else {
          this._values[i] = value;
        }
        return this;
      };
      Map.prototype.forEach = function(cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
          cb.call(thisArg, this._values[i], this._keys[i]);
        }
      };
      return Map;
    }());
    function Pattern(patterns) {
      this.patterns = patterns;
    }
    Pattern.prototype.and = function(other) {
      return new Pattern(this.patterns.concat(other));
    };
    Pattern.prototype.thenDo = function(selector) {
      return new Plan(this, selector);
    };
    function Plan(expression, selector) {
      this.expression = expression;
      this.selector = selector;
    }
    Plan.prototype.activate = function(externalSubscriptions, observer, deactivate) {
      var self = this;
      var joinObservers = [];
      for (var i = 0,
          len = this.expression.patterns.length; i < len; i++) {
        joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], observer.onError.bind(observer)));
      }
      var activePlan = new ActivePlan(joinObservers, function() {
        var result;
        try {
          result = self.selector.apply(self, arguments);
        } catch (e) {
          observer.onError(e);
          return;
        }
        observer.onNext(result);
      }, function() {
        for (var j = 0,
            jlen = joinObservers.length; j < jlen; j++) {
          joinObservers[j].removeActivePlan(activePlan);
        }
        deactivate(activePlan);
      });
      for (i = 0, len = joinObservers.length; i < len; i++) {
        joinObservers[i].addActivePlan(activePlan);
      }
      return activePlan;
    };
    function planCreateObserver(externalSubscriptions, observable, onError) {
      var entry = externalSubscriptions.get(observable);
      if (!entry) {
        var observer = new JoinObserver(observable, onError);
        externalSubscriptions.set(observable, observer);
        return observer;
      }
      return entry;
    }
    function ActivePlan(joinObserverArray, onNext, onCompleted) {
      this.joinObserverArray = joinObserverArray;
      this.onNext = onNext;
      this.onCompleted = onCompleted;
      this.joinObservers = new Map();
      for (var i = 0,
          len = this.joinObserverArray.length; i < len; i++) {
        var joinObserver = this.joinObserverArray[i];
        this.joinObservers.set(joinObserver, joinObserver);
      }
    }
    ActivePlan.prototype.dequeue = function() {
      this.joinObservers.forEach(function(v) {
        v.queue.shift();
      });
    };
    ActivePlan.prototype.match = function() {
      var i,
          len,
          hasValues = true;
      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
        if (this.joinObserverArray[i].queue.length === 0) {
          hasValues = false;
          break;
        }
      }
      if (hasValues) {
        var firstValues = [],
            isCompleted = false;
        for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
          firstValues.push(this.joinObserverArray[i].queue[0]);
          this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);
        }
        if (isCompleted) {
          this.onCompleted();
        } else {
          this.dequeue();
          var values = [];
          for (i = 0, len = firstValues.length; i < firstValues.length; i++) {
            values.push(firstValues[i].value);
          }
          this.onNext.apply(this, values);
        }
      }
    };
    var JoinObserver = (function(__super__) {
      inherits(JoinObserver, __super__);
      function JoinObserver(source, onError) {
        __super__.call(this);
        this.source = source;
        this.onError = onError;
        this.queue = [];
        this.activePlans = [];
        this.subscription = new SingleAssignmentDisposable();
        this.isDisposed = false;
      }
      var JoinObserverPrototype = JoinObserver.prototype;
      JoinObserverPrototype.next = function(notification) {
        if (!this.isDisposed) {
          if (notification.kind === 'E') {
            return this.onError(notification.exception);
          }
          this.queue.push(notification);
          var activePlans = this.activePlans.slice(0);
          for (var i = 0,
              len = activePlans.length; i < len; i++) {
            activePlans[i].match();
          }
        }
      };
      JoinObserverPrototype.error = noop;
      JoinObserverPrototype.completed = noop;
      JoinObserverPrototype.addActivePlan = function(activePlan) {
        this.activePlans.push(activePlan);
      };
      JoinObserverPrototype.subscribe = function() {
        this.subscription.setDisposable(this.source.materialize().subscribe(this));
      };
      JoinObserverPrototype.removeActivePlan = function(activePlan) {
        this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
        this.activePlans.length === 0 && this.dispose();
      };
      JoinObserverPrototype.dispose = function() {
        __super__.prototype.dispose.call(this);
        if (!this.isDisposed) {
          this.isDisposed = true;
          this.subscription.dispose();
        }
      };
      return JoinObserver;
    }(AbstractObserver));
    observableProto.and = function(right) {
      return new Pattern([this, right]);
    };
    observableProto.thenDo = function(selector) {
      return new Pattern([this]).thenDo(selector);
    };
    Observable.when = function() {
      var len = arguments.length,
          plans;
      if (Array.isArray(arguments[0])) {
        plans = arguments[0];
      } else {
        plans = new Array(len);
        for (var i = 0; i < len; i++) {
          plans[i] = arguments[i];
        }
      }
      return new AnonymousObservable(function(o) {
        var activePlans = [],
            externalSubscriptions = new Map();
        var outObserver = observerCreate(function(x) {
          o.onNext(x);
        }, function(err) {
          externalSubscriptions.forEach(function(v) {
            v.onError(err);
          });
          o.onError(err);
        }, function(x) {
          o.onCompleted();
        });
        try {
          for (var i = 0,
              len = plans.length; i < len; i++) {
            activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function(activePlan) {
              var idx = activePlans.indexOf(activePlan);
              activePlans.splice(idx, 1);
              activePlans.length === 0 && o.onCompleted();
            }));
          }
        } catch (e) {
          observableThrow(e).subscribe(o);
        }
        var group = new CompositeDisposable();
        externalSubscriptions.forEach(function(joinObserver) {
          joinObserver.subscribe();
          group.add(joinObserver);
        });
        return group;
      });
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.js", ["github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(undefined) {
      var objectTypes = {
        'function': true,
        'object': true
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
          freeSelf = objectTypes[typeof self] && self.Object && self,
          freeWindow = objectTypes[typeof window] && window && window.Object && window,
          freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
          moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
          freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
      var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
      var Rx = {
        internals: {},
        config: {Promise: root.Promise},
        helpers: {}
      };
      var noop = Rx.helpers.noop = function() {},
          identity = Rx.helpers.identity = function(x) {
            return x;
          },
          defaultNow = Rx.helpers.defaultNow = Date.now,
          defaultComparer = Rx.helpers.defaultComparer = function(x, y) {
            return isEqual(x, y);
          },
          defaultSubComparer = Rx.helpers.defaultSubComparer = function(x, y) {
            return x > y ? 1 : (x < y ? -1 : 0);
          },
          defaultKeySerializer = Rx.helpers.defaultKeySerializer = function(x) {
            return x.toString();
          },
          defaultError = Rx.helpers.defaultError = function(err) {
            throw err;
          },
          isPromise = Rx.helpers.isPromise = function(p) {
            return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function';
          },
          isFunction = Rx.helpers.isFunction = (function() {
            var isFn = function(value) {
              return typeof value == 'function' || false;
            };
            if (isFn(/x/)) {
              isFn = function(value) {
                return typeof value == 'function' && toString.call(value) == '[object Function]';
              };
            }
            return isFn;
          }());
      function cloneArray(arr) {
        for (var a = [],
            i = 0,
            len = arr.length; i < len; i++) {
          a.push(arr[i]);
        }
        return a;
      }
      var errorObj = {e: {}};
      var tryCatchTarget;
      function tryCatcher() {
        try {
          return tryCatchTarget.apply(this, arguments);
        } catch (e) {
          errorObj.e = e;
          return errorObj;
        }
      }
      function tryCatch(fn) {
        if (!isFunction(fn)) {
          throw new TypeError('fn must be a function');
        }
        tryCatchTarget = fn;
        return tryCatcher;
      }
      function thrower(e) {
        throw e;
      }
      Rx.config.longStackSupport = false;
      var hasStacks = false,
          stacks = tryCatch(function() {
            throw new Error();
          })();
      hasStacks = !!stacks.e && !!stacks.e.stack;
      var rStartingLine = captureLine(),
          rFileName;
      var STACK_JUMP_SEPARATOR = 'From previous event:';
      function makeStackTraceLong(error, observable) {
        if (hasStacks && observable.stack && typeof error === 'object' && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
          var stacks = [];
          for (var o = observable; !!o; o = o.source) {
            if (o.stack) {
              stacks.unshift(o.stack);
            }
          }
          stacks.unshift(error.stack);
          var concatedStacks = stacks.join('\n' + STACK_JUMP_SEPARATOR + '\n');
          error.stack = filterStackString(concatedStacks);
        }
      }
      function filterStackString(stackString) {
        var lines = stackString.split('\n'),
            desiredLines = [];
        for (var i = 0,
            len = lines.length; i < len; i++) {
          var line = lines[i];
          if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join('\n');
      }
      function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
          return false;
        }
        var fileName = fileNameAndLineNumber[0],
            lineNumber = fileNameAndLineNumber[1];
        return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
      }
      function isNodeFrame(stackLine) {
        return stackLine.indexOf('(module.js:') !== -1 || stackLine.indexOf('(node.js:') !== -1;
      }
      function captureLine() {
        if (!hasStacks) {
          return;
        }
        try {
          throw new Error();
        } catch (e) {
          var lines = e.stack.split('\n');
          var firstLine = lines[0].indexOf('@') > 0 ? lines[1] : lines[2];
          var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
          if (!fileNameAndLineNumber) {
            return;
          }
          rFileName = fileNameAndLineNumber[0];
          return fileNameAndLineNumber[1];
        }
      }
      function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
          return [attempt1[1], Number(attempt1[2])];
        }
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
          return [attempt2[1], Number(attempt2[2])];
        }
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
          return [attempt3[1], Number(attempt3[2])];
        }
      }
      var EmptyError = Rx.EmptyError = function() {
        this.message = 'Sequence contains no elements.';
        this.name = 'EmptyError';
        Error.call(this);
      };
      EmptyError.prototype = Error.prototype;
      var ObjectDisposedError = Rx.ObjectDisposedError = function() {
        this.message = 'Object has been disposed';
        this.name = 'ObjectDisposedError';
        Error.call(this);
      };
      ObjectDisposedError.prototype = Error.prototype;
      var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function() {
        this.message = 'Argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        Error.call(this);
      };
      ArgumentOutOfRangeError.prototype = Error.prototype;
      var NotSupportedError = Rx.NotSupportedError = function(message) {
        this.message = message || 'This operation is not supported';
        this.name = 'NotSupportedError';
        Error.call(this);
      };
      NotSupportedError.prototype = Error.prototype;
      var NotImplementedError = Rx.NotImplementedError = function(message) {
        this.message = message || 'This operation is not implemented';
        this.name = 'NotImplementedError';
        Error.call(this);
      };
      NotImplementedError.prototype = Error.prototype;
      var notImplemented = Rx.helpers.notImplemented = function() {
        throw new NotImplementedError();
      };
      var notSupported = Rx.helpers.notSupported = function() {
        throw new NotSupportedError();
      };
      var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
      if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
        $iterator$ = '@@iterator';
      }
      var doneEnumerator = Rx.doneEnumerator = {
        done: true,
        value: undefined
      };
      var isIterable = Rx.helpers.isIterable = function(o) {
        return o[$iterator$] !== undefined;
      };
      var isArrayLike = Rx.helpers.isArrayLike = function(o) {
        return o && o.length !== undefined;
      };
      Rx.helpers.iterator = $iterator$;
      var bindCallback = Rx.internals.bindCallback = function(func, thisArg, argCount) {
        if (typeof thisArg === 'undefined') {
          return func;
        }
        switch (argCount) {
          case 0:
            return function() {
              return func.call(thisArg);
            };
          case 1:
            return function(arg) {
              return func.call(thisArg, arg);
            };
          case 2:
            return function(value, index) {
              return func.call(thisArg, value, index);
            };
          case 3:
            return function(value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
        }
        return function() {
          return func.apply(thisArg, arguments);
        };
      };
      var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
          dontEnumsLength = dontEnums.length;
      var argsClass = '[object Arguments]',
          arrayClass = '[object Array]',
          boolClass = '[object Boolean]',
          dateClass = '[object Date]',
          errorClass = '[object Error]',
          funcClass = '[object Function]',
          numberClass = '[object Number]',
          objectClass = '[object Object]',
          regexpClass = '[object RegExp]',
          stringClass = '[object String]';
      var toString = Object.prototype.toString,
          hasOwnProperty = Object.prototype.hasOwnProperty,
          supportsArgsClass = toString.call(arguments) == argsClass,
          supportNodeClass,
          errorProto = Error.prototype,
          objectProto = Object.prototype,
          stringProto = String.prototype,
          propertyIsEnumerable = objectProto.propertyIsEnumerable;
      try {
        supportNodeClass = !(toString.call(document) == objectClass && !({'toString': 0} + ''));
      } catch (e) {
        supportNodeClass = true;
      }
      var nonEnumProps = {};
      nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
        'constructor': true,
        'toLocaleString': true,
        'toString': true,
        'valueOf': true
      };
      nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
        'constructor': true,
        'toString': true,
        'valueOf': true
      };
      nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
        'constructor': true,
        'toString': true
      };
      nonEnumProps[objectClass] = {'constructor': true};
      var support = {};
      (function() {
        var ctor = function() {
          this.x = 1;
        },
            props = [];
        ctor.prototype = {
          'valueOf': 1,
          'y': 1
        };
        for (var key in new ctor) {
          props.push(key);
        }
        for (key in arguments) {}
        support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
        support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
        support.nonEnumArgs = key != 0;
        support.nonEnumShadows = !/valueOf/.test(props);
      }(1));
      var isObject = Rx.internals.isObject = function(value) {
        var type = typeof value;
        return value && (type == 'function' || type == 'object') || false;
      };
      function keysIn(object) {
        var result = [];
        if (!isObject(object)) {
          return result;
        }
        if (support.nonEnumArgs && object.length && isArguments(object)) {
          object = slice.call(object);
        }
        var skipProto = support.enumPrototypes && typeof object == 'function',
            skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
        for (var key in object) {
          if (!(skipProto && key == 'prototype') && !(skipErrorProps && (key == 'message' || key == 'name'))) {
            result.push(key);
          }
        }
        if (support.nonEnumShadows && object !== objectProto) {
          var ctor = object.constructor,
              index = -1,
              length = dontEnumsLength;
          if (object === (ctor && ctor.prototype)) {
            var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),
                nonEnum = nonEnumProps[className];
          }
          while (++index < length) {
            key = dontEnums[index];
            if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
        }
        return result;
      }
      function internalFor(object, callback, keysFunc) {
        var index = -1,
            props = keysFunc(object),
            length = props.length;
        while (++index < length) {
          var key = props[index];
          if (callback(object[key], key, object) === false) {
            break;
          }
        }
        return object;
      }
      function internalForIn(object, callback) {
        return internalFor(object, callback, keysIn);
      }
      function isNode(value) {
        return typeof value.toString != 'function' && typeof(value + '') == 'string';
      }
      var isArguments = function(value) {
        return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;
      };
      if (!supportsArgsClass) {
        isArguments = function(value) {
          return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;
        };
      }
      var isEqual = Rx.internals.isEqual = function(x, y) {
        return deepEquals(x, y, [], []);
      };
      function deepEquals(a, b, stackA, stackB) {
        if (a === b) {
          return a !== 0 || (1 / a == 1 / b);
        }
        var type = typeof a,
            otherType = typeof b;
        if (a === a && (a == null || b == null || (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {
          return false;
        }
        var className = toString.call(a),
            otherClass = toString.call(b);
        if (className == argsClass) {
          className = objectClass;
        }
        if (otherClass == argsClass) {
          otherClass = objectClass;
        }
        if (className != otherClass) {
          return false;
        }
        switch (className) {
          case boolClass:
          case dateClass:
            return +a == +b;
          case numberClass:
            return (a != +a) ? b != +b : (a == 0 ? (1 / a == 1 / b) : a == +b);
          case regexpClass:
          case stringClass:
            return a == String(b);
        }
        var isArr = className == arrayClass;
        if (!isArr) {
          if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
            return false;
          }
          var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
              ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
          if (ctorA != ctorB && !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
            return false;
          }
        }
        var initedStack = !stackA;
        stackA || (stackA = []);
        stackB || (stackB = []);
        var length = stackA.length;
        while (length--) {
          if (stackA[length] == a) {
            return stackB[length] == b;
          }
        }
        var size = 0;
        var result = true;
        stackA.push(a);
        stackB.push(b);
        if (isArr) {
          length = a.length;
          size = b.length;
          result = size == length;
          if (result) {
            while (size--) {
              var index = length,
                  value = b[size];
              if (!(result = deepEquals(a[size], value, stackA, stackB))) {
                break;
              }
            }
          }
        } else {
          internalForIn(b, function(value, key, b) {
            if (hasOwnProperty.call(b, key)) {
              size++;
              return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));
            }
          });
          if (result) {
            internalForIn(a, function(value, key, a) {
              if (hasOwnProperty.call(a, key)) {
                return (result = --size > -1);
              }
            });
          }
        }
        stackA.pop();
        stackB.pop();
        return result;
      }
      var hasProp = {}.hasOwnProperty,
          slice = Array.prototype.slice;
      var inherits = Rx.internals.inherits = function(child, parent) {
        function __() {
          this.constructor = child;
        }
        __.prototype = parent.prototype;
        child.prototype = new __();
      };
      var addProperties = Rx.internals.addProperties = function(obj) {
        for (var sources = [],
            i = 1,
            len = arguments.length; i < len; i++) {
          sources.push(arguments[i]);
        }
        for (var idx = 0,
            ln = sources.length; idx < ln; idx++) {
          var source = sources[idx];
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      };
      var addRef = Rx.internals.addRef = function(xs, r) {
        return new AnonymousObservable(function(observer) {
          return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));
        });
      };
      function arrayInitialize(count, factory) {
        var a = new Array(count);
        for (var i = 0; i < count; i++) {
          a[i] = factory();
        }
        return a;
      }
      var CompositeDisposable = Rx.CompositeDisposable = function() {
        var args = [],
            i,
            len;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
          len = args.length;
        } else {
          len = arguments.length;
          args = new Array(len);
          for (i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        for (i = 0; i < len; i++) {
          if (!isDisposable(args[i])) {
            throw new TypeError('Not a disposable');
          }
        }
        this.disposables = args;
        this.isDisposed = false;
        this.length = args.length;
      };
      var CompositeDisposablePrototype = CompositeDisposable.prototype;
      CompositeDisposablePrototype.add = function(item) {
        if (this.isDisposed) {
          item.dispose();
        } else {
          this.disposables.push(item);
          this.length++;
        }
      };
      CompositeDisposablePrototype.remove = function(item) {
        var shouldDispose = false;
        if (!this.isDisposed) {
          var idx = this.disposables.indexOf(item);
          if (idx !== -1) {
            shouldDispose = true;
            this.disposables.splice(idx, 1);
            this.length--;
            item.dispose();
          }
        }
        return shouldDispose;
      };
      CompositeDisposablePrototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var len = this.disposables.length,
              currentDisposables = new Array(len);
          for (var i = 0; i < len; i++) {
            currentDisposables[i] = this.disposables[i];
          }
          this.disposables = [];
          this.length = 0;
          for (i = 0; i < len; i++) {
            currentDisposables[i].dispose();
          }
        }
      };
      var Disposable = Rx.Disposable = function(action) {
        this.isDisposed = false;
        this.action = action || noop;
      };
      Disposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.action();
          this.isDisposed = true;
        }
      };
      var disposableCreate = Disposable.create = function(action) {
        return new Disposable(action);
      };
      var disposableEmpty = Disposable.empty = {dispose: noop};
      var isDisposable = Disposable.isDisposable = function(d) {
        return d && isFunction(d.dispose);
      };
      var checkDisposed = Disposable.checkDisposed = function(disposable) {
        if (disposable.isDisposed) {
          throw new ObjectDisposedError();
        }
      };
      var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function() {
        this.isDisposed = false;
        this.current = null;
      };
      SingleAssignmentDisposable.prototype.getDisposable = function() {
        return this.current;
      };
      SingleAssignmentDisposable.prototype.setDisposable = function(value) {
        if (this.current) {
          throw new Error('Disposable has already been assigned');
        }
        var shouldDispose = this.isDisposed;
        !shouldDispose && (this.current = value);
        shouldDispose && value && value.dispose();
      };
      SingleAssignmentDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      var SerialDisposable = Rx.SerialDisposable = function() {
        this.isDisposed = false;
        this.current = null;
      };
      SerialDisposable.prototype.getDisposable = function() {
        return this.current;
      };
      SerialDisposable.prototype.setDisposable = function(value) {
        var shouldDispose = this.isDisposed;
        if (!shouldDispose) {
          var old = this.current;
          this.current = value;
        }
        old && old.dispose();
        shouldDispose && value && value.dispose();
      };
      SerialDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      var RefCountDisposable = Rx.RefCountDisposable = (function() {
        function InnerDisposable(disposable) {
          this.disposable = disposable;
          this.disposable.count++;
          this.isInnerDisposed = false;
        }
        InnerDisposable.prototype.dispose = function() {
          if (!this.disposable.isDisposed && !this.isInnerDisposed) {
            this.isInnerDisposed = true;
            this.disposable.count--;
            if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
              this.disposable.isDisposed = true;
              this.disposable.underlyingDisposable.dispose();
            }
          }
        };
        function RefCountDisposable(disposable) {
          this.underlyingDisposable = disposable;
          this.isDisposed = false;
          this.isPrimaryDisposed = false;
          this.count = 0;
        }
        RefCountDisposable.prototype.dispose = function() {
          if (!this.isDisposed && !this.isPrimaryDisposed) {
            this.isPrimaryDisposed = true;
            if (this.count === 0) {
              this.isDisposed = true;
              this.underlyingDisposable.dispose();
            }
          }
        };
        RefCountDisposable.prototype.getDisposable = function() {
          return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
        };
        return RefCountDisposable;
      })();
      function ScheduledDisposable(scheduler, disposable) {
        this.scheduler = scheduler;
        this.disposable = disposable;
        this.isDisposed = false;
      }
      function scheduleItem(s, self) {
        if (!self.isDisposed) {
          self.isDisposed = true;
          self.disposable.dispose();
        }
      }
      ScheduledDisposable.prototype.dispose = function() {
        this.scheduler.scheduleWithState(this, scheduleItem);
      };
      var ScheduledItem = Rx.internals.ScheduledItem = function(scheduler, state, action, dueTime, comparer) {
        this.scheduler = scheduler;
        this.state = state;
        this.action = action;
        this.dueTime = dueTime;
        this.comparer = comparer || defaultSubComparer;
        this.disposable = new SingleAssignmentDisposable();
      };
      ScheduledItem.prototype.invoke = function() {
        this.disposable.setDisposable(this.invokeCore());
      };
      ScheduledItem.prototype.compareTo = function(other) {
        return this.comparer(this.dueTime, other.dueTime);
      };
      ScheduledItem.prototype.isCancelled = function() {
        return this.disposable.isDisposed;
      };
      ScheduledItem.prototype.invokeCore = function() {
        return this.action(this.scheduler, this.state);
      };
      var Scheduler = Rx.Scheduler = (function() {
        function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
          this.now = now;
          this._schedule = schedule;
          this._scheduleRelative = scheduleRelative;
          this._scheduleAbsolute = scheduleAbsolute;
        }
        Scheduler.isScheduler = function(s) {
          return s instanceof Scheduler;
        };
        function invokeAction(scheduler, action) {
          action();
          return disposableEmpty;
        }
        var schedulerProto = Scheduler.prototype;
        schedulerProto.schedule = function(action) {
          return this._schedule(action, invokeAction);
        };
        schedulerProto.scheduleWithState = function(state, action) {
          return this._schedule(state, action);
        };
        schedulerProto.scheduleWithRelative = function(dueTime, action) {
          return this._scheduleRelative(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithRelativeAndState = function(state, dueTime, action) {
          return this._scheduleRelative(state, dueTime, action);
        };
        schedulerProto.scheduleWithAbsolute = function(dueTime, action) {
          return this._scheduleAbsolute(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithAbsoluteAndState = function(state, dueTime, action) {
          return this._scheduleAbsolute(state, dueTime, action);
        };
        Scheduler.now = defaultNow;
        Scheduler.normalize = function(timeSpan) {
          timeSpan < 0 && (timeSpan = 0);
          return timeSpan;
        };
        return Scheduler;
      }());
      var normalizeTime = Scheduler.normalize,
          isScheduler = Scheduler.isScheduler;
      (function(schedulerProto) {
        function invokeRecImmediate(scheduler, pair) {
          var state = pair[0],
              action = pair[1],
              group = new CompositeDisposable();
          action(state, innerAction);
          return group;
          function innerAction(state2) {
            var isAdded = false,
                isDone = false;
            var d = scheduler.scheduleWithState(state2, scheduleWork);
            if (!isDone) {
              group.add(d);
              isAdded = true;
            }
            function scheduleWork(_, state3) {
              if (isAdded) {
                group.remove(d);
              } else {
                isDone = true;
              }
              action(state3, innerAction);
              return disposableEmpty;
            }
          }
        }
        function invokeRecDate(scheduler, pair, method) {
          var state = pair[0],
              action = pair[1],
              group = new CompositeDisposable();
          action(state, innerAction);
          return group;
          function innerAction(state2, dueTime1) {
            var isAdded = false,
                isDone = false;
            var d = scheduler[method](state2, dueTime1, scheduleWork);
            if (!isDone) {
              group.add(d);
              isAdded = true;
            }
            function scheduleWork(_, state3) {
              if (isAdded) {
                group.remove(d);
              } else {
                isDone = true;
              }
              action(state3, innerAction);
              return disposableEmpty;
            }
          }
        }
        function invokeRecDateRelative(s, p) {
          return invokeRecDate(s, p, 'scheduleWithRelativeAndState');
        }
        function invokeRecDateAbsolute(s, p) {
          return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');
        }
        function scheduleInnerRecursive(action, self) {
          action(function(dt) {
            self(action, dt);
          });
        }
        schedulerProto.scheduleRecursive = function(action) {
          return this.scheduleRecursiveWithState(action, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithState = function(state, action) {
          return this.scheduleWithState([state, action], invokeRecImmediate);
        };
        schedulerProto.scheduleRecursiveWithRelative = function(dueTime, action) {
          return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithRelativeAndState = function(state, dueTime, action) {
          return this._scheduleRelative([state, action], dueTime, invokeRecDateRelative);
        };
        schedulerProto.scheduleRecursiveWithAbsolute = function(dueTime, action) {
          return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithAbsoluteAndState = function(state, dueTime, action) {
          return this._scheduleAbsolute([state, action], dueTime, invokeRecDateAbsolute);
        };
      }(Scheduler.prototype));
      (function(schedulerProto) {
        Scheduler.prototype.schedulePeriodic = function(period, action) {
          return this.schedulePeriodicWithState(null, period, action);
        };
        Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
          if (typeof root.setInterval === 'undefined') {
            throw new NotSupportedError();
          }
          period = normalizeTime(period);
          var s = state,
              id = root.setInterval(function() {
                s = action(s);
              }, period);
          return disposableCreate(function() {
            root.clearInterval(id);
          });
        };
      }(Scheduler.prototype));
      (function(schedulerProto) {
        schedulerProto.catchError = schedulerProto['catch'] = function(handler) {
          return new CatchScheduler(this, handler);
        };
      }(Scheduler.prototype));
      var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function() {
        function tick(command, recurse) {
          recurse(0, this._period);
          try {
            this._state = this._action(this._state);
          } catch (e) {
            this._cancel.dispose();
            throw e;
          }
        }
        function SchedulePeriodicRecursive(scheduler, state, period, action) {
          this._scheduler = scheduler;
          this._state = state;
          this._period = period;
          this._action = action;
        }
        SchedulePeriodicRecursive.prototype.start = function() {
          var d = new SingleAssignmentDisposable();
          this._cancel = d;
          d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));
          return d;
        };
        return SchedulePeriodicRecursive;
      }());
      var immediateScheduler = Scheduler.immediate = (function() {
        function scheduleNow(state, action) {
          return action(this, state);
        }
        return new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
      }());
      var currentThreadScheduler = Scheduler.currentThread = (function() {
        var queue;
        function runTrampoline() {
          while (queue.length > 0) {
            var item = queue.shift();
            !item.isCancelled() && item.invoke();
          }
        }
        function scheduleNow(state, action) {
          var si = new ScheduledItem(this, state, action, this.now());
          if (!queue) {
            queue = [si];
            var result = tryCatch(runTrampoline)();
            queue = null;
            if (result === errorObj) {
              return thrower(result.e);
            }
          } else {
            queue.push(si);
          }
          return si.disposable;
        }
        var currentScheduler = new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
        currentScheduler.scheduleRequired = function() {
          return !queue;
        };
        return currentScheduler;
      }());
      var scheduleMethod,
          clearMethod;
      var localTimer = (function() {
        var localSetTimeout,
            localClearTimeout = noop;
        if (!!root.setTimeout) {
          localSetTimeout = root.setTimeout;
          localClearTimeout = root.clearTimeout;
        } else if (!!root.WScript) {
          localSetTimeout = function(fn, time) {
            root.WScript.Sleep(time);
            fn();
          };
        } else {
          throw new NotSupportedError();
        }
        return {
          setTimeout: localSetTimeout,
          clearTimeout: localClearTimeout
        };
      }());
      var localSetTimeout = localTimer.setTimeout,
          localClearTimeout = localTimer.clearTimeout;
      (function() {
        var nextHandle = 1,
            tasksByHandle = {},
            currentlyRunning = false;
        clearMethod = function(handle) {
          delete tasksByHandle[handle];
        };
        function runTask(handle) {
          if (currentlyRunning) {
            localSetTimeout(function() {
              runTask(handle);
            }, 0);
          } else {
            var task = tasksByHandle[handle];
            if (task) {
              currentlyRunning = true;
              var result = tryCatch(task)();
              clearMethod(handle);
              currentlyRunning = false;
              if (result === errorObj) {
                return thrower(result.e);
              }
            }
          }
        }
        var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
        var setImmediate = typeof(setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;
        function postMessageSupported() {
          if (!root.postMessage || root.importScripts) {
            return false;
          }
          var isAsync = false,
              oldHandler = root.onmessage;
          root.onmessage = function() {
            isAsync = true;
          };
          root.postMessage('', '*');
          root.onmessage = oldHandler;
          return isAsync;
        }
        if (isFunction(setImmediate)) {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            setImmediate(function() {
              runTask(id);
            });
            return id;
          };
        } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            process.nextTick(function() {
              runTask(id);
            });
            return id;
          };
        } else if (postMessageSupported()) {
          var MSG_PREFIX = 'ms.rx.schedule' + Math.random();
          function onGlobalPostMessage(event) {
            if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
              runTask(event.data.substring(MSG_PREFIX.length));
            }
          }
          if (root.addEventListener) {
            root.addEventListener('message', onGlobalPostMessage, false);
          } else if (root.attachEvent) {
            root.attachEvent('onmessage', onGlobalPostMessage);
          } else {
            root.onmessage = onGlobalPostMessage;
          }
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            root.postMessage(MSG_PREFIX + currentId, '*');
            return id;
          };
        } else if (!!root.MessageChannel) {
          var channel = new root.MessageChannel();
          channel.port1.onmessage = function(e) {
            runTask(e.data);
          };
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            channel.port2.postMessage(id);
            return id;
          };
        } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {
          scheduleMethod = function(action) {
            var scriptElement = root.document.createElement('script');
            var id = nextHandle++;
            tasksByHandle[id] = action;
            scriptElement.onreadystatechange = function() {
              runTask(id);
              scriptElement.onreadystatechange = null;
              scriptElement.parentNode.removeChild(scriptElement);
              scriptElement = null;
            };
            root.document.documentElement.appendChild(scriptElement);
            return id;
          };
        } else {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            localSetTimeout(function() {
              runTask(id);
            }, 0);
            return id;
          };
        }
      }());
      var timeoutScheduler = Scheduler.timeout = Scheduler['default'] = (function() {
        function scheduleNow(state, action) {
          var scheduler = this,
              disposable = new SingleAssignmentDisposable();
          var id = scheduleMethod(function() {
            !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
          });
          return new CompositeDisposable(disposable, disposableCreate(function() {
            clearMethod(id);
          }));
        }
        function scheduleRelative(state, dueTime, action) {
          var scheduler = this,
              dt = Scheduler.normalize(dueTime),
              disposable = new SingleAssignmentDisposable();
          if (dt === 0) {
            return scheduler.scheduleWithState(state, action);
          }
          var id = localSetTimeout(function() {
            !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
          }, dt);
          return new CompositeDisposable(disposable, disposableCreate(function() {
            localClearTimeout(id);
          }));
        }
        function scheduleAbsolute(state, dueTime, action) {
          return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
        }
        return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
      })();
      var CatchScheduler = (function(__super__) {
        function scheduleNow(state, action) {
          return this._scheduler.scheduleWithState(state, this._wrap(action));
        }
        function scheduleRelative(state, dueTime, action) {
          return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action));
        }
        function scheduleAbsolute(state, dueTime, action) {
          return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action));
        }
        inherits(CatchScheduler, __super__);
        function CatchScheduler(scheduler, handler) {
          this._scheduler = scheduler;
          this._handler = handler;
          this._recursiveOriginal = null;
          this._recursiveWrapper = null;
          __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute);
        }
        CatchScheduler.prototype._clone = function(scheduler) {
          return new CatchScheduler(scheduler, this._handler);
        };
        CatchScheduler.prototype._wrap = function(action) {
          var parent = this;
          return function(self, state) {
            try {
              return action(parent._getRecursiveWrapper(self), state);
            } catch (e) {
              if (!parent._handler(e)) {
                throw e;
              }
              return disposableEmpty;
            }
          };
        };
        CatchScheduler.prototype._getRecursiveWrapper = function(scheduler) {
          if (this._recursiveOriginal !== scheduler) {
            this._recursiveOriginal = scheduler;
            var wrapper = this._clone(scheduler);
            wrapper._recursiveOriginal = scheduler;
            wrapper._recursiveWrapper = wrapper;
            this._recursiveWrapper = wrapper;
          }
          return this._recursiveWrapper;
        };
        CatchScheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
          var self = this,
              failed = false,
              d = new SingleAssignmentDisposable();
          d.setDisposable(this._scheduler.schedulePeriodicWithState(state, period, function(state1) {
            if (failed) {
              return null;
            }
            try {
              return action(state1);
            } catch (e) {
              failed = true;
              if (!self._handler(e)) {
                throw e;
              }
              d.dispose();
              return null;
            }
          }));
          return d;
        };
        return CatchScheduler;
      }(Scheduler));
      var Notification = Rx.Notification = (function() {
        function Notification(kind, value, exception, accept, acceptObservable, toString) {
          this.kind = kind;
          this.value = value;
          this.exception = exception;
          this._accept = accept;
          this._acceptObservable = acceptObservable;
          this.toString = toString;
        }
        Notification.prototype.accept = function(observerOrOnNext, onError, onCompleted) {
          return observerOrOnNext && typeof observerOrOnNext === 'object' ? this._acceptObservable(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
        };
        Notification.prototype.toObservable = function(scheduler) {
          var self = this;
          isScheduler(scheduler) || (scheduler = immediateScheduler);
          return new AnonymousObservable(function(observer) {
            return scheduler.scheduleWithState(self, function(_, notification) {
              notification._acceptObservable(observer);
              notification.kind === 'N' && observer.onCompleted();
            });
          });
        };
        return Notification;
      })();
      var notificationCreateOnNext = Notification.createOnNext = (function() {
        function _accept(onNext) {
          return onNext(this.value);
        }
        function _acceptObservable(observer) {
          return observer.onNext(this.value);
        }
        function toString() {
          return 'OnNext(' + this.value + ')';
        }
        return function(value) {
          return new Notification('N', value, null, _accept, _acceptObservable, toString);
        };
      }());
      var notificationCreateOnError = Notification.createOnError = (function() {
        function _accept(onNext, onError) {
          return onError(this.exception);
        }
        function _acceptObservable(observer) {
          return observer.onError(this.exception);
        }
        function toString() {
          return 'OnError(' + this.exception + ')';
        }
        return function(e) {
          return new Notification('E', null, e, _accept, _acceptObservable, toString);
        };
      }());
      var notificationCreateOnCompleted = Notification.createOnCompleted = (function() {
        function _accept(onNext, onError, onCompleted) {
          return onCompleted();
        }
        function _acceptObservable(observer) {
          return observer.onCompleted();
        }
        function toString() {
          return 'OnCompleted()';
        }
        return function() {
          return new Notification('C', null, null, _accept, _acceptObservable, toString);
        };
      }());
      var Observer = Rx.Observer = function() {};
      Observer.prototype.toNotifier = function() {
        var observer = this;
        return function(n) {
          return n.accept(observer);
        };
      };
      Observer.prototype.asObserver = function() {
        var self = this;
        return new AnonymousObserver(function(x) {
          self.onNext(x);
        }, function(err) {
          self.onError(err);
        }, function() {
          self.onCompleted();
        });
      };
      Observer.prototype.checked = function() {
        return new CheckedObserver(this);
      };
      var observerCreate = Observer.create = function(onNext, onError, onCompleted) {
        onNext || (onNext = noop);
        onError || (onError = defaultError);
        onCompleted || (onCompleted = noop);
        return new AnonymousObserver(onNext, onError, onCompleted);
      };
      Observer.fromNotifier = function(handler, thisArg) {
        var cb = bindCallback(handler, thisArg, 1);
        return new AnonymousObserver(function(x) {
          return cb(notificationCreateOnNext(x));
        }, function(e) {
          return cb(notificationCreateOnError(e));
        }, function() {
          return cb(notificationCreateOnCompleted());
        });
      };
      Observer.prototype.notifyOn = function(scheduler) {
        return new ObserveOnObserver(scheduler, this);
      };
      Observer.prototype.makeSafe = function(disposable) {
        return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
      };
      var AbstractObserver = Rx.internals.AbstractObserver = (function(__super__) {
        inherits(AbstractObserver, __super__);
        function AbstractObserver() {
          this.isStopped = false;
        }
        AbstractObserver.prototype.next = notImplemented;
        AbstractObserver.prototype.error = notImplemented;
        AbstractObserver.prototype.completed = notImplemented;
        AbstractObserver.prototype.onNext = function(value) {
          !this.isStopped && this.next(value);
        };
        AbstractObserver.prototype.onError = function(error) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.error(error);
          }
        };
        AbstractObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.completed();
          }
        };
        AbstractObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        AbstractObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.error(e);
            return true;
          }
          return false;
        };
        return AbstractObserver;
      }(Observer));
      var AnonymousObserver = Rx.AnonymousObserver = (function(__super__) {
        inherits(AnonymousObserver, __super__);
        function AnonymousObserver(onNext, onError, onCompleted) {
          __super__.call(this);
          this._onNext = onNext;
          this._onError = onError;
          this._onCompleted = onCompleted;
        }
        AnonymousObserver.prototype.next = function(value) {
          this._onNext(value);
        };
        AnonymousObserver.prototype.error = function(error) {
          this._onError(error);
        };
        AnonymousObserver.prototype.completed = function() {
          this._onCompleted();
        };
        return AnonymousObserver;
      }(AbstractObserver));
      var CheckedObserver = (function(__super__) {
        inherits(CheckedObserver, __super__);
        function CheckedObserver(observer) {
          __super__.call(this);
          this._observer = observer;
          this._state = 0;
        }
        var CheckedObserverPrototype = CheckedObserver.prototype;
        CheckedObserverPrototype.onNext = function(value) {
          this.checkAccess();
          var res = tryCatch(this._observer.onNext).call(this._observer, value);
          this._state = 0;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.onError = function(err) {
          this.checkAccess();
          var res = tryCatch(this._observer.onError).call(this._observer, err);
          this._state = 2;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.onCompleted = function() {
          this.checkAccess();
          var res = tryCatch(this._observer.onCompleted).call(this._observer);
          this._state = 2;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.checkAccess = function() {
          if (this._state === 1) {
            throw new Error('Re-entrancy detected');
          }
          if (this._state === 2) {
            throw new Error('Observer completed');
          }
          if (this._state === 0) {
            this._state = 1;
          }
        };
        return CheckedObserver;
      }(Observer));
      var ScheduledObserver = Rx.internals.ScheduledObserver = (function(__super__) {
        inherits(ScheduledObserver, __super__);
        function ScheduledObserver(scheduler, observer) {
          __super__.call(this);
          this.scheduler = scheduler;
          this.observer = observer;
          this.isAcquired = false;
          this.hasFaulted = false;
          this.queue = [];
          this.disposable = new SerialDisposable();
        }
        ScheduledObserver.prototype.next = function(value) {
          var self = this;
          this.queue.push(function() {
            self.observer.onNext(value);
          });
        };
        ScheduledObserver.prototype.error = function(e) {
          var self = this;
          this.queue.push(function() {
            self.observer.onError(e);
          });
        };
        ScheduledObserver.prototype.completed = function() {
          var self = this;
          this.queue.push(function() {
            self.observer.onCompleted();
          });
        };
        ScheduledObserver.prototype.ensureActive = function() {
          var isOwner = false;
          if (!this.hasFaulted && this.queue.length > 0) {
            isOwner = !this.isAcquired;
            this.isAcquired = true;
          }
          if (isOwner) {
            this.disposable.setDisposable(this.scheduler.scheduleRecursiveWithState(this, function(parent, self) {
              var work;
              if (parent.queue.length > 0) {
                work = parent.queue.shift();
              } else {
                parent.isAcquired = false;
                return;
              }
              var res = tryCatch(work)();
              if (res === errorObj) {
                parent.queue = [];
                parent.hasFaulted = true;
                return thrower(res.e);
              }
              self(parent);
            }));
          }
        };
        ScheduledObserver.prototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this.disposable.dispose();
        };
        return ScheduledObserver;
      }(AbstractObserver));
      var ObserveOnObserver = (function(__super__) {
        inherits(ObserveOnObserver, __super__);
        function ObserveOnObserver(scheduler, observer, cancel) {
          __super__.call(this, scheduler, observer);
          this._cancel = cancel;
        }
        ObserveOnObserver.prototype.next = function(value) {
          __super__.prototype.next.call(this, value);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.error = function(e) {
          __super__.prototype.error.call(this, e);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.completed = function() {
          __super__.prototype.completed.call(this);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this._cancel && this._cancel.dispose();
          this._cancel = null;
        };
        return ObserveOnObserver;
      })(ScheduledObserver);
      var observableProto;
      var Observable = Rx.Observable = (function() {
        function makeSubscribe(self, subscribe) {
          return function(o) {
            var oldOnError = o.onError;
            o.onError = function(e) {
              makeStackTraceLong(e, self);
              oldOnError.call(o, e);
            };
            return subscribe.call(self, o);
          };
        }
        function Observable(subscribe) {
          if (Rx.config.longStackSupport && hasStacks) {
            var e = tryCatch(thrower)(new Error()).e;
            this.stack = e.stack.substring(e.stack.indexOf('\n') + 1);
            this._subscribe = makeSubscribe(this, subscribe);
          } else {
            this._subscribe = subscribe;
          }
        }
        observableProto = Observable.prototype;
        Observable.isObservable = function(o) {
          return o && isFunction(o.subscribe);
        };
        observableProto.subscribe = observableProto.forEach = function(oOrOnNext, onError, onCompleted) {
          return this._subscribe(typeof oOrOnNext === 'object' ? oOrOnNext : observerCreate(oOrOnNext, onError, onCompleted));
        };
        observableProto.subscribeOnNext = function(onNext, thisArg) {
          return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function(x) {
            onNext.call(thisArg, x);
          } : onNext));
        };
        observableProto.subscribeOnError = function(onError, thisArg) {
          return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function(e) {
            onError.call(thisArg, e);
          } : onError));
        };
        observableProto.subscribeOnCompleted = function(onCompleted, thisArg) {
          return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function() {
            onCompleted.call(thisArg);
          } : onCompleted));
        };
        return Observable;
      })();
      var ObservableBase = Rx.ObservableBase = (function(__super__) {
        inherits(ObservableBase, __super__);
        function fixSubscriber(subscriber) {
          return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
          var ado = state[0],
              self = state[1];
          var sub = tryCatch(self.subscribeCore).call(self, ado);
          if (sub === errorObj) {
            if (!ado.fail(errorObj.e)) {
              return thrower(errorObj.e);
            }
          }
          ado.setDisposable(fixSubscriber(sub));
        }
        function subscribe(observer) {
          var ado = new AutoDetachObserver(observer),
              state = [ado, this];
          if (currentThreadScheduler.scheduleRequired()) {
            currentThreadScheduler.scheduleWithState(state, setDisposable);
          } else {
            setDisposable(null, state);
          }
          return ado;
        }
        function ObservableBase() {
          __super__.call(this, subscribe);
        }
        ObservableBase.prototype.subscribeCore = notImplemented;
        return ObservableBase;
      }(Observable));
      var FlatMapObservable = (function(__super__) {
        inherits(FlatMapObservable, __super__);
        function FlatMapObservable(source, selector, resultSelector, thisArg) {
          this.resultSelector = Rx.helpers.isFunction(resultSelector) ? resultSelector : null;
          this.selector = Rx.internals.bindCallback(Rx.helpers.isFunction(selector) ? selector : function() {
            return selector;
          }, thisArg, 3);
          this.source = source;
          __super__.call(this);
        }
        FlatMapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.selector, this.resultSelector, this));
        };
        function InnerObserver(observer, selector, resultSelector, source) {
          this.i = 0;
          this.selector = selector;
          this.resultSelector = resultSelector;
          this.source = source;
          this.isStopped = false;
          this.o = observer;
        }
        InnerObserver.prototype._wrapResult = function(result, x, i) {
          return this.resultSelector ? result.map(function(y, i2) {
            return this.resultSelector(x, y, i, i2);
          }, this) : result;
        };
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped)
            return;
          var i = this.i++;
          var result = tryCatch(this.selector)(x, i, this.source);
          if (result === errorObj) {
            return this.o.onError(result.e);
          }
          Rx.helpers.isPromise(result) && (result = Rx.Observable.fromPromise(result));
          (Rx.helpers.isArrayLike(result) || Rx.helpers.isIterable(result)) && (result = Rx.Observable.from(result));
          this.o.onNext(this._wrapResult(result, x, i));
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        return FlatMapObservable;
      }(ObservableBase));
      var Enumerable = Rx.internals.Enumerable = function() {};
      var ConcatEnumerableObservable = (function(__super__) {
        inherits(ConcatEnumerableObservable, __super__);
        function ConcatEnumerableObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        ConcatEnumerableObservable.prototype.subscribeCore = function(o) {
          var isDisposed,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursiveWithState(this.sources[$iterator$](), function(e, self) {
            if (isDisposed) {
              return;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              return o.onCompleted();
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(new InnerObserver(o, self, e)));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        function InnerObserver(o, s, e) {
          this.o = o;
          this.s = s;
          this.e = e;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.s(this.e);
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
            return true;
          }
          return false;
        };
        return ConcatEnumerableObservable;
      }(ObservableBase));
      Enumerable.prototype.concat = function() {
        return new ConcatEnumerableObservable(this);
      };
      var CatchErrorObservable = (function(__super__) {
        inherits(CatchErrorObservable, __super__);
        function CatchErrorObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        CatchErrorObservable.prototype.subscribeCore = function(o) {
          var e = this.sources[$iterator$]();
          var isDisposed,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursiveWithState(null, function(lastException, self) {
            if (isDisposed) {
              return;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              return lastException !== null ? o.onError(lastException) : o.onCompleted();
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, self, function() {
              o.onCompleted();
            }));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        return CatchErrorObservable;
      }(ObservableBase));
      Enumerable.prototype.catchError = function() {
        return new CatchErrorObservable(this);
      };
      Enumerable.prototype.catchErrorWhen = function(notificationHandler) {
        var sources = this;
        return new AnonymousObservable(function(o) {
          var exceptions = new Subject(),
              notifier = new Subject(),
              handled = notificationHandler(exceptions),
              notificationDisposable = handled.subscribe(notifier);
          var e = sources[$iterator$]();
          var isDisposed,
              lastException,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursive(function(self) {
            if (isDisposed) {
              return;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              if (lastException) {
                o.onError(lastException);
              } else {
                o.onCompleted();
              }
              return;
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var outer = new SingleAssignmentDisposable();
            var inner = new SingleAssignmentDisposable();
            subscription.setDisposable(new CompositeDisposable(inner, outer));
            outer.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, function(exn) {
              inner.setDisposable(notifier.subscribe(self, function(ex) {
                o.onError(ex);
              }, function() {
                o.onCompleted();
              }));
              exceptions.onNext(exn);
            }, function() {
              o.onCompleted();
            }));
          });
          return new CompositeDisposable(notificationDisposable, subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        });
      };
      var RepeatEnumerable = (function(__super__) {
        inherits(RepeatEnumerable, __super__);
        function RepeatEnumerable(v, c) {
          this.v = v;
          this.c = c == null ? -1 : c;
        }
        RepeatEnumerable.prototype[$iterator$] = function() {
          return new RepeatEnumerator(this);
        };
        function RepeatEnumerator(p) {
          this.v = p.v;
          this.l = p.c;
        }
        RepeatEnumerator.prototype.next = function() {
          if (this.l === 0) {
            return doneEnumerator;
          }
          if (this.l > 0) {
            this.l--;
          }
          return {
            done: false,
            value: this.v
          };
        };
        return RepeatEnumerable;
      }(Enumerable));
      var enumerableRepeat = Enumerable.repeat = function(value, repeatCount) {
        return new RepeatEnumerable(value, repeatCount);
      };
      var OfEnumerable = (function(__super__) {
        inherits(OfEnumerable, __super__);
        function OfEnumerable(s, fn, thisArg) {
          this.s = s;
          this.fn = fn ? bindCallback(fn, thisArg, 3) : null;
        }
        OfEnumerable.prototype[$iterator$] = function() {
          return new OfEnumerator(this);
        };
        function OfEnumerator(p) {
          this.i = -1;
          this.s = p.s;
          this.l = this.s.length;
          this.fn = p.fn;
        }
        OfEnumerator.prototype.next = function() {
          return ++this.i < this.l ? {
            done: false,
            value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s)
          } : doneEnumerator;
        };
        return OfEnumerable;
      }(Enumerable));
      var enumerableOf = Enumerable.of = function(source, selector, thisArg) {
        return new OfEnumerable(source, selector, thisArg);
      };
      observableProto.observeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          return source.subscribe(new ObserveOnObserver(scheduler, observer));
        }, source);
      };
      observableProto.subscribeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var m = new SingleAssignmentDisposable(),
              d = new SerialDisposable();
          d.setDisposable(m);
          m.setDisposable(scheduler.schedule(function() {
            d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(observer)));
          }));
          return d;
        }, source);
      };
      var FromPromiseObservable = (function(__super__) {
        inherits(FromPromiseObservable, __super__);
        function FromPromiseObservable(p) {
          this.p = p;
          __super__.call(this);
        }
        FromPromiseObservable.prototype.subscribeCore = function(o) {
          this.p.then(function(data) {
            o.onNext(data);
            o.onCompleted();
          }, function(err) {
            o.onError(err);
          });
          return disposableEmpty;
        };
        return FromPromiseObservable;
      }(ObservableBase));
      var observableFromPromise = Observable.fromPromise = function(promise) {
        return new FromPromiseObservable(promise);
      };
      observableProto.toPromise = function(promiseCtor) {
        promiseCtor || (promiseCtor = Rx.config.Promise);
        if (!promiseCtor) {
          throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
        }
        var source = this;
        return new promiseCtor(function(resolve, reject) {
          var value,
              hasValue = false;
          source.subscribe(function(v) {
            value = v;
            hasValue = true;
          }, reject, function() {
            hasValue && resolve(value);
          });
        });
      };
      var ToArrayObservable = (function(__super__) {
        inherits(ToArrayObservable, __super__);
        function ToArrayObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        ToArrayObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
          this.o = o;
          this.a = [];
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.a.push(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onNext(this.a);
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return ToArrayObservable;
      }(ObservableBase));
      observableProto.toArray = function() {
        return new ToArrayObservable(this);
      };
      Observable.create = function(subscribe, parent) {
        return new AnonymousObservable(subscribe, parent);
      };
      var observableDefer = Observable.defer = function(observableFactory) {
        return new AnonymousObservable(function(observer) {
          var result;
          try {
            result = observableFactory();
          } catch (e) {
            return observableThrow(e).subscribe(observer);
          }
          isPromise(result) && (result = observableFromPromise(result));
          return result.subscribe(observer);
        });
      };
      var EmptyObservable = (function(__super__) {
        inherits(EmptyObservable, __super__);
        function EmptyObservable(scheduler) {
          this.scheduler = scheduler;
          __super__.call(this);
        }
        EmptyObservable.prototype.subscribeCore = function(observer) {
          var sink = new EmptySink(observer, this.scheduler);
          return sink.run();
        };
        function EmptySink(observer, scheduler) {
          this.observer = observer;
          this.scheduler = scheduler;
        }
        function scheduleItem(s, state) {
          state.onCompleted();
          return disposableEmpty;
        }
        EmptySink.prototype.run = function() {
          return this.scheduler.scheduleWithState(this.observer, scheduleItem);
        };
        return EmptyObservable;
      }(ObservableBase));
      var EMPTY_OBSERVABLE = new EmptyObservable(immediateScheduler);
      var observableEmpty = Observable.empty = function(scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return scheduler === immediateScheduler ? EMPTY_OBSERVABLE : new EmptyObservable(scheduler);
      };
      var FromObservable = (function(__super__) {
        inherits(FromObservable, __super__);
        function FromObservable(iterable, mapper, scheduler) {
          this.iterable = iterable;
          this.mapper = mapper;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        FromObservable.prototype.subscribeCore = function(o) {
          var sink = new FromSink(o, this);
          return sink.run();
        };
        return FromObservable;
      }(ObservableBase));
      var FromSink = (function() {
        function FromSink(o, parent) {
          this.o = o;
          this.parent = parent;
        }
        FromSink.prototype.run = function() {
          var list = Object(this.parent.iterable),
              it = getIterable(list),
              o = this.o,
              mapper = this.parent.mapper;
          function loopRecursive(i, recurse) {
            var next = tryCatch(it.next).call(it);
            if (next === errorObj) {
              return o.onError(next.e);
            }
            if (next.done) {
              return o.onCompleted();
            }
            var result = next.value;
            if (isFunction(mapper)) {
              result = tryCatch(mapper)(result, i);
              if (result === errorObj) {
                return o.onError(result.e);
              }
            }
            o.onNext(result);
            recurse(i + 1);
          }
          return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return FromSink;
      }());
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function StringIterable(s) {
        this._s = s;
      }
      StringIterable.prototype[$iterator$] = function() {
        return new StringIterator(this._s);
      };
      function StringIterator(s) {
        this._s = s;
        this._l = s.length;
        this._i = 0;
      }
      StringIterator.prototype[$iterator$] = function() {
        return this;
      };
      StringIterator.prototype.next = function() {
        return this._i < this._l ? {
          done: false,
          value: this._s.charAt(this._i++)
        } : doneEnumerator;
      };
      function ArrayIterable(a) {
        this._a = a;
      }
      ArrayIterable.prototype[$iterator$] = function() {
        return new ArrayIterator(this._a);
      };
      function ArrayIterator(a) {
        this._a = a;
        this._l = toLength(a);
        this._i = 0;
      }
      ArrayIterator.prototype[$iterator$] = function() {
        return this;
      };
      ArrayIterator.prototype.next = function() {
        return this._i < this._l ? {
          done: false,
          value: this._a[this._i++]
        } : doneEnumerator;
      };
      function numberIsFinite(value) {
        return typeof value === 'number' && root.isFinite(value);
      }
      function isNan(n) {
        return n !== n;
      }
      function getIterable(o) {
        var i = o[$iterator$],
            it;
        if (!i && typeof o === 'string') {
          it = new StringIterable(o);
          return it[$iterator$]();
        }
        if (!i && o.length !== undefined) {
          it = new ArrayIterable(o);
          return it[$iterator$]();
        }
        if (!i) {
          throw new TypeError('Object is not iterable');
        }
        return o[$iterator$]();
      }
      function sign(value) {
        var number = +value;
        if (number === 0) {
          return number;
        }
        if (isNaN(number)) {
          return number;
        }
        return number < 0 ? -1 : 1;
      }
      function toLength(o) {
        var len = +o.length;
        if (isNaN(len)) {
          return 0;
        }
        if (len === 0 || !numberIsFinite(len)) {
          return len;
        }
        len = sign(len) * Math.floor(Math.abs(len));
        if (len <= 0) {
          return 0;
        }
        if (len > maxSafeInteger) {
          return maxSafeInteger;
        }
        return len;
      }
      var observableFrom = Observable.from = function(iterable, mapFn, thisArg, scheduler) {
        if (iterable == null) {
          throw new Error('iterable cannot be null.');
        }
        if (mapFn && !isFunction(mapFn)) {
          throw new Error('mapFn when provided must be a function');
        }
        if (mapFn) {
          var mapper = bindCallback(mapFn, thisArg, 2);
        }
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromObservable(iterable, mapper, scheduler);
      };
      var FromArrayObservable = (function(__super__) {
        inherits(FromArrayObservable, __super__);
        function FromArrayObservable(args, scheduler) {
          this.args = args;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        FromArrayObservable.prototype.subscribeCore = function(observer) {
          var sink = new FromArraySink(observer, this);
          return sink.run();
        };
        return FromArrayObservable;
      }(ObservableBase));
      function FromArraySink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      FromArraySink.prototype.run = function() {
        var observer = this.observer,
            args = this.parent.args,
            len = args.length;
        function loopRecursive(i, recurse) {
          if (i < len) {
            observer.onNext(args[i]);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      var observableFromArray = Observable.fromArray = function(array, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
      };
      Observable.generate = function(initialState, condition, iterate, resultSelector, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new AnonymousObservable(function(o) {
          var first = true;
          return scheduler.scheduleRecursiveWithState(initialState, function(state, self) {
            var hasResult,
                result;
            try {
              if (first) {
                first = false;
              } else {
                state = iterate(state);
              }
              hasResult = condition(state);
              hasResult && (result = resultSelector(state));
            } catch (e) {
              return o.onError(e);
            }
            if (hasResult) {
              o.onNext(result);
              self(state);
            } else {
              o.onCompleted();
            }
          });
        });
      };
      var NeverObservable = (function(__super__) {
        inherits(NeverObservable, __super__);
        function NeverObservable() {
          __super__.call(this);
        }
        NeverObservable.prototype.subscribeCore = function(observer) {
          return disposableEmpty;
        };
        return NeverObservable;
      }(ObservableBase));
      var NEVER_OBSERVABLE = new NeverObservable();
      var observableNever = Observable.never = function() {
        return NEVER_OBSERVABLE;
      };
      function observableOf(scheduler, array) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
      }
      Observable.of = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return new FromArrayObservable(args, currentThreadScheduler);
      };
      Observable.ofWithScheduler = function(scheduler) {
        var len = arguments.length,
            args = new Array(len - 1);
        for (var i = 1; i < len; i++) {
          args[i - 1] = arguments[i];
        }
        return new FromArrayObservable(args, scheduler);
      };
      var PairsObservable = (function(__super__) {
        inherits(PairsObservable, __super__);
        function PairsObservable(obj, scheduler) {
          this.obj = obj;
          this.keys = Object.keys(obj);
          this.scheduler = scheduler;
          __super__.call(this);
        }
        PairsObservable.prototype.subscribeCore = function(observer) {
          var sink = new PairsSink(observer, this);
          return sink.run();
        };
        return PairsObservable;
      }(ObservableBase));
      function PairsSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      PairsSink.prototype.run = function() {
        var observer = this.observer,
            obj = this.parent.obj,
            keys = this.parent.keys,
            len = keys.length;
        function loopRecursive(i, recurse) {
          if (i < len) {
            var key = keys[i];
            observer.onNext([key, obj[key]]);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      Observable.pairs = function(obj, scheduler) {
        scheduler || (scheduler = currentThreadScheduler);
        return new PairsObservable(obj, scheduler);
      };
      var RangeObservable = (function(__super__) {
        inherits(RangeObservable, __super__);
        function RangeObservable(start, count, scheduler) {
          this.start = start;
          this.rangeCount = count;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        RangeObservable.prototype.subscribeCore = function(observer) {
          var sink = new RangeSink(observer, this);
          return sink.run();
        };
        return RangeObservable;
      }(ObservableBase));
      var RangeSink = (function() {
        function RangeSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        RangeSink.prototype.run = function() {
          var start = this.parent.start,
              count = this.parent.rangeCount,
              observer = this.observer;
          function loopRecursive(i, recurse) {
            if (i < count) {
              observer.onNext(start + i);
              recurse(i + 1);
            } else {
              observer.onCompleted();
            }
          }
          return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return RangeSink;
      }());
      Observable.range = function(start, count, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RangeObservable(start, count, scheduler);
      };
      var RepeatObservable = (function(__super__) {
        inherits(RepeatObservable, __super__);
        function RepeatObservable(value, repeatCount, scheduler) {
          this.value = value;
          this.repeatCount = repeatCount == null ? -1 : repeatCount;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        RepeatObservable.prototype.subscribeCore = function(observer) {
          var sink = new RepeatSink(observer, this);
          return sink.run();
        };
        return RepeatObservable;
      }(ObservableBase));
      function RepeatSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      RepeatSink.prototype.run = function() {
        var observer = this.observer,
            value = this.parent.value;
        function loopRecursive(i, recurse) {
          if (i === -1 || i > 0) {
            observer.onNext(value);
            i > 0 && i--;
          }
          if (i === 0) {
            return observer.onCompleted();
          }
          recurse(i);
        }
        return this.parent.scheduler.scheduleRecursiveWithState(this.parent.repeatCount, loopRecursive);
      };
      Observable.repeat = function(value, repeatCount, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RepeatObservable(value, repeatCount, scheduler);
      };
      var JustObservable = (function(__super__) {
        inherits(JustObservable, __super__);
        function JustObservable(value, scheduler) {
          this.value = value;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        JustObservable.prototype.subscribeCore = function(observer) {
          var sink = new JustSink(observer, this.value, this.scheduler);
          return sink.run();
        };
        function JustSink(observer, value, scheduler) {
          this.observer = observer;
          this.value = value;
          this.scheduler = scheduler;
        }
        function scheduleItem(s, state) {
          var value = state[0],
              observer = state[1];
          observer.onNext(value);
          observer.onCompleted();
          return disposableEmpty;
        }
        JustSink.prototype.run = function() {
          var state = [this.value, this.observer];
          return this.scheduler === immediateScheduler ? scheduleItem(null, state) : this.scheduler.scheduleWithState(state, scheduleItem);
        };
        return JustObservable;
      }(ObservableBase));
      var observableReturn = Observable['return'] = Observable.just = function(value, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new JustObservable(value, scheduler);
      };
      var ThrowObservable = (function(__super__) {
        inherits(ThrowObservable, __super__);
        function ThrowObservable(error, scheduler) {
          this.error = error;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        ThrowObservable.prototype.subscribeCore = function(o) {
          var sink = new ThrowSink(o, this);
          return sink.run();
        };
        function ThrowSink(o, p) {
          this.o = o;
          this.p = p;
        }
        function scheduleItem(s, state) {
          var e = state[0],
              o = state[1];
          o.onError(e);
        }
        ThrowSink.prototype.run = function() {
          return this.p.scheduler.scheduleWithState([this.p.error, this.o], scheduleItem);
        };
        return ThrowObservable;
      }(ObservableBase));
      var observableThrow = Observable['throw'] = function(error, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new ThrowObservable(error, scheduler);
      };
      Observable.using = function(resourceFactory, observableFactory) {
        return new AnonymousObservable(function(o) {
          var disposable = disposableEmpty;
          var resource = tryCatch(resourceFactory)();
          if (resource === errorObj) {
            return new CompositeDisposable(observableThrow(resource.e).subscribe(o), disposable);
          }
          resource && (disposable = resource);
          var source = tryCatch(observableFactory)(resource);
          if (source === errorObj) {
            return new CompositeDisposable(observableThrow(source.e).subscribe(o), disposable);
          }
          return new CompositeDisposable(source.subscribe(o), disposable);
        });
      };
      observableProto.amb = function(rightSource) {
        var leftSource = this;
        return new AnonymousObservable(function(observer) {
          var choice,
              leftChoice = 'L',
              rightChoice = 'R',
              leftSubscription = new SingleAssignmentDisposable(),
              rightSubscription = new SingleAssignmentDisposable();
          isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));
          function choiceL() {
            if (!choice) {
              choice = leftChoice;
              rightSubscription.dispose();
            }
          }
          function choiceR() {
            if (!choice) {
              choice = rightChoice;
              leftSubscription.dispose();
            }
          }
          var leftSubscribe = observerCreate(function(left) {
            choiceL();
            choice === leftChoice && observer.onNext(left);
          }, function(e) {
            choiceL();
            choice === leftChoice && observer.onError(e);
          }, function() {
            choiceL();
            choice === leftChoice && observer.onCompleted();
          });
          var rightSubscribe = observerCreate(function(right) {
            choiceR();
            choice === rightChoice && observer.onNext(right);
          }, function(e) {
            choiceR();
            choice === rightChoice && observer.onError(e);
          }, function() {
            choiceR();
            choice === rightChoice && observer.onCompleted();
          });
          leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));
          rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));
          return new CompositeDisposable(leftSubscription, rightSubscription);
        });
      };
      function amb(p, c) {
        return p.amb(c);
      }
      Observable.amb = function() {
        var acc = observableNever(),
            items;
        if (Array.isArray(arguments[0])) {
          items = arguments[0];
        } else {
          var len = arguments.length;
          items = new Array(items);
          for (var i = 0; i < len; i++) {
            items[i] = arguments[i];
          }
        }
        for (var i = 0,
            len = items.length; i < len; i++) {
          acc = amb(acc, items[i]);
        }
        return acc;
      };
      var CatchObserver = (function(__super__) {
        inherits(CatchObserver, __super__);
        function CatchObserver(o, s, fn) {
          this._o = o;
          this._s = s;
          this._fn = fn;
          __super__.call(this);
        }
        CatchObserver.prototype.next = function(x) {
          this._o.onNext(x);
        };
        CatchObserver.prototype.completed = function() {
          return this._o.onCompleted();
        };
        CatchObserver.prototype.error = function(e) {
          var result = tryCatch(this._fn)(e);
          if (result === errorObj) {
            return this._o.onError(result.e);
          }
          isPromise(result) && (result = observableFromPromise(result));
          var d = new SingleAssignmentDisposable();
          this._s.setDisposable(d);
          d.setDisposable(result.subscribe(this._o));
        };
        return CatchObserver;
      }(AbstractObserver));
      function observableCatchHandler(source, handler) {
        return new AnonymousObservable(function(o) {
          var d1 = new SingleAssignmentDisposable(),
              subscription = new SerialDisposable();
          subscription.setDisposable(d1);
          d1.setDisposable(source.subscribe(new CatchObserver(o, subscription, handler)));
          return subscription;
        }, source);
      }
      observableProto['catch'] = function(handlerOrSecond) {
        return isFunction(handlerOrSecond) ? observableCatchHandler(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
      };
      var observableCatch = Observable['catch'] = function() {
        var items;
        if (Array.isArray(arguments[0])) {
          items = arguments[0];
        } else {
          var len = arguments.length;
          items = new Array(len);
          for (var i = 0; i < len; i++) {
            items[i] = arguments[i];
          }
        }
        return enumerableOf(items).catchError();
      };
      observableProto.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        if (Array.isArray(args[0])) {
          args[0].unshift(this);
        } else {
          args.unshift(this);
        }
        return combineLatest.apply(this, args);
      };
      var combineLatest = Observable.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var resultSelector = args.pop();
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(o) {
          var n = args.length,
              falseFactory = function() {
                return false;
              },
              hasValue = arrayInitialize(n, falseFactory),
              hasValueAll = false,
              isDone = arrayInitialize(n, falseFactory),
              values = new Array(n);
          function next(i) {
            hasValue[i] = true;
            if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
              try {
                var res = resultSelector.apply(null, values);
              } catch (e) {
                return o.onError(e);
              }
              o.onNext(res);
            } else if (isDone.filter(function(x, j) {
              return j !== i;
            }).every(identity)) {
              o.onCompleted();
            }
          }
          function done(i) {
            isDone[i] = true;
            isDone.every(identity) && o.onCompleted();
          }
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var source = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(source) && (source = observableFromPromise(source));
              sad.setDisposable(source.subscribe(function(x) {
                values[i] = x;
                next(i);
              }, function(e) {
                o.onError(e);
              }, function() {
                done(i);
              }));
              subscriptions[i] = sad;
            }(idx));
          }
          return new CompositeDisposable(subscriptions);
        }, this);
      };
      observableProto.concat = function() {
        for (var args = [],
            i = 0,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        args.unshift(this);
        return observableConcat.apply(null, args);
      };
      var ConcatObservable = (function(__super__) {
        inherits(ConcatObservable, __super__);
        function ConcatObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        ConcatObservable.prototype.subscribeCore = function(o) {
          var sink = new ConcatSink(this.sources, o);
          return sink.run();
        };
        function ConcatSink(sources, o) {
          this.sources = sources;
          this.o = o;
        }
        ConcatSink.prototype.run = function() {
          var isDisposed,
              subscription = new SerialDisposable(),
              sources = this.sources,
              length = sources.length,
              o = this.o;
          var cancelable = immediateScheduler.scheduleRecursiveWithState(0, function(i, self) {
            if (isDisposed) {
              return;
            }
            if (i === length) {
              return o.onCompleted();
            }
            var currentValue = sources[i];
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              o.onError(e);
            }, function() {
              self(i + 1);
            }));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        return ConcatObservable;
      }(ObservableBase));
      var observableConcat = Observable.concat = function() {
        var args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(arguments.length);
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new ConcatObservable(args);
      };
      observableProto.concatAll = function() {
        return this.merge(1);
      };
      var MergeObservable = (function(__super__) {
        inherits(MergeObservable, __super__);
        function MergeObservable(source, maxConcurrent) {
          this.source = source;
          this.maxConcurrent = maxConcurrent;
          __super__.call(this);
        }
        MergeObservable.prototype.subscribeCore = function(observer) {
          var g = new CompositeDisposable();
          g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
          return g;
        };
        return MergeObservable;
      }(ObservableBase));
      var MergeObserver = (function() {
        function MergeObserver(o, max, g) {
          this.o = o;
          this.max = max;
          this.g = g;
          this.done = false;
          this.q = [];
          this.activeCount = 0;
          this.isStopped = false;
        }
        MergeObserver.prototype.handleSubscribe = function(xs) {
          var sad = new SingleAssignmentDisposable();
          this.g.add(sad);
          isPromise(xs) && (xs = observableFromPromise(xs));
          sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
        };
        MergeObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return;
          }
          if (this.activeCount < this.max) {
            this.activeCount++;
            this.handleSubscribe(innerSource);
          } else {
            this.q.push(innerSource);
          }
        };
        MergeObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        MergeObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.done = true;
            this.activeCount === 0 && this.o.onCompleted();
          }
        };
        MergeObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        MergeObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, sad) {
          this.parent = parent;
          this.sad = sad;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.parent.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            var parent = this.parent;
            parent.g.remove(this.sad);
            if (parent.q.length > 0) {
              parent.handleSubscribe(parent.q.shift());
            } else {
              parent.activeCount--;
              parent.done && parent.activeCount === 0 && parent.o.onCompleted();
            }
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return MergeObserver;
      }());
      observableProto.merge = function(maxConcurrentOrOther) {
        return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
      };
      var observableMerge = Observable.merge = function() {
        var scheduler,
            sources = [],
            i,
            len = arguments.length;
        if (!arguments[0]) {
          scheduler = immediateScheduler;
          for (i = 1; i < len; i++) {
            sources.push(arguments[i]);
          }
        } else if (isScheduler(arguments[0])) {
          scheduler = arguments[0];
          for (i = 1; i < len; i++) {
            sources.push(arguments[i]);
          }
        } else {
          scheduler = immediateScheduler;
          for (i = 0; i < len; i++) {
            sources.push(arguments[i]);
          }
        }
        if (Array.isArray(sources[0])) {
          sources = sources[0];
        }
        return observableOf(scheduler, sources).mergeAll();
      };
      var CompositeError = Rx.CompositeError = function(errors) {
        this.name = "NotImplementedError";
        this.innerErrors = errors;
        this.message = 'This contains multiple errors. Check the innerErrors';
        Error.call(this);
      };
      CompositeError.prototype = Error.prototype;
      Observable.mergeDelayError = function() {
        var args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          var len = arguments.length;
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        var source = observableOf(null, args);
        return new AnonymousObservable(function(o) {
          var group = new CompositeDisposable(),
              m = new SingleAssignmentDisposable(),
              isStopped = false,
              errors = [];
          function setCompletion() {
            if (errors.length === 0) {
              o.onCompleted();
            } else if (errors.length === 1) {
              o.onError(errors[0]);
            } else {
              o.onError(new CompositeError(errors));
            }
          }
          group.add(m);
          m.setDisposable(source.subscribe(function(innerSource) {
            var innerSubscription = new SingleAssignmentDisposable();
            group.add(innerSubscription);
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            innerSubscription.setDisposable(innerSource.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              errors.push(e);
              group.remove(innerSubscription);
              isStopped && group.length === 1 && setCompletion();
            }, function() {
              group.remove(innerSubscription);
              isStopped && group.length === 1 && setCompletion();
            }));
          }, function(e) {
            errors.push(e);
            isStopped = true;
            group.length === 1 && setCompletion();
          }, function() {
            isStopped = true;
            group.length === 1 && setCompletion();
          }));
          return group;
        });
      };
      var MergeAllObservable = (function(__super__) {
        inherits(MergeAllObservable, __super__);
        function MergeAllObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        MergeAllObservable.prototype.subscribeCore = function(observer) {
          var g = new CompositeDisposable(),
              m = new SingleAssignmentDisposable();
          g.add(m);
          m.setDisposable(this.source.subscribe(new MergeAllObserver(observer, g)));
          return g;
        };
        function MergeAllObserver(o, g) {
          this.o = o;
          this.g = g;
          this.isStopped = false;
          this.done = false;
        }
        MergeAllObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return;
          }
          var sad = new SingleAssignmentDisposable();
          this.g.add(sad);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          sad.setDisposable(innerSource.subscribe(new InnerObserver(this, sad)));
        };
        MergeAllObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        MergeAllObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.done = true;
            this.g.length === 1 && this.o.onCompleted();
          }
        };
        MergeAllObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        MergeAllObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, sad) {
          this.parent = parent;
          this.sad = sad;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.parent.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            var parent = this.parent;
            this.isStopped = true;
            parent.g.remove(this.sad);
            parent.done && parent.g.length === 1 && parent.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return MergeAllObservable;
      }(ObservableBase));
      observableProto.mergeAll = function() {
        return new MergeAllObservable(this);
      };
      observableProto.onErrorResumeNext = function(second) {
        if (!second) {
          throw new Error('Second observable is required');
        }
        return onErrorResumeNext([this, second]);
      };
      var onErrorResumeNext = Observable.onErrorResumeNext = function() {
        var sources = [];
        if (Array.isArray(arguments[0])) {
          sources = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            sources.push(arguments[i]);
          }
        }
        return new AnonymousObservable(function(observer) {
          var pos = 0,
              subscription = new SerialDisposable(),
              cancelable = immediateScheduler.scheduleRecursive(function(self) {
                var current,
                    d;
                if (pos < sources.length) {
                  current = sources[pos++];
                  isPromise(current) && (current = observableFromPromise(current));
                  d = new SingleAssignmentDisposable();
                  subscription.setDisposable(d);
                  d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self));
                } else {
                  observer.onCompleted();
                }
              });
          return new CompositeDisposable(subscription, cancelable);
        });
      };
      observableProto.skipUntil = function(other) {
        var source = this;
        return new AnonymousObservable(function(o) {
          var isOpen = false;
          var disposables = new CompositeDisposable(source.subscribe(function(left) {
            isOpen && o.onNext(left);
          }, function(e) {
            o.onError(e);
          }, function() {
            isOpen && o.onCompleted();
          }));
          isPromise(other) && (other = observableFromPromise(other));
          var rightSubscription = new SingleAssignmentDisposable();
          disposables.add(rightSubscription);
          rightSubscription.setDisposable(other.subscribe(function() {
            isOpen = true;
            rightSubscription.dispose();
          }, function(e) {
            o.onError(e);
          }, function() {
            rightSubscription.dispose();
          }));
          return disposables;
        }, source);
      };
      var SwitchObservable = (function(__super__) {
        inherits(SwitchObservable, __super__);
        function SwitchObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        SwitchObservable.prototype.subscribeCore = function(o) {
          var inner = new SerialDisposable(),
              s = this.source.subscribe(new SwitchObserver(o, inner));
          return new CompositeDisposable(s, inner);
        };
        function SwitchObserver(o, inner) {
          this.o = o;
          this.inner = inner;
          this.stopped = false;
          this.latest = 0;
          this.hasLatest = false;
          this.isStopped = false;
        }
        SwitchObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return;
          }
          var d = new SingleAssignmentDisposable(),
              id = ++this.latest;
          this.hasLatest = true;
          this.inner.setDisposable(d);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));
        };
        SwitchObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        SwitchObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.stopped = true;
            !this.hasLatest && this.o.onCompleted();
          }
        };
        SwitchObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        SwitchObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, id) {
          this.parent = parent;
          this.id = id;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          this.parent.latest === this.id && this.parent.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.latest === this.id && this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            if (this.parent.latest === this.id) {
              this.parent.hasLatest = false;
              this.parent.isStopped && this.parent.o.onCompleted();
            }
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return SwitchObservable;
      }(ObservableBase));
      observableProto['switch'] = observableProto.switchLatest = function() {
        return new SwitchObservable(this);
      };
      var TakeUntilObservable = (function(__super__) {
        inherits(TakeUntilObservable, __super__);
        function TakeUntilObservable(source, other) {
          this.source = source;
          this.other = isPromise(other) ? observableFromPromise(other) : other;
          __super__.call(this);
        }
        TakeUntilObservable.prototype.subscribeCore = function(o) {
          return new CompositeDisposable(this.source.subscribe(o), this.other.subscribe(new InnerObserver(o)));
        };
        function InnerObserver(o) {
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          this.o.onCompleted();
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          !this.isStopped && (this.isStopped = true);
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return TakeUntilObservable;
      }(ObservableBase));
      observableProto.takeUntil = function(other) {
        return new TakeUntilObservable(this, other);
      };
      function falseFactory() {
        return false;
      }
      observableProto.withLatestFrom = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var resultSelector = args.pop(),
            source = this;
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(observer) {
          var n = args.length,
              hasValue = arrayInitialize(n, falseFactory),
              hasValueAll = false,
              values = new Array(n);
          var subscriptions = new Array(n + 1);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var other = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(other) && (other = observableFromPromise(other));
              sad.setDisposable(other.subscribe(function(x) {
                values[i] = x;
                hasValue[i] = true;
                hasValueAll = hasValue.every(identity);
              }, function(e) {
                observer.onError(e);
              }, noop));
              subscriptions[i] = sad;
            }(idx));
          }
          var sad = new SingleAssignmentDisposable();
          sad.setDisposable(source.subscribe(function(x) {
            var allValues = [x].concat(values);
            if (!hasValueAll) {
              return;
            }
            var res = tryCatch(resultSelector).apply(null, allValues);
            if (res === errorObj) {
              return observer.onError(res.e);
            }
            observer.onNext(res);
          }, function(e) {
            observer.onError(e);
          }, function() {
            observer.onCompleted();
          }));
          subscriptions[n] = sad;
          return new CompositeDisposable(subscriptions);
        }, this);
      };
      function zipArray(second, resultSelector) {
        var first = this;
        return new AnonymousObservable(function(o) {
          var index = 0,
              len = second.length;
          return first.subscribe(function(left) {
            if (index < len) {
              var right = second[index++],
                  res = tryCatch(resultSelector)(left, right);
              if (res === errorObj) {
                return o.onError(res.e);
              }
              o.onNext(res);
            } else {
              o.onCompleted();
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, first);
      }
      function falseFactory() {
        return false;
      }
      function emptyArrayFactory() {
        return [];
      }
      observableProto.zip = function() {
        if (Array.isArray(arguments[0])) {
          return zipArray.apply(this, arguments);
        }
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var parent = this,
            resultSelector = args.pop();
        args.unshift(parent);
        return new AnonymousObservable(function(o) {
          var n = args.length,
              queues = arrayInitialize(n, emptyArrayFactory),
              isDone = arrayInitialize(n, falseFactory);
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var source = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(source) && (source = observableFromPromise(source));
              sad.setDisposable(source.subscribe(function(x) {
                queues[i].push(x);
                if (queues.every(function(x) {
                  return x.length > 0;
                })) {
                  var queuedValues = queues.map(function(x) {
                    return x.shift();
                  }),
                      res = tryCatch(resultSelector).apply(parent, queuedValues);
                  if (res === errorObj) {
                    return o.onError(res.e);
                  }
                  o.onNext(res);
                } else if (isDone.filter(function(x, j) {
                  return j !== i;
                }).every(identity)) {
                  o.onCompleted();
                }
              }, function(e) {
                o.onError(e);
              }, function() {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
              }));
              subscriptions[i] = sad;
            })(idx);
          }
          return new CompositeDisposable(subscriptions);
        }, parent);
      };
      Observable.zip = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var first = args.shift();
        return first.zip.apply(first, args);
      };
      function falseFactory() {
        return false;
      }
      function arrayFactory() {
        return [];
      }
      Observable.zipArray = function() {
        var sources;
        if (Array.isArray(arguments[0])) {
          sources = arguments[0];
        } else {
          var len = arguments.length;
          sources = new Array(len);
          for (var i = 0; i < len; i++) {
            sources[i] = arguments[i];
          }
        }
        return new AnonymousObservable(function(o) {
          var n = sources.length,
              queues = arrayInitialize(n, arrayFactory),
              isDone = arrayInitialize(n, falseFactory);
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              subscriptions[i] = new SingleAssignmentDisposable();
              subscriptions[i].setDisposable(sources[i].subscribe(function(x) {
                queues[i].push(x);
                if (queues.every(function(x) {
                  return x.length > 0;
                })) {
                  var res = queues.map(function(x) {
                    return x.shift();
                  });
                  o.onNext(res);
                } else if (isDone.filter(function(x, j) {
                  return j !== i;
                }).every(identity)) {
                  return o.onCompleted();
                }
              }, function(e) {
                o.onError(e);
              }, function() {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
              }));
            })(idx);
          }
          return new CompositeDisposable(subscriptions);
        });
      };
      function asObservable(source) {
        return function subscribe(o) {
          return source.subscribe(o);
        };
      }
      observableProto.asObservable = function() {
        return new AnonymousObservable(asObservable(this), this);
      };
      function toArray(x) {
        return x.toArray();
      }
      function notEmpty(x) {
        return x.length > 0;
      }
      observableProto.bufferWithCount = function(count, skip) {
        typeof skip !== 'number' && (skip = count);
        return this.windowWithCount(count, skip).flatMap(toArray).filter(notEmpty);
      };
      observableProto.dematerialize = function() {
        var source = this;
        return new AnonymousObservable(function(o) {
          return source.subscribe(function(x) {
            return x.accept(o);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      var DistinctUntilChangedObservable = (function(__super__) {
        inherits(DistinctUntilChangedObservable, __super__);
        function DistinctUntilChangedObservable(source, keyFn, comparer) {
          this.source = source;
          this.keyFn = keyFn;
          this.comparer = comparer;
          __super__.call(this);
        }
        DistinctUntilChangedObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new DistinctUntilChangedObserver(o, this.keyFn, this.comparer));
        };
        return DistinctUntilChangedObservable;
      }(ObservableBase));
      function DistinctUntilChangedObserver(o, keyFn, comparer) {
        this.o = o;
        this.keyFn = keyFn;
        this.comparer = comparer;
        this.hasCurrentKey = false;
        this.currentKey = null;
        this.isStopped = false;
      }
      DistinctUntilChangedObserver.prototype.onNext = function(x) {
        if (this.isStopped) {
          return;
        }
        var key = x;
        if (isFunction(this.keyFn)) {
          key = tryCatch(this.keyFn)(x);
          if (key === errorObj) {
            return this.o.onError(key.e);
          }
        }
        if (this.hasCurrentKey) {
          comparerEquals = tryCatch(this.comparer)(this.currentKey, key);
          if (comparerEquals === errorObj) {
            return this.o.onError(comparerEquals.e);
          }
        }
        if (!this.hasCurrentKey || !comparerEquals) {
          this.hasCurrentKey = true;
          this.currentKey = key;
          this.o.onNext(x);
        }
      };
      DistinctUntilChangedObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      DistinctUntilChangedObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onCompleted();
        }
      };
      DistinctUntilChangedObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      DistinctUntilChangedObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      observableProto.distinctUntilChanged = function(keyFn, comparer) {
        comparer || (comparer = defaultComparer);
        return new DistinctUntilChangedObservable(this, keyFn, comparer);
      };
      var TapObservable = (function(__super__) {
        inherits(TapObservable, __super__);
        function TapObservable(source, observerOrOnNext, onError, onCompleted) {
          this.source = source;
          this._oN = observerOrOnNext;
          this._oE = onError;
          this._oC = onCompleted;
          __super__.call(this);
        }
        TapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this));
        };
        function InnerObserver(o, p) {
          this.o = o;
          this.t = !p._oN || isFunction(p._oN) ? observerCreate(p._oN || noop, p._oE || noop, p._oC || noop) : p._oN;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          var res = tryCatch(this.t.onNext).call(this.t, x);
          if (res === errorObj) {
            this.o.onError(res.e);
          }
          this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            var res = tryCatch(this.t.onError).call(this.t, err);
            if (res === errorObj) {
              return this.o.onError(res.e);
            }
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            var res = tryCatch(this.t.onCompleted).call(this.t);
            if (res === errorObj) {
              return this.o.onError(res.e);
            }
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return TapObservable;
      }(ObservableBase));
      observableProto['do'] = observableProto.tap = observableProto.doAction = function(observerOrOnNext, onError, onCompleted) {
        return new TapObservable(this, observerOrOnNext, onError, onCompleted);
      };
      observableProto.doOnNext = observableProto.tapOnNext = function(onNext, thisArg) {
        return this.tap(typeof thisArg !== 'undefined' ? function(x) {
          onNext.call(thisArg, x);
        } : onNext);
      };
      observableProto.doOnError = observableProto.tapOnError = function(onError, thisArg) {
        return this.tap(noop, typeof thisArg !== 'undefined' ? function(e) {
          onError.call(thisArg, e);
        } : onError);
      };
      observableProto.doOnCompleted = observableProto.tapOnCompleted = function(onCompleted, thisArg) {
        return this.tap(noop, null, typeof thisArg !== 'undefined' ? function() {
          onCompleted.call(thisArg);
        } : onCompleted);
      };
      observableProto['finally'] = function(action) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var subscription = tryCatch(source.subscribe).call(source, observer);
          if (subscription === errorObj) {
            action();
            return thrower(subscription.e);
          }
          return disposableCreate(function() {
            var r = tryCatch(subscription.dispose).call(subscription);
            action();
            r === errorObj && thrower(r.e);
          });
        }, this);
      };
      var IgnoreElementsObservable = (function(__super__) {
        inherits(IgnoreElementsObservable, __super__);
        function IgnoreElementsObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        IgnoreElementsObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = noop;
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onError(e);
            return true;
          }
          return false;
        };
        return IgnoreElementsObservable;
      }(ObservableBase));
      observableProto.ignoreElements = function() {
        return new IgnoreElementsObservable(this);
      };
      observableProto.materialize = function() {
        var source = this;
        return new AnonymousObservable(function(observer) {
          return source.subscribe(function(value) {
            observer.onNext(notificationCreateOnNext(value));
          }, function(e) {
            observer.onNext(notificationCreateOnError(e));
            observer.onCompleted();
          }, function() {
            observer.onNext(notificationCreateOnCompleted());
            observer.onCompleted();
          });
        }, source);
      };
      observableProto.repeat = function(repeatCount) {
        return enumerableRepeat(this, repeatCount).concat();
      };
      observableProto.retry = function(retryCount) {
        return enumerableRepeat(this, retryCount).catchError();
      };
      observableProto.retryWhen = function(notifier) {
        return enumerableRepeat(this).catchErrorWhen(notifier);
      };
      var ScanObservable = (function(__super__) {
        inherits(ScanObservable, __super__);
        function ScanObservable(source, accumulator, hasSeed, seed) {
          this.source = source;
          this.accumulator = accumulator;
          this.hasSeed = hasSeed;
          this.seed = seed;
          __super__.call(this);
        }
        ScanObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this));
        };
        return ScanObservable;
      }(ObservableBase));
      function InnerObserver(o, parent) {
        this.o = o;
        this.accumulator = parent.accumulator;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.accumulation = null;
        this.hasValue = false;
        this.isStopped = false;
      }
      InnerObserver.prototype = {
        onNext: function(x) {
          if (this.isStopped) {
            return;
          }
          !this.hasValue && (this.hasValue = true);
          if (this.hasAccumulation) {
            this.accumulation = tryCatch(this.accumulator)(this.accumulation, x);
          } else {
            this.accumulation = this.hasSeed ? tryCatch(this.accumulator)(this.seed, x) : x;
            this.hasAccumulation = true;
          }
          if (this.accumulation === errorObj) {
            return this.o.onError(this.accumulation.e);
          }
          this.o.onNext(this.accumulation);
        },
        onError: function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        },
        onCompleted: function() {
          if (!this.isStopped) {
            this.isStopped = true;
            !this.hasValue && this.hasSeed && this.o.onNext(this.seed);
            this.o.onCompleted();
          }
        },
        dispose: function() {
          this.isStopped = true;
        },
        fail: function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        }
      };
      observableProto.scan = function() {
        var hasSeed = false,
            seed,
            accumulator = arguments[0];
        if (arguments.length === 2) {
          hasSeed = true;
          seed = arguments[1];
        }
        return new ScanObservable(this, accumulator, hasSeed, seed);
      };
      observableProto.skipLast = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && o.onNext(q.shift());
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.startWith = function() {
        var values,
            scheduler,
            start = 0;
        if (!!arguments.length && isScheduler(arguments[0])) {
          scheduler = arguments[0];
          start = 1;
        } else {
          scheduler = immediateScheduler;
        }
        for (var args = [],
            i = start,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        return enumerableOf([observableFromArray(args, scheduler), this]).concat();
      };
      observableProto.takeLast = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && q.shift();
          }, function(e) {
            o.onError(e);
          }, function() {
            while (q.length > 0) {
              o.onNext(q.shift());
            }
            o.onCompleted();
          });
        }, source);
      };
      observableProto.takeLastBuffer = function(count) {
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && q.shift();
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onNext(q);
            o.onCompleted();
          });
        }, source);
      };
      observableProto.windowWithCount = function(count, skip) {
        var source = this;
        +count || (count = 0);
        Math.abs(count) === Infinity && (count = 0);
        if (count <= 0) {
          throw new ArgumentOutOfRangeError();
        }
        skip == null && (skip = count);
        +skip || (skip = 0);
        Math.abs(skip) === Infinity && (skip = 0);
        if (skip <= 0) {
          throw new ArgumentOutOfRangeError();
        }
        return new AnonymousObservable(function(observer) {
          var m = new SingleAssignmentDisposable(),
              refCountDisposable = new RefCountDisposable(m),
              n = 0,
              q = [];
          function createWindow() {
            var s = new Subject();
            q.push(s);
            observer.onNext(addRef(s, refCountDisposable));
          }
          createWindow();
          m.setDisposable(source.subscribe(function(x) {
            for (var i = 0,
                len = q.length; i < len; i++) {
              q[i].onNext(x);
            }
            var c = n - count + 1;
            c >= 0 && c % skip === 0 && q.shift().onCompleted();
            ++n % skip === 0 && createWindow();
          }, function(e) {
            while (q.length > 0) {
              q.shift().onError(e);
            }
            observer.onError(e);
          }, function() {
            while (q.length > 0) {
              q.shift().onCompleted();
            }
            observer.onCompleted();
          }));
          return refCountDisposable;
        }, source);
      };
      observableProto.flatMapConcat = observableProto.concatMap = function(selector, resultSelector, thisArg) {
        return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(1);
      };
      observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this,
            onNextFunc = bindCallback(onNext, thisArg, 2),
            onErrorFunc = bindCallback(onError, thisArg, 1),
            onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
        return new AnonymousObservable(function(observer) {
          var index = 0;
          return source.subscribe(function(x) {
            var result;
            try {
              result = onNextFunc(x, index++);
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
          }, function(err) {
            var result;
            try {
              result = onErrorFunc(err);
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          }, function() {
            var result;
            try {
              result = onCompletedFunc();
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          });
        }, this).concatAll();
      };
      observableProto.defaultIfEmpty = function(defaultValue) {
        var source = this;
        defaultValue === undefined && (defaultValue = null);
        return new AnonymousObservable(function(observer) {
          var found = false;
          return source.subscribe(function(x) {
            found = true;
            observer.onNext(x);
          }, function(e) {
            observer.onError(e);
          }, function() {
            !found && observer.onNext(defaultValue);
            observer.onCompleted();
          });
        }, source);
      };
      function arrayIndexOfComparer(array, item, comparer) {
        for (var i = 0,
            len = array.length; i < len; i++) {
          if (comparer(array[i], item)) {
            return i;
          }
        }
        return -1;
      }
      function HashSet(comparer) {
        this.comparer = comparer;
        this.set = [];
      }
      HashSet.prototype.push = function(value) {
        var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
        retValue && this.set.push(value);
        return retValue;
      };
      observableProto.distinct = function(keySelector, comparer) {
        var source = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
          var hashSet = new HashSet(comparer);
          return source.subscribe(function(x) {
            var key = x;
            if (keySelector) {
              try {
                key = keySelector(x);
              } catch (e) {
                o.onError(e);
                return;
              }
            }
            hashSet.push(key) && o.onNext(x);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      var MapObservable = (function(__super__) {
        inherits(MapObservable, __super__);
        function MapObservable(source, selector, thisArg) {
          this.source = source;
          this.selector = bindCallback(selector, thisArg, 3);
          __super__.call(this);
        }
        function innerMap(selector, self) {
          return function(x, i, o) {
            return selector.call(this, self.selector(x, i, o), i, o);
          };
        }
        MapObservable.prototype.internalMap = function(selector, thisArg) {
          return new MapObservable(this.source, innerMap(selector, this), thisArg);
        };
        MapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.selector, this));
        };
        function InnerObserver(o, selector, source) {
          this.o = o;
          this.selector = selector;
          this.source = source;
          this.i = 0;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          var result = tryCatch(this.selector)(x, this.i++, this.source);
          if (result === errorObj) {
            return this.o.onError(result.e);
          }
          this.o.onNext(result);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return MapObservable;
      }(ObservableBase));
      observableProto.map = observableProto.select = function(selector, thisArg) {
        var selectorFn = typeof selector === 'function' ? selector : function() {
          return selector;
        };
        return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
      };
      function plucker(args, len) {
        return function mapper(x) {
          var currentProp = x;
          for (var i = 0; i < len; i++) {
            var p = currentProp[args[i]];
            if (typeof p !== 'undefined') {
              currentProp = p;
            } else {
              return undefined;
            }
          }
          return currentProp;
        };
      }
      observableProto.pluck = function() {
        var len = arguments.length,
            args = new Array(len);
        if (len === 0) {
          throw new Error('List of properties cannot be empty.');
        }
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return this.map(plucker(args, len));
      };
      observableProto.flatMapObserver = observableProto.selectManyObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var index = 0;
          return source.subscribe(function(x) {
            var result;
            try {
              result = onNext.call(thisArg, x, index++);
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
          }, function(err) {
            var result;
            try {
              result = onError.call(thisArg, err);
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          }, function() {
            var result;
            try {
              result = onCompleted.call(thisArg);
            } catch (e) {
              observer.onError(e);
              return;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          });
        }, source).mergeAll();
      };
      observableProto.flatMap = observableProto.selectMany = function(selector, resultSelector, thisArg) {
        return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();
      };
      Rx.Observable.prototype.flatMapLatest = function(selector, resultSelector, thisArg) {
        return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();
      };
      var SkipObservable = (function(__super__) {
        inherits(SkipObservable, __super__);
        function SkipObservable(source, count) {
          this.source = source;
          this.skipCount = count;
          __super__.call(this);
        }
        SkipObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.skipCount));
        };
        function InnerObserver(o, c) {
          this.c = c;
          this.r = c;
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          if (this.r <= 0) {
            this.o.onNext(x);
          } else {
            this.r--;
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return SkipObservable;
      }(ObservableBase));
      observableProto.skip = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        return new SkipObservable(this, count);
      };
      observableProto.skipWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
          var i = 0,
              running = false;
          return source.subscribe(function(x) {
            if (!running) {
              try {
                running = !callback(x, i++, source);
              } catch (e) {
                o.onError(e);
                return;
              }
            }
            running && o.onNext(x);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.take = function(count, scheduler) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (count === 0) {
          return observableEmpty(scheduler);
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var remaining = count;
          return source.subscribe(function(x) {
            if (remaining-- > 0) {
              o.onNext(x);
              remaining <= 0 && o.onCompleted();
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.takeWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
          var i = 0,
              running = true;
          return source.subscribe(function(x) {
            if (running) {
              try {
                running = callback(x, i++, source);
              } catch (e) {
                o.onError(e);
                return;
              }
              if (running) {
                o.onNext(x);
              } else {
                o.onCompleted();
              }
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      var FilterObservable = (function(__super__) {
        inherits(FilterObservable, __super__);
        function FilterObservable(source, predicate, thisArg) {
          this.source = source;
          this.predicate = bindCallback(predicate, thisArg, 3);
          __super__.call(this);
        }
        FilterObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.predicate, this));
        };
        function innerPredicate(predicate, self) {
          return function(x, i, o) {
            return self.predicate(x, i, o) && predicate.call(this, x, i, o);
          };
        }
        FilterObservable.prototype.internalFilter = function(predicate, thisArg) {
          return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);
        };
        function InnerObserver(o, predicate, source) {
          this.o = o;
          this.predicate = predicate;
          this.source = source;
          this.i = 0;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return;
          }
          var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);
          if (shouldYield === errorObj) {
            return this.o.onError(shouldYield.e);
          }
          shouldYield && this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return FilterObservable;
      }(ObservableBase));
      observableProto.filter = observableProto.where = function(predicate, thisArg) {
        return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
      };
      observableProto.transduce = function(transducer) {
        var source = this;
        function transformForObserver(o) {
          return {
            '@@transducer/init': function() {
              return o;
            },
            '@@transducer/step': function(obs, input) {
              return obs.onNext(input);
            },
            '@@transducer/result': function(obs) {
              return obs.onCompleted();
            }
          };
        }
        return new AnonymousObservable(function(o) {
          var xform = transducer(transformForObserver(o));
          return source.subscribe(function(v) {
            var res = tryCatch(xform['@@transducer/step']).call(xform, o, v);
            if (res === errorObj) {
              o.onError(res.e);
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            xform['@@transducer/result'](o);
          });
        }, source);
      };
      var AnonymousObservable = Rx.AnonymousObservable = (function(__super__) {
        inherits(AnonymousObservable, __super__);
        function fixSubscriber(subscriber) {
          return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
          var ado = state[0],
              self = state[1];
          var sub = tryCatch(self.__subscribe).call(self, ado);
          if (sub === errorObj) {
            if (!ado.fail(errorObj.e)) {
              return thrower(errorObj.e);
            }
          }
          ado.setDisposable(fixSubscriber(sub));
        }
        function innerSubscribe(observer) {
          var ado = new AutoDetachObserver(observer),
              state = [ado, this];
          if (currentThreadScheduler.scheduleRequired()) {
            currentThreadScheduler.scheduleWithState(state, setDisposable);
          } else {
            setDisposable(null, state);
          }
          return ado;
        }
        function AnonymousObservable(subscribe, parent) {
          this.source = parent;
          this.__subscribe = subscribe;
          __super__.call(this, innerSubscribe);
        }
        return AnonymousObservable;
      }(Observable));
      var AutoDetachObserver = (function(__super__) {
        inherits(AutoDetachObserver, __super__);
        function AutoDetachObserver(observer) {
          __super__.call(this);
          this.observer = observer;
          this.m = new SingleAssignmentDisposable();
        }
        var AutoDetachObserverPrototype = AutoDetachObserver.prototype;
        AutoDetachObserverPrototype.next = function(value) {
          var result = tryCatch(this.observer.onNext).call(this.observer, value);
          if (result === errorObj) {
            this.dispose();
            thrower(result.e);
          }
        };
        AutoDetachObserverPrototype.error = function(err) {
          var result = tryCatch(this.observer.onError).call(this.observer, err);
          this.dispose();
          result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.completed = function() {
          var result = tryCatch(this.observer.onCompleted).call(this.observer);
          this.dispose();
          result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.setDisposable = function(value) {
          this.m.setDisposable(value);
        };
        AutoDetachObserverPrototype.getDisposable = function() {
          return this.m.getDisposable();
        };
        AutoDetachObserverPrototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this.m.dispose();
        };
        return AutoDetachObserver;
      }(AbstractObserver));
      var InnerSubscription = function(subject, observer) {
        this.subject = subject;
        this.observer = observer;
      };
      InnerSubscription.prototype.dispose = function() {
        if (!this.subject.isDisposed && this.observer !== null) {
          var idx = this.subject.observers.indexOf(this.observer);
          this.subject.observers.splice(idx, 1);
          this.observer = null;
        }
      };
      var Subject = Rx.Subject = (function(__super__) {
        function subscribe(observer) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.observers.push(observer);
            return new InnerSubscription(this, observer);
          }
          if (this.hasError) {
            observer.onError(this.error);
            return disposableEmpty;
          }
          observer.onCompleted();
          return disposableEmpty;
        }
        inherits(Subject, __super__);
        function Subject() {
          __super__.call(this, subscribe);
          this.isDisposed = false, this.isStopped = false, this.observers = [];
          this.hasError = false;
        }
        addProperties(Subject.prototype, Observer.prototype, {
          hasObservers: function() {
            return this.observers.length > 0;
          },
          onCompleted: function() {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onCompleted();
              }
              this.observers.length = 0;
            }
          },
          onError: function(error) {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              this.error = error;
              this.hasError = true;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onError(error);
              }
              this.observers.length = 0;
            }
          },
          onNext: function(value) {
            checkDisposed(this);
            if (!this.isStopped) {
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onNext(value);
              }
            }
          },
          dispose: function() {
            this.isDisposed = true;
            this.observers = null;
          }
        });
        Subject.create = function(observer, observable) {
          return new AnonymousSubject(observer, observable);
        };
        return Subject;
      }(Observable));
      var AsyncSubject = Rx.AsyncSubject = (function(__super__) {
        function subscribe(observer) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.observers.push(observer);
            return new InnerSubscription(this, observer);
          }
          if (this.hasError) {
            observer.onError(this.error);
          } else if (this.hasValue) {
            observer.onNext(this.value);
            observer.onCompleted();
          } else {
            observer.onCompleted();
          }
          return disposableEmpty;
        }
        inherits(AsyncSubject, __super__);
        function AsyncSubject() {
          __super__.call(this, subscribe);
          this.isDisposed = false;
          this.isStopped = false;
          this.hasValue = false;
          this.observers = [];
          this.hasError = false;
        }
        addProperties(AsyncSubject.prototype, Observer, {
          hasObservers: function() {
            checkDisposed(this);
            return this.observers.length > 0;
          },
          onCompleted: function() {
            var i,
                len;
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              var os = cloneArray(this.observers),
                  len = os.length;
              if (this.hasValue) {
                for (i = 0; i < len; i++) {
                  var o = os[i];
                  o.onNext(this.value);
                  o.onCompleted();
                }
              } else {
                for (i = 0; i < len; i++) {
                  os[i].onCompleted();
                }
              }
              this.observers.length = 0;
            }
          },
          onError: function(error) {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              this.hasError = true;
              this.error = error;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onError(error);
              }
              this.observers.length = 0;
            }
          },
          onNext: function(value) {
            checkDisposed(this);
            if (this.isStopped) {
              return;
            }
            this.value = value;
            this.hasValue = true;
          },
          dispose: function() {
            this.isDisposed = true;
            this.observers = null;
            this.exception = null;
            this.value = null;
          }
        });
        return AsyncSubject;
      }(Observable));
      var AnonymousSubject = Rx.AnonymousSubject = (function(__super__) {
        inherits(AnonymousSubject, __super__);
        function subscribe(observer) {
          return this.observable.subscribe(observer);
        }
        function AnonymousSubject(observer, observable) {
          this.observer = observer;
          this.observable = observable;
          __super__.call(this, subscribe);
        }
        addProperties(AnonymousSubject.prototype, Observer.prototype, {
          onCompleted: function() {
            this.observer.onCompleted();
          },
          onError: function(error) {
            this.observer.onError(error);
          },
          onNext: function(value) {
            this.observer.onNext(value);
          }
        });
        return AnonymousSubject;
      }(Observable));
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root.Rx = Rx;
        define(function() {
          return Rx;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = Rx).Rx = Rx;
        } else {
          freeExports.Rx = Rx;
        }
      } else {
        root.Rx = Rx;
      }
      var rEndingLine = captureLine();
    }.call(this));
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.virtualtime.js", ["npm:rx@3.0.1/dist/rx.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(['rx'], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Scheduler = Rx.Scheduler,
        ScheduledItem = Rx.internals.ScheduledItem,
        SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive,
        disposableEmpty = Rx.Disposable.empty,
        inherits = Rx.internals.inherits,
        defaultSubComparer = Rx.helpers.defaultSubComparer,
        notImplemented = Rx.helpers.notImplemented;
    function IndexedItem(id, value) {
      this.id = id;
      this.value = value;
    }
    IndexedItem.prototype.compareTo = function(other) {
      var c = this.value.compareTo(other.value);
      c === 0 && (c = this.id - other.id);
      return c;
    };
    var PriorityQueue = Rx.internals.PriorityQueue = function(capacity) {
      this.items = new Array(capacity);
      this.length = 0;
    };
    var priorityProto = PriorityQueue.prototype;
    priorityProto.isHigherPriority = function(left, right) {
      return this.items[left].compareTo(this.items[right]) < 0;
    };
    priorityProto.percolate = function(index) {
      if (index >= this.length || index < 0) {
        return;
      }
      var parent = index - 1 >> 1;
      if (parent < 0 || parent === index) {
        return;
      }
      if (this.isHigherPriority(index, parent)) {
        var temp = this.items[index];
        this.items[index] = this.items[parent];
        this.items[parent] = temp;
        this.percolate(parent);
      }
    };
    priorityProto.heapify = function(index) {
      +index || (index = 0);
      if (index >= this.length || index < 0) {
        return;
      }
      var left = 2 * index + 1,
          right = 2 * index + 2,
          first = index;
      if (left < this.length && this.isHigherPriority(left, first)) {
        first = left;
      }
      if (right < this.length && this.isHigherPriority(right, first)) {
        first = right;
      }
      if (first !== index) {
        var temp = this.items[index];
        this.items[index] = this.items[first];
        this.items[first] = temp;
        this.heapify(first);
      }
    };
    priorityProto.peek = function() {
      return this.items[0].value;
    };
    priorityProto.removeAt = function(index) {
      this.items[index] = this.items[--this.length];
      this.items[this.length] = undefined;
      this.heapify();
    };
    priorityProto.dequeue = function() {
      var result = this.peek();
      this.removeAt(0);
      return result;
    };
    priorityProto.enqueue = function(item) {
      var index = this.length++;
      this.items[index] = new IndexedItem(PriorityQueue.count++, item);
      this.percolate(index);
    };
    priorityProto.remove = function(item) {
      for (var i = 0; i < this.length; i++) {
        if (this.items[i].value === item) {
          this.removeAt(i);
          return true;
        }
      }
      return false;
    };
    PriorityQueue.count = 0;
    var VirtualTimeScheduler = Rx.VirtualTimeScheduler = (function(__super__) {
      function localNow() {
        return this.toDateTimeOffset(this.clock);
      }
      function scheduleNow(state, action) {
        return this.scheduleAbsoluteWithState(state, this.clock, action);
      }
      function scheduleRelative(state, dueTime, action) {
        return this.scheduleRelativeWithState(state, this.toRelative(dueTime), action);
      }
      function scheduleAbsolute(state, dueTime, action) {
        return this.scheduleRelativeWithState(state, this.toRelative(dueTime - this.now()), action);
      }
      function invokeAction(scheduler, action) {
        action();
        return disposableEmpty;
      }
      inherits(VirtualTimeScheduler, __super__);
      function VirtualTimeScheduler(initialClock, comparer) {
        this.clock = initialClock;
        this.comparer = comparer;
        this.isEnabled = false;
        this.queue = new PriorityQueue(1024);
        __super__.call(this, localNow, scheduleNow, scheduleRelative, scheduleAbsolute);
      }
      var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;
      VirtualTimeSchedulerPrototype.add = notImplemented;
      VirtualTimeSchedulerPrototype.toDateTimeOffset = notImplemented;
      VirtualTimeSchedulerPrototype.toRelative = notImplemented;
      VirtualTimeSchedulerPrototype.schedulePeriodicWithState = function(state, period, action) {
        var s = new SchedulePeriodicRecursive(this, state, period, action);
        return s.start();
      };
      VirtualTimeSchedulerPrototype.scheduleRelativeWithState = function(state, dueTime, action) {
        var runAt = this.add(this.clock, dueTime);
        return this.scheduleAbsoluteWithState(state, runAt, action);
      };
      VirtualTimeSchedulerPrototype.scheduleRelative = function(dueTime, action) {
        return this.scheduleRelativeWithState(action, dueTime, invokeAction);
      };
      VirtualTimeSchedulerPrototype.start = function() {
        if (!this.isEnabled) {
          this.isEnabled = true;
          do {
            var next = this.getNext();
            if (next !== null) {
              this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
              next.invoke();
            } else {
              this.isEnabled = false;
            }
          } while (this.isEnabled);
        }
      };
      VirtualTimeSchedulerPrototype.stop = function() {
        this.isEnabled = false;
      };
      VirtualTimeSchedulerPrototype.advanceTo = function(time) {
        var dueToClock = this.comparer(this.clock, time);
        if (this.comparer(this.clock, time) > 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (dueToClock === 0) {
          return;
        }
        if (!this.isEnabled) {
          this.isEnabled = true;
          do {
            var next = this.getNext();
            if (next !== null && this.comparer(next.dueTime, time) <= 0) {
              this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
              next.invoke();
            } else {
              this.isEnabled = false;
            }
          } while (this.isEnabled);
          this.clock = time;
        }
      };
      VirtualTimeSchedulerPrototype.advanceBy = function(time) {
        var dt = this.add(this.clock, time),
            dueToClock = this.comparer(this.clock, dt);
        if (dueToClock > 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (dueToClock === 0) {
          return;
        }
        this.advanceTo(dt);
      };
      VirtualTimeSchedulerPrototype.sleep = function(time) {
        var dt = this.add(this.clock, time);
        if (this.comparer(this.clock, dt) >= 0) {
          throw new ArgumentOutOfRangeError();
        }
        this.clock = dt;
      };
      VirtualTimeSchedulerPrototype.getNext = function() {
        while (this.queue.length > 0) {
          var next = this.queue.peek();
          if (next.isCancelled()) {
            this.queue.dequeue();
          } else {
            return next;
          }
        }
        return null;
      };
      VirtualTimeSchedulerPrototype.scheduleAbsolute = function(dueTime, action) {
        return this.scheduleAbsoluteWithState(action, dueTime, invokeAction);
      };
      VirtualTimeSchedulerPrototype.scheduleAbsoluteWithState = function(state, dueTime, action) {
        var self = this;
        function run(scheduler, state1) {
          self.queue.remove(si);
          return action(scheduler, state1);
        }
        var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
        this.queue.enqueue(si);
        return si.disposable;
      };
      return VirtualTimeScheduler;
    }(Scheduler));
    Rx.HistoricalScheduler = (function(__super__) {
      inherits(HistoricalScheduler, __super__);
      function HistoricalScheduler(initialClock, comparer) {
        var clock = initialClock == null ? 0 : initialClock;
        var cmp = comparer || defaultSubComparer;
        __super__.call(this, clock, cmp);
      }
      var HistoricalSchedulerProto = HistoricalScheduler.prototype;
      HistoricalSchedulerProto.add = function(absolute, relative) {
        return absolute + relative;
      };
      HistoricalSchedulerProto.toDateTimeOffset = function(absolute) {
        return new Date(absolute).getTime();
      };
      HistoricalSchedulerProto.toRelative = function(timeSpan) {
        return timeSpan;
      };
      return HistoricalScheduler;
    }(Rx.VirtualTimeScheduler));
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.testing.js", ["npm:rx@3.0.1/dist/rx.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(['rx.virtualtime', 'exports'], function(Rx, exports) {
        root.Rx = factory(root, exports, Rx);
        return root.Rx;
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observer = Rx.Observer,
        Observable = Rx.Observable,
        Notification = Rx.Notification,
        VirtualTimeScheduler = Rx.VirtualTimeScheduler,
        Disposable = Rx.Disposable,
        disposableEmpty = Disposable.empty,
        disposableCreate = Disposable.create,
        CompositeDisposable = Rx.CompositeDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        inherits = Rx.internals.inherits,
        defaultComparer = Rx.internals.isEqual;
    function OnNextPredicate(predicate) {
      this.predicate = predicate;
    }
    ;
    OnNextPredicate.prototype.equals = function(other) {
      if (other === this) {
        return true;
      }
      if (other == null) {
        return false;
      }
      if (other.kind !== 'N') {
        return false;
      }
      return this.predicate(other.value);
    };
    function OnErrorPredicate(predicate) {
      this.predicate = predicate;
    }
    ;
    OnErrorPredicate.prototype.equals = function(other) {
      if (other === this) {
        return true;
      }
      if (other == null) {
        return false;
      }
      if (other.kind !== 'E') {
        return false;
      }
      return this.predicate(other.exception);
    };
    var ReactiveTest = Rx.ReactiveTest = {
      created: 100,
      subscribed: 200,
      disposed: 1000,
      onNext: function(ticks, value) {
        return typeof value === 'function' ? new Recorded(ticks, new OnNextPredicate(value)) : new Recorded(ticks, Notification.createOnNext(value));
      },
      onError: function(ticks, error) {
        return typeof error === 'function' ? new Recorded(ticks, new OnErrorPredicate(error)) : new Recorded(ticks, Notification.createOnError(error));
      },
      onCompleted: function(ticks) {
        return new Recorded(ticks, Notification.createOnCompleted());
      },
      subscribe: function(start, end) {
        return new Subscription(start, end);
      }
    };
    var Recorded = Rx.Recorded = function(time, value, comparer) {
      this.time = time;
      this.value = value;
      this.comparer = comparer || defaultComparer;
    };
    Recorded.prototype.equals = function(other) {
      return this.time === other.time && this.comparer(this.value, other.value);
    };
    Recorded.prototype.toString = function() {
      return this.value.toString() + '@' + this.time;
    };
    var Subscription = Rx.Subscription = function(start, end) {
      this.subscribe = start;
      this.unsubscribe = end || Number.MAX_VALUE;
    };
    Subscription.prototype.equals = function(other) {
      return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;
    };
    Subscription.prototype.toString = function() {
      return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';
    };
    var MockDisposable = Rx.MockDisposable = function(scheduler) {
      this.scheduler = scheduler;
      this.disposes = [];
      this.disposes.push(this.scheduler.clock);
    };
    MockDisposable.prototype.dispose = function() {
      this.disposes.push(this.scheduler.clock);
    };
    var MockObserver = (function(__super__) {
      inherits(MockObserver, __super__);
      function MockObserver(scheduler) {
        __super__.call(this);
        this.scheduler = scheduler;
        this.messages = [];
      }
      var MockObserverPrototype = MockObserver.prototype;
      MockObserverPrototype.onNext = function(value) {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));
      };
      MockObserverPrototype.onError = function(exception) {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(exception)));
      };
      MockObserverPrototype.onCompleted = function() {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));
      };
      return MockObserver;
    })(Observer);
    function MockPromise(scheduler, messages) {
      var self = this;
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
      this.observers = [];
      for (var i = 0,
          len = this.messages.length; i < len; i++) {
        var message = this.messages[i],
            notification = message.value;
        (function(innerNotification) {
          scheduler.scheduleAbsoluteWithState(null, message.time, function() {
            var obs = self.observers.slice(0);
            for (var j = 0,
                jLen = obs.length; j < jLen; j++) {
              innerNotification.accept(obs[j]);
            }
            return disposableEmpty;
          });
        })(notification);
      }
    }
    MockPromise.prototype.then = function(onResolved, onRejected) {
      var self = this;
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      var newPromise;
      var observer = Rx.Observer.create(function(x) {
        var retValue = onResolved(x);
        if (retValue && typeof retValue.then === 'function') {
          newPromise = retValue;
        } else {
          var ticks = self.scheduler.clock;
          newPromise = new MockPromise(self.scheduler, [Rx.ReactiveTest.onNext(ticks, undefined), Rx.ReactiveTest.onCompleted(ticks)]);
        }
        var idx = self.observers.indexOf(observer);
        self.observers.splice(idx, 1);
        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
      }, function(err) {
        onRejected(err);
        var idx = self.observers.indexOf(observer);
        self.observers.splice(idx, 1);
        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
      });
      this.observers.push(observer);
      return newPromise || new MockPromise(this.scheduler, this.messages);
    };
    var HotObservable = (function(__super__) {
      function subscribe(observer) {
        var observable = this;
        this.observers.push(observer);
        this.subscriptions.push(new Subscription(this.scheduler.clock));
        var index = this.subscriptions.length - 1;
        return disposableCreate(function() {
          var idx = observable.observers.indexOf(observer);
          observable.observers.splice(idx, 1);
          observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
        });
      }
      inherits(HotObservable, __super__);
      function HotObservable(scheduler, messages) {
        __super__.call(this, subscribe);
        var message,
            notification,
            observable = this;
        this.scheduler = scheduler;
        this.messages = messages;
        this.subscriptions = [];
        this.observers = [];
        for (var i = 0,
            len = this.messages.length; i < len; i++) {
          message = this.messages[i];
          notification = message.value;
          (function(innerNotification) {
            scheduler.scheduleAbsoluteWithState(null, message.time, function() {
              var obs = observable.observers.slice(0);
              for (var j = 0,
                  jLen = obs.length; j < jLen; j++) {
                innerNotification.accept(obs[j]);
              }
              return disposableEmpty;
            });
          })(notification);
        }
      }
      return HotObservable;
    })(Observable);
    var ColdObservable = (function(__super__) {
      function subscribe(observer) {
        var message,
            notification,
            observable = this;
        this.subscriptions.push(new Subscription(this.scheduler.clock));
        var index = this.subscriptions.length - 1;
        var d = new CompositeDisposable();
        for (var i = 0,
            len = this.messages.length; i < len; i++) {
          message = this.messages[i];
          notification = message.value;
          (function(innerNotification) {
            d.add(observable.scheduler.scheduleRelativeWithState(null, message.time, function() {
              innerNotification.accept(observer);
              return disposableEmpty;
            }));
          })(notification);
        }
        return disposableCreate(function() {
          observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
          d.dispose();
        });
      }
      inherits(ColdObservable, __super__);
      function ColdObservable(scheduler, messages) {
        __super__.call(this, subscribe);
        this.scheduler = scheduler;
        this.messages = messages;
        this.subscriptions = [];
      }
      return ColdObservable;
    })(Observable);
    Rx.TestScheduler = (function(__super__) {
      inherits(TestScheduler, __super__);
      function baseComparer(x, y) {
        return x > y ? 1 : (x < y ? -1 : 0);
      }
      function TestScheduler() {
        __super__.call(this, 0, baseComparer);
      }
      TestScheduler.prototype.scheduleAbsoluteWithState = function(state, dueTime, action) {
        dueTime <= this.clock && (dueTime = this.clock + 1);
        return __super__.prototype.scheduleAbsoluteWithState.call(this, state, dueTime, action);
      };
      TestScheduler.prototype.add = function(absolute, relative) {
        return absolute + relative;
      };
      TestScheduler.prototype.toDateTimeOffset = function(absolute) {
        return new Date(absolute).getTime();
      };
      TestScheduler.prototype.toRelative = function(timeSpan) {
        return timeSpan;
      };
      TestScheduler.prototype.startWithTiming = function(create, created, subscribed, disposed) {
        var observer = this.createObserver(),
            source,
            subscription;
        this.scheduleAbsoluteWithState(null, created, function() {
          source = create();
          return disposableEmpty;
        });
        this.scheduleAbsoluteWithState(null, subscribed, function() {
          subscription = source.subscribe(observer);
          return disposableEmpty;
        });
        this.scheduleAbsoluteWithState(null, disposed, function() {
          subscription.dispose();
          return disposableEmpty;
        });
        this.start();
        return observer;
      };
      TestScheduler.prototype.startWithDispose = function(create, disposed) {
        return this.startWithTiming(create, ReactiveTest.created, ReactiveTest.subscribed, disposed);
      };
      TestScheduler.prototype.startWithCreate = function(create) {
        return this.startWithTiming(create, ReactiveTest.created, ReactiveTest.subscribed, ReactiveTest.disposed);
      };
      TestScheduler.prototype.createHotObservable = function() {
        var len = arguments.length,
            args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new HotObservable(this, args);
      };
      TestScheduler.prototype.createColdObservable = function() {
        var len = arguments.length,
            args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new ColdObservable(this, args);
      };
      TestScheduler.prototype.createResolvedPromise = function(ticks, value) {
        return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);
      };
      TestScheduler.prototype.createRejectedPromise = function(ticks, reason) {
        return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);
      };
      TestScheduler.prototype.createObserver = function() {
        return new MockObserver(this);
      };
      return TestScheduler;
    })(VirtualTimeScheduler);
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:rx@3.0.1/dist/rx.time.js", ["npm:rx@3.0.1/dist/rx.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(['rx'], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.1/dist/rx.js"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableDefer = Observable.defer,
        observableEmpty = Observable.empty,
        observableNever = Observable.never,
        observableThrow = Observable['throw'],
        observableFromArray = Observable.fromArray,
        timeoutScheduler = Rx.Scheduler['default'],
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        SerialDisposable = Rx.SerialDisposable,
        CompositeDisposable = Rx.CompositeDisposable,
        RefCountDisposable = Rx.RefCountDisposable,
        Subject = Rx.Subject,
        addRef = Rx.internals.addRef,
        normalizeTime = Rx.Scheduler.normalize,
        helpers = Rx.helpers,
        isPromise = helpers.isPromise,
        isFunction = helpers.isFunction,
        isScheduler = Rx.Scheduler.isScheduler,
        observableFromPromise = Observable.fromPromise;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function observableTimerDate(dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        return scheduler.scheduleWithAbsolute(dueTime, function() {
          observer.onNext(0);
          observer.onCompleted();
        });
      });
    }
    function observableTimerDateAndPeriod(dueTime, period, scheduler) {
      return new AnonymousObservable(function(observer) {
        var d = dueTime,
            p = normalizeTime(period);
        return scheduler.scheduleRecursiveWithAbsoluteAndState(0, d, function(count, self) {
          if (p > 0) {
            var now = scheduler.now();
            d = d + p;
            d <= now && (d = now + p);
          }
          observer.onNext(count);
          self(count + 1, d);
        });
      });
    }
    function observableTimerTimeSpan(dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        return scheduler.scheduleWithRelative(normalizeTime(dueTime), function() {
          observer.onNext(0);
          observer.onCompleted();
        });
      });
    }
    function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
      return dueTime === period ? new AnonymousObservable(function(observer) {
        return scheduler.schedulePeriodicWithState(0, period, function(count) {
          observer.onNext(count);
          return count + 1;
        });
      }) : observableDefer(function() {
        return observableTimerDateAndPeriod(scheduler.now() + dueTime, period, scheduler);
      });
    }
    var observableinterval = Observable.interval = function(period, scheduler) {
      return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : timeoutScheduler);
    };
    var observableTimer = Observable.timer = function(dueTime, periodOrScheduler, scheduler) {
      var period;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      if (periodOrScheduler != null && typeof periodOrScheduler === 'number') {
        period = periodOrScheduler;
      } else if (isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
      }
      if (dueTime instanceof Date && period === undefined) {
        return observableTimerDate(dueTime.getTime(), scheduler);
      }
      if (dueTime instanceof Date && period !== undefined) {
        return observableTimerDateAndPeriod(dueTime.getTime(), periodOrScheduler, scheduler);
      }
      return period === undefined ? observableTimerTimeSpan(dueTime, scheduler) : observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
    };
    function observableDelayTimeSpan(source, dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        var active = false,
            cancelable = new SerialDisposable(),
            exception = null,
            q = [],
            running = false,
            subscription;
        subscription = source.materialize().timestamp(scheduler).subscribe(function(notification) {
          var d,
              shouldRun;
          if (notification.value.kind === 'E') {
            q = [];
            q.push(notification);
            exception = notification.value.exception;
            shouldRun = !running;
          } else {
            q.push({
              value: notification.value,
              timestamp: notification.timestamp + dueTime
            });
            shouldRun = !active;
            active = true;
          }
          if (shouldRun) {
            if (exception !== null) {
              observer.onError(exception);
            } else {
              d = new SingleAssignmentDisposable();
              cancelable.setDisposable(d);
              d.setDisposable(scheduler.scheduleRecursiveWithRelative(dueTime, function(self) {
                var e,
                    recurseDueTime,
                    result,
                    shouldRecurse;
                if (exception !== null) {
                  return;
                }
                running = true;
                do {
                  result = null;
                  if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {
                    result = q.shift().value;
                  }
                  if (result !== null) {
                    result.accept(observer);
                  }
                } while (result !== null);
                shouldRecurse = false;
                recurseDueTime = 0;
                if (q.length > 0) {
                  shouldRecurse = true;
                  recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
                } else {
                  active = false;
                }
                e = exception;
                running = false;
                if (e !== null) {
                  observer.onError(e);
                } else if (shouldRecurse) {
                  self(recurseDueTime);
                }
              }));
            }
          }
        });
        return new CompositeDisposable(subscription, cancelable);
      }, source);
    }
    function observableDelayDate(source, dueTime, scheduler) {
      return observableDefer(function() {
        return observableDelayTimeSpan(source, dueTime - scheduler.now(), scheduler);
      });
    }
    observableProto.delay = function(dueTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return dueTime instanceof Date ? observableDelayDate(this, dueTime.getTime(), scheduler) : observableDelayTimeSpan(this, dueTime, scheduler);
    };
    observableProto.debounce = function(dueTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this;
      return new AnonymousObservable(function(observer) {
        var cancelable = new SerialDisposable(),
            hasvalue = false,
            value,
            id = 0;
        var subscription = source.subscribe(function(x) {
          hasvalue = true;
          value = x;
          id++;
          var currentId = id,
              d = new SingleAssignmentDisposable();
          cancelable.setDisposable(d);
          d.setDisposable(scheduler.scheduleWithRelative(dueTime, function() {
            hasvalue && id === currentId && observer.onNext(value);
            hasvalue = false;
          }));
        }, function(e) {
          cancelable.dispose();
          observer.onError(e);
          hasvalue = false;
          id++;
        }, function() {
          cancelable.dispose();
          hasvalue && observer.onNext(value);
          observer.onCompleted();
          hasvalue = false;
          id++;
        });
        return new CompositeDisposable(subscription, cancelable);
      }, this);
    };
    observableProto.throttle = function(dueTime, scheduler) {
      return this.debounce(dueTime, scheduler);
    };
    observableProto.windowWithTime = function(timeSpan, timeShiftOrScheduler, scheduler) {
      var source = this,
          timeShift;
      timeShiftOrScheduler == null && (timeShift = timeSpan);
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      if (typeof timeShiftOrScheduler === 'number') {
        timeShift = timeShiftOrScheduler;
      } else if (isScheduler(timeShiftOrScheduler)) {
        timeShift = timeSpan;
        scheduler = timeShiftOrScheduler;
      }
      return new AnonymousObservable(function(observer) {
        var groupDisposable,
            nextShift = timeShift,
            nextSpan = timeSpan,
            q = [],
            refCountDisposable,
            timerD = new SerialDisposable(),
            totalTime = 0;
        groupDisposable = new CompositeDisposable(timerD), refCountDisposable = new RefCountDisposable(groupDisposable);
        function createTimer() {
          var m = new SingleAssignmentDisposable(),
              isSpan = false,
              isShift = false;
          timerD.setDisposable(m);
          if (nextSpan === nextShift) {
            isSpan = true;
            isShift = true;
          } else if (nextSpan < nextShift) {
            isSpan = true;
          } else {
            isShift = true;
          }
          var newTotalTime = isSpan ? nextSpan : nextShift,
              ts = newTotalTime - totalTime;
          totalTime = newTotalTime;
          if (isSpan) {
            nextSpan += timeShift;
          }
          if (isShift) {
            nextShift += timeShift;
          }
          m.setDisposable(scheduler.scheduleWithRelative(ts, function() {
            if (isShift) {
              var s = new Subject();
              q.push(s);
              observer.onNext(addRef(s, refCountDisposable));
            }
            isSpan && q.shift().onCompleted();
            createTimer();
          }));
        }
        ;
        q.push(new Subject());
        observer.onNext(addRef(q[0], refCountDisposable));
        createTimer();
        groupDisposable.add(source.subscribe(function(x) {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onNext(x);
          }
        }, function(e) {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onError(e);
          }
          observer.onError(e);
        }, function() {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onCompleted();
          }
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    observableProto.windowWithTimeOrCount = function(timeSpan, count, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var timerD = new SerialDisposable(),
            groupDisposable = new CompositeDisposable(timerD),
            refCountDisposable = new RefCountDisposable(groupDisposable),
            n = 0,
            windowId = 0,
            s = new Subject();
        function createTimer(id) {
          var m = new SingleAssignmentDisposable();
          timerD.setDisposable(m);
          m.setDisposable(scheduler.scheduleWithRelative(timeSpan, function() {
            if (id !== windowId) {
              return;
            }
            n = 0;
            var newId = ++windowId;
            s.onCompleted();
            s = new Subject();
            observer.onNext(addRef(s, refCountDisposable));
            createTimer(newId);
          }));
        }
        observer.onNext(addRef(s, refCountDisposable));
        createTimer(0);
        groupDisposable.add(source.subscribe(function(x) {
          var newId = 0,
              newWindow = false;
          s.onNext(x);
          if (++n === count) {
            newWindow = true;
            n = 0;
            newId = ++windowId;
            s.onCompleted();
            s = new Subject();
            observer.onNext(addRef(s, refCountDisposable));
          }
          newWindow && createTimer(newId);
        }, function(e) {
          s.onError(e);
          observer.onError(e);
        }, function() {
          s.onCompleted();
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    function toArray(x) {
      return x.toArray();
    }
    observableProto.bufferWithTime = function(timeSpan, timeShiftOrScheduler, scheduler) {
      return this.windowWithTime(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray);
    };
    function toArray(x) {
      return x.toArray();
    }
    observableProto.bufferWithTimeOrCount = function(timeSpan, count, scheduler) {
      return this.windowWithTimeOrCount(timeSpan, count, scheduler).flatMap(toArray);
    };
    observableProto.timeInterval = function(scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return observableDefer(function() {
        var last = scheduler.now();
        return source.map(function(x) {
          var now = scheduler.now(),
              span = now - last;
          last = now;
          return {
            value: x,
            interval: span
          };
        });
      });
    };
    observableProto.timestamp = function(scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return this.map(function(x) {
        return {
          value: x,
          timestamp: scheduler.now()
        };
      });
    };
    function sampleObservable(source, sampler) {
      return new AnonymousObservable(function(o) {
        var atEnd = false,
            value,
            hasValue = false;
        function sampleSubscribe() {
          if (hasValue) {
            hasValue = false;
            o.onNext(value);
          }
          atEnd && o.onCompleted();
        }
        var sourceSubscription = new SingleAssignmentDisposable();
        sourceSubscription.setDisposable(source.subscribe(function(newValue) {
          hasValue = true;
          value = newValue;
        }, function(e) {
          o.onError(e);
        }, function() {
          atEnd = true;
          sourceSubscription.dispose();
        }));
        return new CompositeDisposable(sourceSubscription, sampler.subscribe(sampleSubscribe, function(e) {
          o.onError(e);
        }, sampleSubscribe));
      }, source);
    }
    observableProto.sample = observableProto.throttleLatest = function(intervalOrSampler, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return typeof intervalOrSampler === 'number' ? sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) : sampleObservable(this, intervalOrSampler);
    };
    observableProto.timeout = function(dueTime, other, scheduler) {
      (other == null || typeof other === 'string') && (other = observableThrow(new Error(other || 'Timeout')));
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = dueTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(observer) {
        var id = 0,
            original = new SingleAssignmentDisposable(),
            subscription = new SerialDisposable(),
            switched = false,
            timer = new SerialDisposable();
        subscription.setDisposable(original);
        function createTimer() {
          var myId = id;
          timer.setDisposable(scheduler[schedulerMethod](dueTime, function() {
            if (id === myId) {
              isPromise(other) && (other = observableFromPromise(other));
              subscription.setDisposable(other.subscribe(observer));
            }
          }));
        }
        createTimer();
        original.setDisposable(source.subscribe(function(x) {
          if (!switched) {
            id++;
            observer.onNext(x);
            createTimer();
          }
        }, function(e) {
          if (!switched) {
            id++;
            observer.onError(e);
          }
        }, function() {
          if (!switched) {
            id++;
            observer.onCompleted();
          }
        }));
        return new CompositeDisposable(subscription, timer);
      }, source);
    };
    Observable.generateWithAbsoluteTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var first = true,
            hasResult = false;
        return scheduler.scheduleRecursiveWithAbsoluteAndState(initialState, scheduler.now(), function(state, self) {
          hasResult && observer.onNext(state);
          try {
            if (first) {
              first = false;
            } else {
              state = iterate(state);
            }
            hasResult = condition(state);
            if (hasResult) {
              var result = resultSelector(state);
              var time = timeSelector(state);
            }
          } catch (e) {
            observer.onError(e);
            return;
          }
          if (hasResult) {
            self(result, time);
          } else {
            observer.onCompleted();
          }
        });
      });
    };
    Observable.generateWithRelativeTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var first = true,
            hasResult = false;
        return scheduler.scheduleRecursiveWithRelativeAndState(initialState, 0, function(state, self) {
          hasResult && observer.onNext(state);
          try {
            if (first) {
              first = false;
            } else {
              state = iterate(state);
            }
            hasResult = condition(state);
            if (hasResult) {
              var result = resultSelector(state);
              var time = timeSelector(state);
            }
          } catch (e) {
            observer.onError(e);
            return;
          }
          if (hasResult) {
            self(result, time);
          } else {
            observer.onCompleted();
          }
        });
      });
    };
    observableProto.delaySubscription = function(dueTime, scheduler) {
      var scheduleMethod = dueTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var d = new SerialDisposable();
        d.setDisposable(scheduler[scheduleMethod](dueTime, function() {
          d.setDisposable(source.subscribe(o));
        }));
        return d;
      }, this);
    };
    observableProto.delayWithSelector = function(subscriptionDelay, delayDurationSelector) {
      var source = this,
          subDelay,
          selector;
      if (isFunction(subscriptionDelay)) {
        selector = subscriptionDelay;
      } else {
        subDelay = subscriptionDelay;
        selector = delayDurationSelector;
      }
      return new AnonymousObservable(function(observer) {
        var delays = new CompositeDisposable(),
            atEnd = false,
            subscription = new SerialDisposable();
        function start() {
          subscription.setDisposable(source.subscribe(function(x) {
            var delay = tryCatch(selector)(x);
            if (delay === errorObj) {
              return observer.onError(delay.e);
            }
            var d = new SingleAssignmentDisposable();
            delays.add(d);
            d.setDisposable(delay.subscribe(function() {
              observer.onNext(x);
              delays.remove(d);
              done();
            }, function(e) {
              observer.onError(e);
            }, function() {
              observer.onNext(x);
              delays.remove(d);
              done();
            }));
          }, function(e) {
            observer.onError(e);
          }, function() {
            atEnd = true;
            subscription.dispose();
            done();
          }));
        }
        function done() {
          atEnd && delays.length === 0 && observer.onCompleted();
        }
        if (!subDelay) {
          start();
        } else {
          subscription.setDisposable(subDelay.subscribe(start, function(e) {
            observer.onError(e);
          }, start));
        }
        return new CompositeDisposable(subscription, delays);
      }, this);
    };
    observableProto.timeoutWithSelector = function(firstTimeout, timeoutdurationSelector, other) {
      if (arguments.length === 1) {
        timeoutdurationSelector = firstTimeout;
        firstTimeout = observableNever();
      }
      other || (other = observableThrow(new Error('Timeout')));
      var source = this;
      return new AnonymousObservable(function(observer) {
        var subscription = new SerialDisposable(),
            timer = new SerialDisposable(),
            original = new SingleAssignmentDisposable();
        subscription.setDisposable(original);
        var id = 0,
            switched = false;
        function setTimer(timeout) {
          var myId = id;
          function timerWins() {
            return id === myId;
          }
          var d = new SingleAssignmentDisposable();
          timer.setDisposable(d);
          d.setDisposable(timeout.subscribe(function() {
            timerWins() && subscription.setDisposable(other.subscribe(observer));
            d.dispose();
          }, function(e) {
            timerWins() && observer.onError(e);
          }, function() {
            timerWins() && subscription.setDisposable(other.subscribe(observer));
          }));
        }
        ;
        setTimer(firstTimeout);
        function observerWins() {
          var res = !switched;
          if (res) {
            id++;
          }
          return res;
        }
        original.setDisposable(source.subscribe(function(x) {
          if (observerWins()) {
            observer.onNext(x);
            var timeout;
            try {
              timeout = timeoutdurationSelector(x);
            } catch (e) {
              observer.onError(e);
              return;
            }
            setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
          }
        }, function(e) {
          observerWins() && observer.onError(e);
        }, function() {
          observerWins() && observer.onCompleted();
        }));
        return new CompositeDisposable(subscription, timer);
      }, source);
    };
    observableProto.debounceWithSelector = function(durationSelector) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var value,
            hasValue = false,
            cancelable = new SerialDisposable(),
            id = 0;
        var subscription = source.subscribe(function(x) {
          var throttle = tryCatch(durationSelector)(x);
          if (throttle === errorObj) {
            return o.onError(throttle.e);
          }
          isPromise(throttle) && (throttle = observableFromPromise(throttle));
          hasValue = true;
          value = x;
          id++;
          var currentid = id,
              d = new SingleAssignmentDisposable();
          cancelable.setDisposable(d);
          d.setDisposable(throttle.subscribe(function() {
            hasValue && id === currentid && o.onNext(value);
            hasValue = false;
            d.dispose();
          }, function(e) {
            o.onError(e);
          }, function() {
            hasValue && id === currentid && o.onNext(value);
            hasValue = false;
            d.dispose();
          }));
        }, function(e) {
          cancelable.dispose();
          o.onError(e);
          hasValue = false;
          id++;
        }, function() {
          cancelable.dispose();
          hasValue && o.onNext(value);
          o.onCompleted();
          hasValue = false;
          id++;
        });
        return new CompositeDisposable(subscription, cancelable);
      }, source);
    };
    observableProto.skipLastWithTime = function(duration, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this;
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            o.onNext(q.shift().value);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now();
          while (q.length > 0 && now - q[0].interval >= duration) {
            o.onNext(q.shift().value);
          }
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeLastWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            q.shift();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now();
          while (q.length > 0) {
            var next = q.shift();
            if (now - next.interval <= duration) {
              o.onNext(next.value);
            }
          }
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeLastBufferWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            q.shift();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now(),
              res = [];
          while (q.length > 0) {
            var next = q.shift();
            now - next.interval <= duration && res.push(next.value);
          }
          o.onNext(res);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        return new CompositeDisposable(scheduler.scheduleWithRelative(duration, function() {
          o.onCompleted();
        }), source.subscribe(o));
      }, source);
    };
    observableProto.skipWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var open = false;
        return new CompositeDisposable(scheduler.scheduleWithRelative(duration, function() {
          open = true;
        }), source.subscribe(function(x) {
          open && observer.onNext(x);
        }, observer.onError.bind(observer), observer.onCompleted.bind(observer)));
      }, source);
    };
    observableProto.skipUntilWithTime = function(startTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = startTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(o) {
        var open = false;
        return new CompositeDisposable(scheduler[schedulerMethod](startTime, function() {
          open = true;
        }), source.subscribe(function(x) {
          open && o.onNext(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        }));
      }, source);
    };
    observableProto.takeUntilWithTime = function(endTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = endTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(o) {
        return new CompositeDisposable(scheduler[schedulerMethod](endTime, function() {
          o.onCompleted();
        }), source.subscribe(o));
      }, source);
    };
    observableProto.throttleFirst = function(windowDuration, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var duration = +windowDuration || 0;
      if (duration <= 0) {
        throw new RangeError('windowDuration cannot be less or equal zero.');
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var lastOnNext = 0;
        return source.subscribe(function(x) {
          var now = scheduler.now();
          if (lastOnNext === 0 || now - lastOnNext >= duration) {
            lastOnNext = now;
            o.onNext(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-util@0.1.0.js", ["github:jspm/nodelibs-util@0.1.0/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-util@0.1.0/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.1.js", ["github:jspm/nodelibs-process@0.1.1/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-buffer@0.1.0.js", ["github:jspm/nodelibs-buffer@0.1.0/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-buffer@0.1.0/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:uuid@2.0.1/uuid.js", ["npm:uuid@2.0.1/rng-browser.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _rng = require("npm:uuid@2.0.1/rng-browser.js");
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0,
        ii = 0;
    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) {
        buf[i + ii++] = _hexToByte[oct];
      }
    });
    while (ii < 16) {
      buf[i + ii++] = 0;
    }
    return buf;
  }
  function unparse(buf, offset) {
    var i = offset || 0,
        bth = _byteToHex;
    return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
  }
  var _seedBytes = _rng();
  var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
  var _lastMSecs = 0,
      _lastNSecs = 0;
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();
    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs) / 10000;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 0x3fff;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;
    b[i++] = tmh >>> 24 & 0xf | 0x10;
    b[i++] = tmh >>> 16 & 0xff;
    b[i++] = clockseq >>> 8 | 0x80;
    b[i++] = clockseq & 0xff;
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }
    return buf ? buf : unparse(b);
  }
  function v4(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || _rng)();
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || unparse(rnds);
  }
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  module.exports = uuid;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:url@0.10.3/url.js", ["npm:punycode@1.3.2.js", "npm:querystring@0.2.0.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var punycode = require("npm:punycode@1.3.2.js");
  exports.parse = urlParse;
  exports.resolve = urlResolve;
  exports.resolveObject = urlResolveObject;
  exports.format = urlFormat;
  exports.Url = Url;
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,
      delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
      unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
      autoEscape = ['\''].concat(unwise),
      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
      unsafeProtocol = {
        'javascript': true,
        'javascript:': true
      },
      hostlessProtocol = {
        'javascript': true,
        'javascript:': true
      },
      slashedProtocol = {
        'http': true,
        'https': true,
        'ftp': true,
        'gopher': true,
        'file': true,
        'http:': true,
        'https:': true,
        'ftp:': true,
        'gopher:': true,
        'file:': true
      },
      querystring = require("npm:querystring@0.2.0.js");
  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && isObject(url) && url instanceof Url)
      return url;
    var u = new Url;
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    if (!isString(url)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }
    var rest = url;
    rest = rest.trim();
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === '//';
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
      var hostEnd = -1;
      for (var i = 0; i < hostEndingChars.length; i++) {
        var hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      var auth,
          atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf('@');
      } else {
        atSign = rest.lastIndexOf('@', hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = decodeURIComponent(auth);
      }
      hostEnd = -1;
      for (var i = 0; i < nonHostChars.length; i++) {
        var hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      if (hostEnd === -1)
        hostEnd = rest.length;
      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost();
      this.hostname = this.hostname || '';
      var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i = 0,
            l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part)
            continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = '';
            for (var j = 0,
                k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                newpart += 'x';
              } else {
                newpart += part[j];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = '/' + notHost.join('.') + rest;
              }
              this.hostname = validParts.join('.');
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = '';
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        var domainArray = this.hostname.split('.');
        var newOut = [];
        for (var i = 0; i < domainArray.length; ++i) {
          var s = domainArray[i];
          newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
        }
        this.hostname = newOut.join('.');
      }
      var p = this.port ? ':' + this.port : '';
      var h = this.hostname || '';
      this.host = h + p;
      this.href += this.host;
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if (rest[0] !== '/') {
          rest = '/' + rest;
        }
      }
    }
    if (!unsafeProtocol[lowerProto]) {
      for (var i = 0,
          l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }
    var hash = rest.indexOf('#');
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
      this.search = rest.substr(qm);
      this.query = rest.substr(qm + 1);
      if (parseQueryString) {
        this.query = querystring.parse(this.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      this.search = '';
      this.query = {};
    }
    if (rest)
      this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = '/';
    }
    if (this.pathname || this.search) {
      var p = this.pathname || '';
      var s = this.search || '';
      this.path = p + s;
    }
    this.href = this.format();
    return this;
  };
  function urlFormat(obj) {
    if (isString(obj))
      obj = urlParse(obj);
    if (!(obj instanceof Url))
      return Url.prototype.format.call(obj);
    return obj.format();
  }
  Url.prototype.format = function() {
    var auth = this.auth || '';
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ':');
      auth += '@';
    }
    var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';
    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
      if (this.port) {
        host += ':' + this.port;
      }
    }
    if (this.query && isObject(this.query) && Object.keys(this.query).length) {
      query = querystring.stringify(this.query);
    }
    var search = this.search || (query && ('?' + query)) || '';
    if (protocol && protocol.substr(-1) !== ':')
      protocol += ':';
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = '//' + (host || '');
      if (pathname && pathname.charAt(0) !== '/')
        pathname = '/' + pathname;
    } else if (!host) {
      host = '';
    }
    if (hash && hash.charAt(0) !== '#')
      hash = '#' + hash;
    if (search && search.charAt(0) !== '?')
      search = '?' + search;
    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');
    return protocol + host + pathname + search + hash;
  };
  function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
  }
  Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };
  function urlResolveObject(source, relative) {
    if (!source)
      return relative;
    return urlParse(source, false, true).resolveObject(relative);
  }
  Url.prototype.resolveObject = function(relative) {
    if (isString(relative)) {
      var rel = new Url();
      rel.parse(relative, false, true);
      relative = rel;
    }
    var result = new Url();
    Object.keys(this).forEach(function(k) {
      result[k] = this[k];
    }, this);
    result.hash = relative.hash;
    if (relative.href === '') {
      result.href = result.format();
      return result;
    }
    if (relative.slashes && !relative.protocol) {
      Object.keys(relative).forEach(function(k) {
        if (k !== 'protocol')
          result[k] = relative[k];
      });
      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
        result.path = result.pathname = '/';
      }
      result.href = result.format();
      return result;
    }
    if (relative.protocol && relative.protocol !== result.protocol) {
      if (!slashedProtocol[relative.protocol]) {
        Object.keys(relative).forEach(function(k) {
          result[k] = relative[k];
        });
        result.href = result.format();
        return result;
      }
      result.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        var relPath = (relative.pathname || '').split('/');
        while (relPath.length && !(relative.host = relPath.shift()))
          ;
        if (!relative.host)
          relative.host = '';
        if (!relative.hostname)
          relative.hostname = '';
        if (relPath[0] !== '')
          relPath.unshift('');
        if (relPath.length < 2)
          relPath.unshift('');
        result.pathname = relPath.join('/');
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.query = relative.query;
      result.host = relative.host || '';
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result.port = relative.port;
      if (result.pathname || result.search) {
        var p = result.pathname || '';
        var s = result.search || '';
        result.path = p + s;
      }
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    }
    var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
        isRelAbs = (relative.host || relative.pathname && relative.pathname.charAt(0) === '/'),
        mustEndAbs = (isRelAbs || isSourceAbs || (result.host && relative.pathname)),
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];
    if (psychotic) {
      result.hostname = '';
      result.port = null;
      if (result.host) {
        if (srcPath[0] === '')
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = '';
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === '')
            relPath[0] = relative.host;
          else
            relPath.unshift(relative.host);
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }
    if (isRelAbs) {
      result.host = (relative.host || relative.host === '') ? relative.host : result.host;
      result.hostname = (relative.hostname || relative.hostname === '') ? relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
      result.query = relative.query;
    } else if (!isNullOrUndefined(relative.search)) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result.query = relative.query;
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
      }
      result.href = result.format();
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      if (result.search) {
        result.path = '/' + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = ((result.host || relative.host) && (last === '.' || last === '..') || last === '');
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last == '.') {
        srcPath.splice(i, 1);
      } else if (last === '..') {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift('..');
      }
    }
    if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
      srcPath.unshift('');
    }
    if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
      srcPath.push('');
    }
    var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || (result.host && srcPath.length);
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift('');
    }
    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join('/');
    }
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  };
  Url.prototype.parseHost = function() {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ':') {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host)
      this.hostname = host;
  };
  function isString(arg) {
    return typeof arg === "string";
  }
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:util@0.10.3.js", ["npm:util@0.10.3/util.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:util@0.10.3/util.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xml2js@0.4.10/lib/xml2js.js", ["npm:sax@1.1.1.js", "github:jspm/nodelibs-events@0.1.1.js", "npm:xmlbuilder@2.6.4.js", "npm:xml2js@0.4.10/lib/bom.js", "npm:xml2js@0.4.10/lib/processors.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    (function() {
      "use strict";
      var bom,
          builder,
          escapeCDATA,
          events,
          isEmpty,
          processName,
          processors,
          requiresCDATA,
          sax,
          wrapCDATA,
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty,
          bind = function(fn, me) {
            return function() {
              return fn.apply(me, arguments);
            };
          };
      sax = require("npm:sax@1.1.1.js");
      events = require("github:jspm/nodelibs-events@0.1.1.js");
      builder = require("npm:xmlbuilder@2.6.4.js");
      bom = require("npm:xml2js@0.4.10/lib/bom.js");
      processors = require("npm:xml2js@0.4.10/lib/processors.js");
      isEmpty = function(thing) {
        return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
      };
      processName = function(processors, processedName) {
        var i,
            len,
            process;
        for (i = 0, len = processors.length; i < len; i++) {
          process = processors[i];
          processedName = process(processedName);
        }
        return processedName;
      };
      requiresCDATA = function(entry) {
        return entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0;
      };
      wrapCDATA = function(entry) {
        return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
      };
      escapeCDATA = function(entry) {
        return entry.replace(']]>', ']]]]><![CDATA[>');
      };
      exports.processors = processors;
      exports.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: '@@',
          charsAsChildren: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: ''
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          preserveChildrenOrder: false,
          childkey: '$$',
          charsAsChildren: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: 'root',
          xmldec: {
            'version': '1.0',
            'encoding': 'UTF-8',
            'standalone': true
          },
          doctype: null,
          renderOpts: {
            'pretty': true,
            'indent': '  ',
            'newline': '\n'
          },
          headless: false,
          chunkSize: 10000,
          emptyTag: '',
          cdata: false
        }
      };
      exports.ValidationError = (function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
          this.message = message;
        }
        return ValidationError;
      })(Error);
      exports.Builder = (function() {
        function Builder(opts) {
          var key,
              ref,
              value;
          this.options = {};
          ref = exports.defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value = opts[key];
            this.options[key] = value;
          }
        }
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey,
              charkey,
              render,
              rootElement,
              rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if ((Object.keys(rootObj).length === 1) && (this.options.rootName === exports.defaults['0.2'].rootName)) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render = (function(_this) {
            return function(element, obj) {
              var attr,
                  child,
                  entry,
                  index,
                  key,
                  value;
              if (typeof obj !== 'object') {
                if (_this.options.cdata && requiresCDATA(obj)) {
                  element.raw(wrapCDATA(obj));
                } else {
                  element.txt(obj);
                }
              } else {
                for (key in obj) {
                  if (!hasProp.call(obj, key))
                    continue;
                  child = obj[key];
                  if (key === attrkey) {
                    if (typeof child === "object") {
                      for (attr in child) {
                        value = child[attr];
                        element = element.att(attr, value);
                      }
                    }
                  } else if (key === charkey) {
                    if (_this.options.cdata && requiresCDATA(child)) {
                      element = element.raw(wrapCDATA(child));
                    } else {
                      element = element.txt(child);
                    }
                  } else if (Array.isArray(child)) {
                    for (index in child) {
                      if (!hasProp.call(child, index))
                        continue;
                      entry = child[index];
                      if (typeof entry === 'string') {
                        if (_this.options.cdata && requiresCDATA(entry)) {
                          element = element.ele(key).raw(wrapCDATA(entry)).up();
                        } else {
                          element = element.ele(key, entry).up();
                        }
                      } else {
                        element = render(element.ele(key), entry).up();
                      }
                    }
                  } else if (typeof child === "object") {
                    element = render(element.ele(key), child).up();
                  } else {
                    if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                      element = element.ele(key).raw(wrapCDATA(child)).up();
                    } else {
                      element = element.ele(key, child.toString()).up();
                    }
                  }
                }
              }
              return element;
            };
          })(this);
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {headless: this.options.headless});
          return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
      })();
      exports.Parser = (function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
          this.parseString = bind(this.parseString, this);
          this.reset = bind(this.reset, this);
          this.assignOrPush = bind(this.assignOrPush, this);
          this.processAsync = bind(this.processAsync, this);
          var key,
              ref,
              value;
          if (!(this instanceof exports.Parser)) {
            return new exports.Parser(opts);
          }
          this.options = {};
          ref = exports.defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value = opts[key];
            this.options[key] = value;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
        Parser.prototype.processAsync = function() {
          var chunk;
          if (this.remaining.length <= this.options.chunkSize) {
            chunk = this.remaining;
            this.remaining = '';
            this.saxParser = this.saxParser.write(chunk);
            return this.saxParser.close();
          } else {
            chunk = this.remaining.substr(0, this.options.chunkSize);
            this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
            this.saxParser = this.saxParser.write(chunk);
            return setImmediate(this.processAsync);
          }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return obj[key] = newValue;
            } else {
              return obj[key] = [newValue];
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
        Parser.prototype.reset = function() {
          var attrkey,
              charkey,
              ontext,
              stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = (function(_this) {
            return function(error) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error);
              }
            };
          })(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = (function(_this) {
            return function(node) {
              var key,
                  newValue,
                  obj,
                  processedKey,
                  ref;
              obj = {};
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                ref = node.attributes;
                for (key in ref) {
                  if (!hasProp.call(ref, key))
                    continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = {};
                  }
                  newValue = node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processName(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processName(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          })(this);
          this.saxParser.onclosetag = (function(_this) {
            return function() {
              var cdata,
                  emptyStr,
                  err,
                  key,
                  node,
                  nodeName,
                  obj,
                  objClone,
                  old,
                  s,
                  xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                delete obj["#name"];
              }
              if (obj.cdata === true) {
                cdata = obj.cdata;
                delete obj.cdata;
              }
              s = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                obj[charkey] = _this.options.valueProcessors ? processName(_this.options.valueProcessors, obj[charkey]) : obj[charkey];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
              }
              if (_this.options.validator != null) {
                xpath = "/" + ((function() {
                  var i,
                      len,
                      results;
                  results = [];
                  for (i = 0, len = stack.length; i < len; i++) {
                    node = stack[i];
                    results.push(node["#name"]);
                  }
                  return results;
                })()).concat(nodeName).join("/");
                try {
                  obj = _this.options.validator(xpath, s && s[nodeName], obj);
                } catch (_error) {
                  err = _error;
                  _this.emit("error", err);
                }
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                if (!_this.options.preserveChildrenOrder) {
                  node = {};
                  if (_this.options.attrkey in obj) {
                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                    delete obj[_this.options.attrkey];
                  }
                  if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                    node[_this.options.charkey] = obj[_this.options.charkey];
                    delete obj[_this.options.charkey];
                  }
                  if (Object.getOwnPropertyNames(obj).length > 0) {
                    node[_this.options.childkey] = obj;
                  }
                  obj = node;
                } else if (s) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  objClone = {};
                  for (key in obj) {
                    if (!hasProp.call(obj, key))
                      continue;
                    objClone[key] = obj[key];
                  }
                  s[_this.options.childkey].push(objClone);
                  delete obj["#name"];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = {};
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          })(this);
          ontext = (function(_this) {
            return function(text) {
              var charChild,
                  s;
              s = stack[stack.length - 1];
              if (s) {
                s[charkey] += text;
                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && text.replace(/\\n/g, '').trim() !== '') {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  charChild = {'#name': '__text__'};
                  charChild[charkey] = text;
                  s[_this.options.childkey].push(charChild);
                }
                return s;
              }
            };
          })(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = (function(_this) {
            return function(text) {
              var s;
              s = ontext(text);
              if (s) {
                return s.cdata = true;
              }
            };
          })(this);
        };
        Parser.prototype.parseString = function(str, cb) {
          var err;
          if ((cb != null) && typeof cb === "function") {
            this.on("end", function(result) {
              this.reset();
              return cb(null, result);
            });
            this.on("error", function(err) {
              this.reset();
              return cb(err);
            });
          }
          str = str.toString();
          if (str.trim() === '') {
            this.emit("end", null);
            return true;
          }
          try {
            str = bom.stripBOM(str);
            if (this.options.async) {
              this.remaining = str;
              setImmediate(this.processAsync);
              this.saxParser;
            }
            return this.saxParser.write(str).close();
          } catch (_error) {
            err = _error;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit('error', err);
              return this.saxParser.errThrown = true;
            } else if (this.saxParser.ended) {
              throw err;
            }
          }
        };
        return Parser;
      })(events.EventEmitter);
      exports.parseString = function(str, a, b) {
        var cb,
            options,
            parser;
        if (b != null) {
          if (typeof b === 'function') {
            cb = b;
          }
          if (typeof a === 'object') {
            options = a;
          }
        } else {
          if (typeof a === 'function') {
            cb = a;
          }
          options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
      };
    }).call(this);
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:bluebird@2.9.34/js/browser/bluebird.js", ["github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.Promise = e();
      }
    }(function() {
      var define,
          module,
          exports;
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a)
                return a(o, !0);
              if (i)
                return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {exports: {}};
            t[o][0].call(l.exports, function(e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
          }
          return n[o].exports;
        }
        var i = typeof _dereq_ == "function" && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      })({
        1: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var SomePromiseArray = Promise._SomePromiseArray;
            function any(promises) {
              var ret = new SomePromiseArray(promises);
              var promise = ret.promise();
              ret.setHowMany(1);
              ret.setUnwrap();
              ret.init();
              return promise;
            }
            Promise.any = function(promises) {
              return any(promises);
            };
            Promise.prototype.any = function() {
              return any(this);
            };
          };
        }, {}],
        2: [function(_dereq_, module, exports) {
          "use strict";
          var firstLineError;
          try {
            throw new Error();
          } catch (e) {
            firstLineError = e;
          }
          var schedule = _dereq_("./schedule.js");
          var Queue = _dereq_("./queue.js");
          var util = _dereq_("./util.js");
          function Async() {
            this._isTickUsed = false;
            this._lateQueue = new Queue(16);
            this._normalQueue = new Queue(16);
            this._trampolineEnabled = true;
            var self = this;
            this.drainQueues = function() {
              self._drainQueues();
            };
            this._schedule = schedule.isStatic ? schedule(this.drainQueues) : schedule;
          }
          Async.prototype.disableTrampolineIfNecessary = function() {
            if (util.hasDevTools) {
              this._trampolineEnabled = false;
            }
          };
          Async.prototype.enableTrampoline = function() {
            if (!this._trampolineEnabled) {
              this._trampolineEnabled = true;
              this._schedule = function(fn) {
                setTimeout(fn, 0);
              };
            }
          };
          Async.prototype.haveItemsQueued = function() {
            return this._normalQueue.length() > 0;
          };
          Async.prototype.throwLater = function(fn, arg) {
            if (arguments.length === 1) {
              arg = fn;
              fn = function() {
                throw arg;
              };
            }
            if (typeof setTimeout !== "undefined") {
              setTimeout(function() {
                fn(arg);
              }, 0);
            } else
              try {
                this._schedule(function() {
                  fn(arg);
                });
              } catch (e) {
                throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
              }
          };
          function AsyncInvokeLater(fn, receiver, arg) {
            this._lateQueue.push(fn, receiver, arg);
            this._queueTick();
          }
          function AsyncInvoke(fn, receiver, arg) {
            this._normalQueue.push(fn, receiver, arg);
            this._queueTick();
          }
          function AsyncSettlePromises(promise) {
            this._normalQueue._pushOne(promise);
            this._queueTick();
          }
          if (!util.hasDevTools) {
            Async.prototype.invokeLater = AsyncInvokeLater;
            Async.prototype.invoke = AsyncInvoke;
            Async.prototype.settlePromises = AsyncSettlePromises;
          } else {
            if (schedule.isStatic) {
              schedule = function(fn) {
                setTimeout(fn, 0);
              };
            }
            Async.prototype.invokeLater = function(fn, receiver, arg) {
              if (this._trampolineEnabled) {
                AsyncInvokeLater.call(this, fn, receiver, arg);
              } else {
                this._schedule(function() {
                  setTimeout(function() {
                    fn.call(receiver, arg);
                  }, 100);
                });
              }
            };
            Async.prototype.invoke = function(fn, receiver, arg) {
              if (this._trampolineEnabled) {
                AsyncInvoke.call(this, fn, receiver, arg);
              } else {
                this._schedule(function() {
                  fn.call(receiver, arg);
                });
              }
            };
            Async.prototype.settlePromises = function(promise) {
              if (this._trampolineEnabled) {
                AsyncSettlePromises.call(this, promise);
              } else {
                this._schedule(function() {
                  promise._settlePromises();
                });
              }
            };
          }
          Async.prototype.invokeFirst = function(fn, receiver, arg) {
            this._normalQueue.unshift(fn, receiver, arg);
            this._queueTick();
          };
          Async.prototype._drainQueue = function(queue) {
            while (queue.length() > 0) {
              var fn = queue.shift();
              if (typeof fn !== "function") {
                fn._settlePromises();
                continue;
              }
              var receiver = queue.shift();
              var arg = queue.shift();
              fn.call(receiver, arg);
            }
          };
          Async.prototype._drainQueues = function() {
            this._drainQueue(this._normalQueue);
            this._reset();
            this._drainQueue(this._lateQueue);
          };
          Async.prototype._queueTick = function() {
            if (!this._isTickUsed) {
              this._isTickUsed = true;
              this._schedule(this.drainQueues);
            }
          };
          Async.prototype._reset = function() {
            this._isTickUsed = false;
          };
          module.exports = new Async();
          module.exports.firstLineError = firstLineError;
        }, {
          "./queue.js": 28,
          "./schedule.js": 31,
          "./util.js": 38
        }],
        3: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
            var rejectThis = function(_, e) {
              this._reject(e);
            };
            var targetRejected = function(e, context) {
              context.promiseRejectionQueued = true;
              context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
            };
            var bindingResolved = function(thisArg, context) {
              if (this._isPending()) {
                this._resolveCallback(context.target);
              }
            };
            var bindingRejected = function(e, context) {
              if (!context.promiseRejectionQueued)
                this._reject(e);
            };
            Promise.prototype.bind = function(thisArg) {
              var maybePromise = tryConvertToPromise(thisArg);
              var ret = new Promise(INTERNAL);
              ret._propagateFrom(this, 1);
              var target = this._target();
              ret._setBoundTo(maybePromise);
              if (maybePromise instanceof Promise) {
                var context = {
                  promiseRejectionQueued: false,
                  promise: ret,
                  target: target,
                  bindingPromise: maybePromise
                };
                target._then(INTERNAL, targetRejected, ret._progress, ret, context);
                maybePromise._then(bindingResolved, bindingRejected, ret._progress, ret, context);
              } else {
                ret._resolveCallback(target);
              }
              return ret;
            };
            Promise.prototype._setBoundTo = function(obj) {
              if (obj !== undefined) {
                this._bitField = this._bitField | 131072;
                this._boundTo = obj;
              } else {
                this._bitField = this._bitField & (~131072);
              }
            };
            Promise.prototype._isBound = function() {
              return (this._bitField & 131072) === 131072;
            };
            Promise.bind = function(thisArg, value) {
              var maybePromise = tryConvertToPromise(thisArg);
              var ret = new Promise(INTERNAL);
              ret._setBoundTo(maybePromise);
              if (maybePromise instanceof Promise) {
                maybePromise._then(function() {
                  ret._resolveCallback(value);
                }, ret._reject, ret._progress, ret, null);
              } else {
                ret._resolveCallback(value);
              }
              return ret;
            };
          };
        }, {}],
        4: [function(_dereq_, module, exports) {
          "use strict";
          var old;
          if (typeof Promise !== "undefined")
            old = Promise;
          function noConflict() {
            try {
              if (Promise === bluebird)
                Promise = old;
            } catch (e) {}
            return bluebird;
          }
          var bluebird = _dereq_("./promise.js")();
          bluebird.noConflict = noConflict;
          module.exports = bluebird;
        }, {"./promise.js": 23}],
        5: [function(_dereq_, module, exports) {
          "use strict";
          var cr = Object.create;
          if (cr) {
            var callerCache = cr(null);
            var getterCache = cr(null);
            callerCache[" size"] = getterCache[" size"] = 0;
          }
          module.exports = function(Promise) {
            var util = _dereq_("./util.js");
            var canEvaluate = util.canEvaluate;
            var isIdentifier = util.isIdentifier;
            var getMethodCaller;
            var getGetter;
            if (!true) {
              var makeMethodCaller = function(methodName) {
                return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
              };
              var makeGetter = function(propertyName) {
                return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
              };
              var getCompiled = function(name, compiler, cache) {
                var ret = cache[name];
                if (typeof ret !== "function") {
                  if (!isIdentifier(name)) {
                    return null;
                  }
                  ret = compiler(name);
                  cache[name] = ret;
                  cache[" size"]++;
                  if (cache[" size"] > 512) {
                    var keys = Object.keys(cache);
                    for (var i = 0; i < 256; ++i)
                      delete cache[keys[i]];
                    cache[" size"] = keys.length - 256;
                  }
                }
                return ret;
              };
              getMethodCaller = function(name) {
                return getCompiled(name, makeMethodCaller, callerCache);
              };
              getGetter = function(name) {
                return getCompiled(name, makeGetter, getterCache);
              };
            }
            function ensureMethod(obj, methodName) {
              var fn;
              if (obj != null)
                fn = obj[methodName];
              if (typeof fn !== "function") {
                var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
                throw new Promise.TypeError(message);
              }
              return fn;
            }
            function caller(obj) {
              var methodName = this.pop();
              var fn = ensureMethod(obj, methodName);
              return fn.apply(obj, this);
            }
            Promise.prototype.call = function(methodName) {
              var $_len = arguments.length;
              var args = new Array($_len - 1);
              for (var $_i = 1; $_i < $_len; ++$_i) {
                args[$_i - 1] = arguments[$_i];
              }
              if (!true) {
                if (canEvaluate) {
                  var maybeCaller = getMethodCaller(methodName);
                  if (maybeCaller !== null) {
                    return this._then(maybeCaller, undefined, undefined, args, undefined);
                  }
                }
              }
              args.push(methodName);
              return this._then(caller, undefined, undefined, args, undefined);
            };
            function namedGetter(obj) {
              return obj[this];
            }
            function indexedGetter(obj) {
              var index = +this;
              if (index < 0)
                index = Math.max(0, index + obj.length);
              return obj[index];
            }
            Promise.prototype.get = function(propertyName) {
              var isIndex = (typeof propertyName === "number");
              var getter;
              if (!isIndex) {
                if (canEvaluate) {
                  var maybeGetter = getGetter(propertyName);
                  getter = maybeGetter !== null ? maybeGetter : namedGetter;
                } else {
                  getter = namedGetter;
                }
              } else {
                getter = indexedGetter;
              }
              return this._then(getter, undefined, undefined, propertyName, undefined);
            };
          };
        }, {"./util.js": 38}],
        6: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var errors = _dereq_("./errors.js");
            var async = _dereq_("./async.js");
            var CancellationError = errors.CancellationError;
            Promise.prototype._cancel = function(reason) {
              if (!this.isCancellable())
                return this;
              var parent;
              var promiseToReject = this;
              while ((parent = promiseToReject._cancellationParent) !== undefined && parent.isCancellable()) {
                promiseToReject = parent;
              }
              this._unsetCancellable();
              promiseToReject._target()._rejectCallback(reason, false, true);
            };
            Promise.prototype.cancel = function(reason) {
              if (!this.isCancellable())
                return this;
              if (reason === undefined)
                reason = new CancellationError();
              async.invokeLater(this._cancel, this, reason);
              return this;
            };
            Promise.prototype.cancellable = function() {
              if (this._cancellable())
                return this;
              async.enableTrampoline();
              this._setCancellable();
              this._cancellationParent = undefined;
              return this;
            };
            Promise.prototype.uncancellable = function() {
              var ret = this.then();
              ret._unsetCancellable();
              return ret;
            };
            Promise.prototype.fork = function(didFulfill, didReject, didProgress) {
              var ret = this._then(didFulfill, didReject, didProgress, undefined, undefined);
              ret._setCancellable();
              ret._cancellationParent = undefined;
              return ret;
            };
          };
        }, {
          "./async.js": 2,
          "./errors.js": 13
        }],
        7: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function() {
            var async = _dereq_("./async.js");
            var util = _dereq_("./util.js");
            var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
            var stackFramePattern = null;
            var formatStack = null;
            var indentStackFrames = false;
            var warn;
            function CapturedTrace(parent) {
              this._parent = parent;
              var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
              captureStackTrace(this, CapturedTrace);
              if (length > 32)
                this.uncycle();
            }
            util.inherits(CapturedTrace, Error);
            CapturedTrace.prototype.uncycle = function() {
              var length = this._length;
              if (length < 2)
                return;
              var nodes = [];
              var stackToIndex = {};
              for (var i = 0,
                  node = this; node !== undefined; ++i) {
                nodes.push(node);
                node = node._parent;
              }
              length = this._length = i;
              for (var i = length - 1; i >= 0; --i) {
                var stack = nodes[i].stack;
                if (stackToIndex[stack] === undefined) {
                  stackToIndex[stack] = i;
                }
              }
              for (var i = 0; i < length; ++i) {
                var currentStack = nodes[i].stack;
                var index = stackToIndex[currentStack];
                if (index !== undefined && index !== i) {
                  if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                  }
                  nodes[i]._parent = undefined;
                  nodes[i]._length = 1;
                  var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                  if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                  } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                  }
                  var currentChildLength = cycleEdgeNode._length + 1;
                  for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                  }
                  return;
                }
              }
            };
            CapturedTrace.prototype.parent = function() {
              return this._parent;
            };
            CapturedTrace.prototype.hasParent = function() {
              return this._parent !== undefined;
            };
            CapturedTrace.prototype.attachExtraTrace = function(error) {
              if (error.__stackCleaned__)
                return;
              this.uncycle();
              var parsed = CapturedTrace.parseStackAndMessage(error);
              var message = parsed.message;
              var stacks = [parsed.stack];
              var trace = this;
              while (trace !== undefined) {
                stacks.push(cleanStack(trace.stack.split("\n")));
                trace = trace._parent;
              }
              removeCommonRoots(stacks);
              removeDuplicateOrEmptyJumps(stacks);
              util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
              util.notEnumerableProp(error, "__stackCleaned__", true);
            };
            function reconstructStack(message, stacks) {
              for (var i = 0; i < stacks.length - 1; ++i) {
                stacks[i].push("From previous event:");
                stacks[i] = stacks[i].join("\n");
              }
              if (i < stacks.length) {
                stacks[i] = stacks[i].join("\n");
              }
              return message + "\n" + stacks.join("\n");
            }
            function removeDuplicateOrEmptyJumps(stacks) {
              for (var i = 0; i < stacks.length; ++i) {
                if (stacks[i].length === 0 || ((i + 1 < stacks.length) && stacks[i][0] === stacks[i + 1][0])) {
                  stacks.splice(i, 1);
                  i--;
                }
              }
            }
            function removeCommonRoots(stacks) {
              var current = stacks[0];
              for (var i = 1; i < stacks.length; ++i) {
                var prev = stacks[i];
                var currentLastIndex = current.length - 1;
                var currentLastLine = current[currentLastIndex];
                var commonRootMeetPoint = -1;
                for (var j = prev.length - 1; j >= 0; --j) {
                  if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                  }
                }
                for (var j = commonRootMeetPoint; j >= 0; --j) {
                  var line = prev[j];
                  if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                  } else {
                    break;
                  }
                }
                current = prev;
              }
            }
            function cleanStack(stack) {
              var ret = [];
              for (var i = 0; i < stack.length; ++i) {
                var line = stack[i];
                var isTraceLine = stackFramePattern.test(line) || "    (No stack trace)" === line;
                var isInternalFrame = isTraceLine && shouldIgnore(line);
                if (isTraceLine && !isInternalFrame) {
                  if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                  }
                  ret.push(line);
                }
              }
              return ret;
            }
            function stackFramesAsArray(error) {
              var stack = error.stack.replace(/\s+$/g, "").split("\n");
              for (var i = 0; i < stack.length; ++i) {
                var line = stack[i];
                if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                  break;
                }
              }
              if (i > 0) {
                stack = stack.slice(i);
              }
              return stack;
            }
            CapturedTrace.parseStackAndMessage = function(error) {
              var stack = error.stack;
              var message = error.toString();
              stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
              return {
                message: message,
                stack: cleanStack(stack)
              };
            };
            CapturedTrace.formatAndLogError = function(error, title) {
              if (typeof console !== "undefined") {
                var message;
                if (typeof error === "object" || typeof error === "function") {
                  var stack = error.stack;
                  message = title + formatStack(stack, error);
                } else {
                  message = title + String(error);
                }
                if (typeof warn === "function") {
                  warn(message);
                } else if (typeof console.log === "function" || typeof console.log === "object") {
                  console.log(message);
                }
              }
            };
            CapturedTrace.unhandledRejection = function(reason) {
              CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
            };
            CapturedTrace.isSupported = function() {
              return typeof captureStackTrace === "function";
            };
            CapturedTrace.fireRejectionEvent = function(name, localHandler, reason, promise) {
              var localEventFired = false;
              try {
                if (typeof localHandler === "function") {
                  localEventFired = true;
                  if (name === "rejectionHandled") {
                    localHandler(promise);
                  } else {
                    localHandler(reason, promise);
                  }
                }
              } catch (e) {
                async.throwLater(e);
              }
              var globalEventFired = false;
              try {
                globalEventFired = fireGlobalEvent(name, reason, promise);
              } catch (e) {
                globalEventFired = true;
                async.throwLater(e);
              }
              var domEventFired = false;
              if (fireDomEvent) {
                try {
                  domEventFired = fireDomEvent(name.toLowerCase(), {
                    reason: reason,
                    promise: promise
                  });
                } catch (e) {
                  domEventFired = true;
                  async.throwLater(e);
                }
              }
              if (!globalEventFired && !localEventFired && !domEventFired && name === "unhandledRejection") {
                CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
              }
            };
            function formatNonError(obj) {
              var str;
              if (typeof obj === "function") {
                str = "[function " + (obj.name || "anonymous") + "]";
              } else {
                str = obj.toString();
                var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
                if (ruselessToString.test(str)) {
                  try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                  } catch (e) {}
                }
                if (str.length === 0) {
                  str = "(empty array)";
                }
              }
              return ("(<" + snip(str) + ">, no stack trace)");
            }
            function snip(str) {
              var maxChars = 41;
              if (str.length < maxChars) {
                return str;
              }
              return str.substr(0, maxChars - 3) + "...";
            }
            var shouldIgnore = function() {
              return false;
            };
            var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
            function parseLineInfo(line) {
              var matches = line.match(parseLineInfoRegex);
              if (matches) {
                return {
                  fileName: matches[1],
                  line: parseInt(matches[2], 10)
                };
              }
            }
            CapturedTrace.setBounds = function(firstLineError, lastLineError) {
              if (!CapturedTrace.isSupported())
                return;
              var firstStackLines = firstLineError.stack.split("\n");
              var lastStackLines = lastLineError.stack.split("\n");
              var firstIndex = -1;
              var lastIndex = -1;
              var firstFileName;
              var lastFileName;
              for (var i = 0; i < firstStackLines.length; ++i) {
                var result = parseLineInfo(firstStackLines[i]);
                if (result) {
                  firstFileName = result.fileName;
                  firstIndex = result.line;
                  break;
                }
              }
              for (var i = 0; i < lastStackLines.length; ++i) {
                var result = parseLineInfo(lastStackLines[i]);
                if (result) {
                  lastFileName = result.fileName;
                  lastIndex = result.line;
                  break;
                }
              }
              if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
                return;
              }
              shouldIgnore = function(line) {
                if (bluebirdFramePattern.test(line))
                  return true;
                var info = parseLineInfo(line);
                if (info) {
                  if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                    return true;
                  }
                }
                return false;
              };
            };
            var captureStackTrace = (function stackDetection() {
              var v8stackFramePattern = /^\s*at\s*/;
              var v8stackFormatter = function(stack, error) {
                if (typeof stack === "string")
                  return stack;
                if (error.name !== undefined && error.message !== undefined) {
                  return error.toString();
                }
                return formatNonError(error);
              };
              if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                stackFramePattern = v8stackFramePattern;
                formatStack = v8stackFormatter;
                var captureStackTrace = Error.captureStackTrace;
                shouldIgnore = function(line) {
                  return bluebirdFramePattern.test(line);
                };
                return function(receiver, ignoreUntil) {
                  Error.stackTraceLimit = Error.stackTraceLimit + 6;
                  captureStackTrace(receiver, ignoreUntil);
                  Error.stackTraceLimit = Error.stackTraceLimit - 6;
                };
              }
              var err = new Error();
              if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
                stackFramePattern = /@/;
                formatStack = v8stackFormatter;
                indentStackFrames = true;
                return function captureStackTrace(o) {
                  o.stack = new Error().stack;
                };
              }
              var hasStackAfterThrow;
              try {
                throw new Error();
              } catch (e) {
                hasStackAfterThrow = ("stack" in e);
              }
              if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
                stackFramePattern = v8stackFramePattern;
                formatStack = v8stackFormatter;
                return function captureStackTrace(o) {
                  Error.stackTraceLimit = Error.stackTraceLimit + 6;
                  try {
                    throw new Error();
                  } catch (e) {
                    o.stack = e.stack;
                  }
                  Error.stackTraceLimit = Error.stackTraceLimit - 6;
                };
              }
              formatStack = function(stack, error) {
                if (typeof stack === "string")
                  return stack;
                if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
                  return error.toString();
                }
                return formatNonError(error);
              };
              return null;
            })([]);
            var fireDomEvent;
            var fireGlobalEvent = (function() {
              if (util.isNode) {
                return function(name, reason, promise) {
                  if (name === "rejectionHandled") {
                    return process.emit(name, promise);
                  } else {
                    return process.emit(name, reason, promise);
                  }
                };
              } else {
                var customEventWorks = false;
                var anyEventWorks = true;
                try {
                  var ev = new self.CustomEvent("test");
                  customEventWorks = ev instanceof CustomEvent;
                } catch (e) {}
                if (!customEventWorks) {
                  try {
                    var event = document.createEvent("CustomEvent");
                    event.initCustomEvent("testingtheevent", false, true, {});
                    self.dispatchEvent(event);
                  } catch (e) {
                    anyEventWorks = false;
                  }
                }
                if (anyEventWorks) {
                  fireDomEvent = function(type, detail) {
                    var event;
                    if (customEventWorks) {
                      event = new self.CustomEvent(type, {
                        detail: detail,
                        bubbles: false,
                        cancelable: true
                      });
                    } else if (self.dispatchEvent) {
                      event = document.createEvent("CustomEvent");
                      event.initCustomEvent(type, false, true, detail);
                    }
                    return event ? !self.dispatchEvent(event) : false;
                  };
                }
                var toWindowMethodNameMap = {};
                toWindowMethodNameMap["unhandledRejection"] = ("on" + "unhandledRejection").toLowerCase();
                toWindowMethodNameMap["rejectionHandled"] = ("on" + "rejectionHandled").toLowerCase();
                return function(name, reason, promise) {
                  var methodName = toWindowMethodNameMap[name];
                  var method = self[methodName];
                  if (!method)
                    return false;
                  if (name === "rejectionHandled") {
                    method.call(self, promise);
                  } else {
                    method.call(self, reason, promise);
                  }
                  return true;
                };
              }
            })();
            if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
              warn = function(message) {
                console.warn(message);
              };
              if (util.isNode && process.stderr.isTTY) {
                warn = function(message) {
                  process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
                };
              } else if (!util.isNode && typeof(new Error().stack) === "string") {
                warn = function(message) {
                  console.warn("%c" + message, "color: red");
                };
              }
            }
            return CapturedTrace;
          };
        }, {
          "./async.js": 2,
          "./util.js": 38
        }],
        8: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(NEXT_FILTER) {
            var util = _dereq_("./util.js");
            var errors = _dereq_("./errors.js");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var keys = _dereq_("./es5.js").keys;
            var TypeError = errors.TypeError;
            function CatchFilter(instances, callback, promise) {
              this._instances = instances;
              this._callback = callback;
              this._promise = promise;
            }
            function safePredicate(predicate, e) {
              var safeObject = {};
              var retfilter = tryCatch(predicate).call(safeObject, e);
              if (retfilter === errorObj)
                return retfilter;
              var safeKeys = keys(safeObject);
              if (safeKeys.length) {
                errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
                return errorObj;
              }
              return retfilter;
            }
            CatchFilter.prototype.doFilter = function(e) {
              var cb = this._callback;
              var promise = this._promise;
              var boundTo = promise._boundValue();
              for (var i = 0,
                  len = this._instances.length; i < len; ++i) {
                var item = this._instances[i];
                var itemIsErrorType = item === Error || (item != null && item.prototype instanceof Error);
                if (itemIsErrorType && e instanceof item) {
                  var ret = tryCatch(cb).call(boundTo, e);
                  if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                  }
                  return ret;
                } else if (typeof item === "function" && !itemIsErrorType) {
                  var shouldHandle = safePredicate(item, e);
                  if (shouldHandle === errorObj) {
                    e = errorObj.e;
                    break;
                  } else if (shouldHandle) {
                    var ret = tryCatch(cb).call(boundTo, e);
                    if (ret === errorObj) {
                      NEXT_FILTER.e = ret.e;
                      return NEXT_FILTER;
                    }
                    return ret;
                  }
                }
              }
              NEXT_FILTER.e = e;
              return NEXT_FILTER;
            };
            return CatchFilter;
          };
        }, {
          "./errors.js": 13,
          "./es5.js": 14,
          "./util.js": 38
        }],
        9: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, CapturedTrace, isDebugging) {
            var contextStack = [];
            function Context() {
              this._trace = new CapturedTrace(peekContext());
            }
            Context.prototype._pushContext = function() {
              if (!isDebugging())
                return;
              if (this._trace !== undefined) {
                contextStack.push(this._trace);
              }
            };
            Context.prototype._popContext = function() {
              if (!isDebugging())
                return;
              if (this._trace !== undefined) {
                contextStack.pop();
              }
            };
            function createContext() {
              if (isDebugging())
                return new Context();
            }
            function peekContext() {
              var lastIndex = contextStack.length - 1;
              if (lastIndex >= 0) {
                return contextStack[lastIndex];
              }
              return undefined;
            }
            Promise.prototype._peekContext = peekContext;
            Promise.prototype._pushContext = Context.prototype._pushContext;
            Promise.prototype._popContext = Context.prototype._popContext;
            return createContext;
          };
        }, {}],
        10: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, CapturedTrace) {
            var getDomain = Promise._getDomain;
            var async = _dereq_("./async.js");
            var Warning = _dereq_("./errors.js").Warning;
            var util = _dereq_("./util.js");
            var canAttachTrace = util.canAttachTrace;
            var unhandledRejectionHandled;
            var possiblyUnhandledRejection;
            var debugging = false || (util.isNode && (!!process.env["BLUEBIRD_DEBUG"] || process.env["NODE_ENV"] === "development"));
            if (debugging) {
              async.disableTrampolineIfNecessary();
            }
            Promise.prototype._ignoreRejections = function() {
              this._unsetRejectionIsUnhandled();
              this._bitField = this._bitField | 16777216;
            };
            Promise.prototype._ensurePossibleRejectionHandled = function() {
              if ((this._bitField & 16777216) !== 0)
                return;
              this._setRejectionIsUnhandled();
              async.invokeLater(this._notifyUnhandledRejection, this, undefined);
            };
            Promise.prototype._notifyUnhandledRejectionIsHandled = function() {
              CapturedTrace.fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
            };
            Promise.prototype._notifyUnhandledRejection = function() {
              if (this._isRejectionUnhandled()) {
                var reason = this._getCarriedStackTrace() || this._settledValue;
                this._setUnhandledRejectionIsNotified();
                CapturedTrace.fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
              }
            };
            Promise.prototype._setUnhandledRejectionIsNotified = function() {
              this._bitField = this._bitField | 524288;
            };
            Promise.prototype._unsetUnhandledRejectionIsNotified = function() {
              this._bitField = this._bitField & (~524288);
            };
            Promise.prototype._isUnhandledRejectionNotified = function() {
              return (this._bitField & 524288) > 0;
            };
            Promise.prototype._setRejectionIsUnhandled = function() {
              this._bitField = this._bitField | 2097152;
            };
            Promise.prototype._unsetRejectionIsUnhandled = function() {
              this._bitField = this._bitField & (~2097152);
              if (this._isUnhandledRejectionNotified()) {
                this._unsetUnhandledRejectionIsNotified();
                this._notifyUnhandledRejectionIsHandled();
              }
            };
            Promise.prototype._isRejectionUnhandled = function() {
              return (this._bitField & 2097152) > 0;
            };
            Promise.prototype._setCarriedStackTrace = function(capturedTrace) {
              this._bitField = this._bitField | 1048576;
              this._fulfillmentHandler0 = capturedTrace;
            };
            Promise.prototype._isCarryingStackTrace = function() {
              return (this._bitField & 1048576) > 0;
            };
            Promise.prototype._getCarriedStackTrace = function() {
              return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : undefined;
            };
            Promise.prototype._captureStackTrace = function() {
              if (debugging) {
                this._trace = new CapturedTrace(this._peekContext());
              }
              return this;
            };
            Promise.prototype._attachExtraTrace = function(error, ignoreSelf) {
              if (debugging && canAttachTrace(error)) {
                var trace = this._trace;
                if (trace !== undefined) {
                  if (ignoreSelf)
                    trace = trace._parent;
                }
                if (trace !== undefined) {
                  trace.attachExtraTrace(error);
                } else if (!error.__stackCleaned__) {
                  var parsed = CapturedTrace.parseStackAndMessage(error);
                  util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
                  util.notEnumerableProp(error, "__stackCleaned__", true);
                }
              }
            };
            Promise.prototype._warn = function(message) {
              var warning = new Warning(message);
              var ctx = this._peekContext();
              if (ctx) {
                ctx.attachExtraTrace(warning);
              } else {
                var parsed = CapturedTrace.parseStackAndMessage(warning);
                warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
              }
              CapturedTrace.formatAndLogError(warning, "");
            };
            Promise.onPossiblyUnhandledRejection = function(fn) {
              var domain = getDomain();
              possiblyUnhandledRejection = typeof fn === "function" ? (domain === null ? fn : domain.bind(fn)) : undefined;
            };
            Promise.onUnhandledRejectionHandled = function(fn) {
              var domain = getDomain();
              unhandledRejectionHandled = typeof fn === "function" ? (domain === null ? fn : domain.bind(fn)) : undefined;
            };
            Promise.longStackTraces = function() {
              if (async.haveItemsQueued() && debugging === false) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
              }
              debugging = CapturedTrace.isSupported();
              if (debugging) {
                async.disableTrampolineIfNecessary();
              }
            };
            Promise.hasLongStackTraces = function() {
              return debugging && CapturedTrace.isSupported();
            };
            if (!CapturedTrace.isSupported()) {
              Promise.longStackTraces = function() {};
              debugging = false;
            }
            return function() {
              return debugging;
            };
          };
        }, {
          "./async.js": 2,
          "./errors.js": 13,
          "./util.js": 38
        }],
        11: [function(_dereq_, module, exports) {
          "use strict";
          var util = _dereq_("./util.js");
          var isPrimitive = util.isPrimitive;
          module.exports = function(Promise) {
            var returner = function() {
              return this;
            };
            var thrower = function() {
              throw this;
            };
            var returnUndefined = function() {};
            var throwUndefined = function() {
              throw undefined;
            };
            var wrapper = function(value, action) {
              if (action === 1) {
                return function() {
                  throw value;
                };
              } else if (action === 2) {
                return function() {
                  return value;
                };
              }
            };
            Promise.prototype["return"] = Promise.prototype.thenReturn = function(value) {
              if (value === undefined)
                return this.then(returnUndefined);
              if (isPrimitive(value)) {
                return this._then(wrapper(value, 2), undefined, undefined, undefined, undefined);
              }
              return this._then(returner, undefined, undefined, value, undefined);
            };
            Promise.prototype["throw"] = Promise.prototype.thenThrow = function(reason) {
              if (reason === undefined)
                return this.then(throwUndefined);
              if (isPrimitive(reason)) {
                return this._then(wrapper(reason, 1), undefined, undefined, undefined, undefined);
              }
              return this._then(thrower, undefined, undefined, reason, undefined);
            };
          };
        }, {"./util.js": 38}],
        12: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var PromiseReduce = Promise.reduce;
            Promise.prototype.each = function(fn) {
              return PromiseReduce(this, fn, null, INTERNAL);
            };
            Promise.each = function(promises, fn) {
              return PromiseReduce(promises, fn, null, INTERNAL);
            };
          };
        }, {}],
        13: [function(_dereq_, module, exports) {
          "use strict";
          var es5 = _dereq_("./es5.js");
          var Objectfreeze = es5.freeze;
          var util = _dereq_("./util.js");
          var inherits = util.inherits;
          var notEnumerableProp = util.notEnumerableProp;
          function subError(nameProperty, defaultMessage) {
            function SubError(message) {
              if (!(this instanceof SubError))
                return new SubError(message);
              notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
              notEnumerableProp(this, "name", nameProperty);
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
              } else {
                Error.call(this);
              }
            }
            inherits(SubError, Error);
            return SubError;
          }
          var _TypeError,
              _RangeError;
          var Warning = subError("Warning", "warning");
          var CancellationError = subError("CancellationError", "cancellation error");
          var TimeoutError = subError("TimeoutError", "timeout error");
          var AggregateError = subError("AggregateError", "aggregate error");
          try {
            _TypeError = TypeError;
            _RangeError = RangeError;
          } catch (e) {
            _TypeError = subError("TypeError", "type error");
            _RangeError = subError("RangeError", "range error");
          }
          var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
          for (var i = 0; i < methods.length; ++i) {
            if (typeof Array.prototype[methods[i]] === "function") {
              AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
            }
          }
          es5.defineProperty(AggregateError.prototype, "length", {
            value: 0,
            configurable: false,
            writable: true,
            enumerable: true
          });
          AggregateError.prototype["isOperational"] = true;
          var level = 0;
          AggregateError.prototype.toString = function() {
            var indent = Array(level * 4 + 1).join(" ");
            var ret = "\n" + indent + "AggregateError of:" + "\n";
            level++;
            indent = Array(level * 4 + 1).join(" ");
            for (var i = 0; i < this.length; ++i) {
              var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
              var lines = str.split("\n");
              for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
              }
              str = lines.join("\n");
              ret += str + "\n";
            }
            level--;
            return ret;
          };
          function OperationalError(message) {
            if (!(this instanceof OperationalError))
              return new OperationalError(message);
            notEnumerableProp(this, "name", "OperationalError");
            notEnumerableProp(this, "message", message);
            this.cause = message;
            this["isOperational"] = true;
            if (message instanceof Error) {
              notEnumerableProp(this, "message", message.message);
              notEnumerableProp(this, "stack", message.stack);
            } else if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          }
          inherits(OperationalError, Error);
          var errorTypes = Error["__BluebirdErrorTypes__"];
          if (!errorTypes) {
            errorTypes = Objectfreeze({
              CancellationError: CancellationError,
              TimeoutError: TimeoutError,
              OperationalError: OperationalError,
              RejectionError: OperationalError,
              AggregateError: AggregateError
            });
            notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
          }
          module.exports = {
            Error: Error,
            TypeError: _TypeError,
            RangeError: _RangeError,
            CancellationError: errorTypes.CancellationError,
            OperationalError: errorTypes.OperationalError,
            TimeoutError: errorTypes.TimeoutError,
            AggregateError: errorTypes.AggregateError,
            Warning: Warning
          };
        }, {
          "./es5.js": 14,
          "./util.js": 38
        }],
        14: [function(_dereq_, module, exports) {
          var isES5 = (function() {
            "use strict";
            return this === undefined;
          })();
          if (isES5) {
            module.exports = {
              freeze: Object.freeze,
              defineProperty: Object.defineProperty,
              getDescriptor: Object.getOwnPropertyDescriptor,
              keys: Object.keys,
              names: Object.getOwnPropertyNames,
              getPrototypeOf: Object.getPrototypeOf,
              isArray: Array.isArray,
              isES5: isES5,
              propertyIsWritable: function(obj, prop) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                return !!(!descriptor || descriptor.writable || descriptor.set);
              }
            };
          } else {
            var has = {}.hasOwnProperty;
            var str = {}.toString;
            var proto = {}.constructor.prototype;
            var ObjectKeys = function(o) {
              var ret = [];
              for (var key in o) {
                if (has.call(o, key)) {
                  ret.push(key);
                }
              }
              return ret;
            };
            var ObjectGetDescriptor = function(o, key) {
              return {value: o[key]};
            };
            var ObjectDefineProperty = function(o, key, desc) {
              o[key] = desc.value;
              return o;
            };
            var ObjectFreeze = function(obj) {
              return obj;
            };
            var ObjectGetPrototypeOf = function(obj) {
              try {
                return Object(obj).constructor.prototype;
              } catch (e) {
                return proto;
              }
            };
            var ArrayIsArray = function(obj) {
              try {
                return str.call(obj) === "[object Array]";
              } catch (e) {
                return false;
              }
            };
            module.exports = {
              isArray: ArrayIsArray,
              keys: ObjectKeys,
              names: ObjectKeys,
              defineProperty: ObjectDefineProperty,
              getDescriptor: ObjectGetDescriptor,
              freeze: ObjectFreeze,
              getPrototypeOf: ObjectGetPrototypeOf,
              isES5: isES5,
              propertyIsWritable: function() {
                return true;
              }
            };
          }
        }, {}],
        15: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var PromiseMap = Promise.map;
            Promise.prototype.filter = function(fn, options) {
              return PromiseMap(this, fn, options, INTERNAL);
            };
            Promise.filter = function(promises, fn, options) {
              return PromiseMap(promises, fn, options, INTERNAL);
            };
          };
        }, {}],
        16: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
            var util = _dereq_("./util.js");
            var isPrimitive = util.isPrimitive;
            var thrower = util.thrower;
            function returnThis() {
              return this;
            }
            function throwThis() {
              throw this;
            }
            function return$(r) {
              return function() {
                return r;
              };
            }
            function throw$(r) {
              return function() {
                throw r;
              };
            }
            function promisedFinally(ret, reasonOrValue, isFulfilled) {
              var then;
              if (isPrimitive(reasonOrValue)) {
                then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
              } else {
                then = isFulfilled ? returnThis : throwThis;
              }
              return ret._then(then, thrower, undefined, reasonOrValue, undefined);
            }
            function finallyHandler(reasonOrValue) {
              var promise = this.promise;
              var handler = this.handler;
              var ret = promise._isBound() ? handler.call(promise._boundValue()) : handler();
              if (ret !== undefined) {
                var maybePromise = tryConvertToPromise(ret, promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  return promisedFinally(maybePromise, reasonOrValue, promise.isFulfilled());
                }
              }
              if (promise.isRejected()) {
                NEXT_FILTER.e = reasonOrValue;
                return NEXT_FILTER;
              } else {
                return reasonOrValue;
              }
            }
            function tapHandler(value) {
              var promise = this.promise;
              var handler = this.handler;
              var ret = promise._isBound() ? handler.call(promise._boundValue(), value) : handler(value);
              if (ret !== undefined) {
                var maybePromise = tryConvertToPromise(ret, promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  return promisedFinally(maybePromise, value, true);
                }
              }
              return value;
            }
            Promise.prototype._passThroughHandler = function(handler, isFinally) {
              if (typeof handler !== "function")
                return this.then();
              var promiseAndHandler = {
                promise: this,
                handler: handler
              };
              return this._then(isFinally ? finallyHandler : tapHandler, isFinally ? finallyHandler : undefined, undefined, promiseAndHandler, undefined);
            };
            Promise.prototype.lastly = Promise.prototype["finally"] = function(handler) {
              return this._passThroughHandler(handler, true);
            };
            Promise.prototype.tap = function(handler) {
              return this._passThroughHandler(handler, false);
            };
          };
        }, {"./util.js": 38}],
        17: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, apiRejection, INTERNAL, tryConvertToPromise) {
            var errors = _dereq_("./errors.js");
            var TypeError = errors.TypeError;
            var util = _dereq_("./util.js");
            var errorObj = util.errorObj;
            var tryCatch = util.tryCatch;
            var yieldHandlers = [];
            function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
              for (var i = 0; i < yieldHandlers.length; ++i) {
                traceParent._pushContext();
                var result = tryCatch(yieldHandlers[i])(value);
                traceParent._popContext();
                if (result === errorObj) {
                  traceParent._pushContext();
                  var ret = Promise.reject(errorObj.e);
                  traceParent._popContext();
                  return ret;
                }
                var maybePromise = tryConvertToPromise(result, traceParent);
                if (maybePromise instanceof Promise)
                  return maybePromise;
              }
              return null;
            }
            function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
              var promise = this._promise = new Promise(INTERNAL);
              promise._captureStackTrace();
              this._stack = stack;
              this._generatorFunction = generatorFunction;
              this._receiver = receiver;
              this._generator = undefined;
              this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
            }
            PromiseSpawn.prototype.promise = function() {
              return this._promise;
            };
            PromiseSpawn.prototype._run = function() {
              this._generator = this._generatorFunction.call(this._receiver);
              this._receiver = this._generatorFunction = undefined;
              this._next(undefined);
            };
            PromiseSpawn.prototype._continue = function(result) {
              if (result === errorObj) {
                return this._promise._rejectCallback(result.e, false, true);
              }
              var value = result.value;
              if (result.done === true) {
                this._promise._resolveCallback(value);
              } else {
                var maybePromise = tryConvertToPromise(value, this._promise);
                if (!(maybePromise instanceof Promise)) {
                  maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
                  if (maybePromise === null) {
                    this._throw(new TypeError("A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) + "From coroutine:\u000a" + this._stack.split("\n").slice(1, -7).join("\n")));
                    return;
                  }
                }
                maybePromise._then(this._next, this._throw, undefined, this, null);
              }
            };
            PromiseSpawn.prototype._throw = function(reason) {
              this._promise._attachExtraTrace(reason);
              this._promise._pushContext();
              var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
              this._promise._popContext();
              this._continue(result);
            };
            PromiseSpawn.prototype._next = function(value) {
              this._promise._pushContext();
              var result = tryCatch(this._generator.next).call(this._generator, value);
              this._promise._popContext();
              this._continue(result);
            };
            Promise.coroutine = function(generatorFunction, options) {
              if (typeof generatorFunction !== "function") {
                throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
              }
              var yieldHandler = Object(options).yieldHandler;
              var PromiseSpawn$ = PromiseSpawn;
              var stack = new Error().stack;
              return function() {
                var generator = generatorFunction.apply(this, arguments);
                var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
                spawn._generator = generator;
                spawn._next(undefined);
                return spawn.promise();
              };
            };
            Promise.coroutine.addYieldHandler = function(fn) {
              if (typeof fn !== "function")
                throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              yieldHandlers.push(fn);
            };
            Promise.spawn = function(generatorFunction) {
              if (typeof generatorFunction !== "function") {
                return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
              }
              var spawn = new PromiseSpawn(generatorFunction, this);
              var ret = spawn.promise();
              spawn._run(Promise.spawn);
              return ret;
            };
          };
        }, {
          "./errors.js": 13,
          "./util.js": 38
        }],
        18: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
            var util = _dereq_("./util.js");
            var canEvaluate = util.canEvaluate;
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var reject;
            if (!true) {
              if (canEvaluate) {
                var thenCallback = function(i) {
                  return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
                };
                var caller = function(count) {
                  var values = [];
                  for (var i = 1; i <= count; ++i)
                    values.push("holder.p" + i);
                  return new Function("holder", "                                      \n\
            'use strict';                                                    \n\
            var callback = holder.fn;                                        \n\
            return callback(values);                                         \n\
            ".replace(/values/g, values.join(", ")));
                };
                var thenCallbacks = [];
                var callers = [undefined];
                for (var i = 1; i <= 5; ++i) {
                  thenCallbacks.push(thenCallback(i));
                  callers.push(caller(i));
                }
                var Holder = function(total, fn) {
                  this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
                  this.fn = fn;
                  this.total = total;
                  this.now = 0;
                };
                Holder.prototype.callers = callers;
                Holder.prototype.checkFulfillment = function(promise) {
                  var now = this.now;
                  now++;
                  var total = this.total;
                  if (now >= total) {
                    var handler = this.callers[total];
                    promise._pushContext();
                    var ret = tryCatch(handler)(this);
                    promise._popContext();
                    if (ret === errorObj) {
                      promise._rejectCallback(ret.e, false, true);
                    } else {
                      promise._resolveCallback(ret);
                    }
                  } else {
                    this.now = now;
                  }
                };
                var reject = function(reason) {
                  this._reject(reason);
                };
              }
            }
            Promise.join = function() {
              var last = arguments.length - 1;
              var fn;
              if (last > 0 && typeof arguments[last] === "function") {
                fn = arguments[last];
                if (!true) {
                  if (last < 6 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var holder = new Holder(last, fn);
                    var callbacks = thenCallbacks;
                    for (var i = 0; i < last; ++i) {
                      var maybePromise = tryConvertToPromise(arguments[i], ret);
                      if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        if (maybePromise._isPending()) {
                          maybePromise._then(callbacks[i], reject, undefined, ret, holder);
                        } else if (maybePromise._isFulfilled()) {
                          callbacks[i].call(ret, maybePromise._value(), holder);
                        } else {
                          ret._reject(maybePromise._reason());
                        }
                      } else {
                        callbacks[i].call(ret, maybePromise, holder);
                      }
                    }
                    return ret;
                  }
                }
              }
              var $_len = arguments.length;
              var args = new Array($_len);
              for (var $_i = 0; $_i < $_len; ++$_i) {
                args[$_i] = arguments[$_i];
              }
              if (fn)
                args.pop();
              var ret = new PromiseArray(args).promise();
              return fn !== undefined ? ret.spread(fn) : ret;
            };
          };
        }, {"./util.js": 38}],
        19: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
            var getDomain = Promise._getDomain;
            var async = _dereq_("./async.js");
            var util = _dereq_("./util.js");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var PENDING = {};
            var EMPTY_ARRAY = [];
            function MappingPromiseArray(promises, fn, limit, _filter) {
              this.constructor$(promises);
              this._promise._captureStackTrace();
              var domain = getDomain();
              this._callback = domain === null ? fn : domain.bind(fn);
              this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
              this._limit = limit;
              this._inFlight = 0;
              this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
              async.invoke(init, this, undefined);
            }
            util.inherits(MappingPromiseArray, PromiseArray);
            function init() {
              this._init$(undefined, -2);
            }
            MappingPromiseArray.prototype._init = function() {};
            MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
              var values = this._values;
              var length = this.length();
              var preservedValues = this._preservedValues;
              var limit = this._limit;
              if (values[index] === PENDING) {
                values[index] = value;
                if (limit >= 1) {
                  this._inFlight--;
                  this._drainQueue();
                  if (this._isResolved())
                    return;
                }
              } else {
                if (limit >= 1 && this._inFlight >= limit) {
                  values[index] = value;
                  this._queue.push(index);
                  return;
                }
                if (preservedValues !== null)
                  preservedValues[index] = value;
                var callback = this._callback;
                var receiver = this._promise._boundValue();
                this._promise._pushContext();
                var ret = tryCatch(callback).call(receiver, value, index, length);
                this._promise._popContext();
                if (ret === errorObj)
                  return this._reject(ret.e);
                var maybePromise = tryConvertToPromise(ret, this._promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  if (maybePromise._isPending()) {
                    if (limit >= 1)
                      this._inFlight++;
                    values[index] = PENDING;
                    return maybePromise._proxyPromiseArray(this, index);
                  } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                  } else {
                    return this._reject(maybePromise._reason());
                  }
                }
                values[index] = ret;
              }
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= length) {
                if (preservedValues !== null) {
                  this._filter(values, preservedValues);
                } else {
                  this._resolve(values);
                }
              }
            };
            MappingPromiseArray.prototype._drainQueue = function() {
              var queue = this._queue;
              var limit = this._limit;
              var values = this._values;
              while (queue.length > 0 && this._inFlight < limit) {
                if (this._isResolved())
                  return;
                var index = queue.pop();
                this._promiseFulfilled(values[index], index);
              }
            };
            MappingPromiseArray.prototype._filter = function(booleans, values) {
              var len = values.length;
              var ret = new Array(len);
              var j = 0;
              for (var i = 0; i < len; ++i) {
                if (booleans[i])
                  ret[j++] = values[i];
              }
              ret.length = j;
              this._resolve(ret);
            };
            MappingPromiseArray.prototype.preservedValues = function() {
              return this._preservedValues;
            };
            function map(promises, fn, options, _filter) {
              var limit = typeof options === "object" && options !== null ? options.concurrency : 0;
              limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
              return new MappingPromiseArray(promises, fn, limit, _filter);
            }
            Promise.prototype.map = function(fn, options) {
              if (typeof fn !== "function")
                return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              return map(this, fn, options, null).promise();
            };
            Promise.map = function(promises, fn, options, _filter) {
              if (typeof fn !== "function")
                return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              return map(promises, fn, options, _filter).promise();
            };
          };
        }, {
          "./async.js": 2,
          "./util.js": 38
        }],
        20: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
            var util = _dereq_("./util.js");
            var tryCatch = util.tryCatch;
            Promise.method = function(fn) {
              if (typeof fn !== "function") {
                throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              }
              return function() {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                ret._pushContext();
                var value = tryCatch(fn).apply(this, arguments);
                ret._popContext();
                ret._resolveFromSyncValue(value);
                return ret;
              };
            };
            Promise.attempt = Promise["try"] = function(fn, args, ctx) {
              if (typeof fn !== "function") {
                return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              }
              var ret = new Promise(INTERNAL);
              ret._captureStackTrace();
              ret._pushContext();
              var value = util.isArray(args) ? tryCatch(fn).apply(ctx, args) : tryCatch(fn).call(ctx, args);
              ret._popContext();
              ret._resolveFromSyncValue(value);
              return ret;
            };
            Promise.prototype._resolveFromSyncValue = function(value) {
              if (value === util.errorObj) {
                this._rejectCallback(value.e, false, true);
              } else {
                this._resolveCallback(value, true);
              }
            };
          };
        }, {"./util.js": 38}],
        21: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var util = _dereq_("./util.js");
            var async = _dereq_("./async.js");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            function spreadAdapter(val, nodeback) {
              var promise = this;
              if (!util.isArray(val))
                return successAdapter.call(promise, val, nodeback);
              var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }
            function successAdapter(val, nodeback) {
              var promise = this;
              var receiver = promise._boundValue();
              var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }
            function errorAdapter(reason, nodeback) {
              var promise = this;
              if (!reason) {
                var target = promise._target();
                var newReason = target._getCarriedStackTrace();
                newReason.cause = reason;
                reason = newReason;
              }
              var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }
            Promise.prototype.asCallback = Promise.prototype.nodeify = function(nodeback, options) {
              if (typeof nodeback == "function") {
                var adapter = successAdapter;
                if (options !== undefined && Object(options).spread) {
                  adapter = spreadAdapter;
                }
                this._then(adapter, errorAdapter, undefined, this, nodeback);
              }
              return this;
            };
          };
        }, {
          "./async.js": 2,
          "./util.js": 38
        }],
        22: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray) {
            var util = _dereq_("./util.js");
            var async = _dereq_("./async.js");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            Promise.prototype.progressed = function(handler) {
              return this._then(undefined, undefined, handler, undefined, undefined);
            };
            Promise.prototype._progress = function(progressValue) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              this._target()._progressUnchecked(progressValue);
            };
            Promise.prototype._progressHandlerAt = function(index) {
              return index === 0 ? this._progressHandler0 : this[(index << 2) + index - 5 + 2];
            };
            Promise.prototype._doProgressWith = function(progression) {
              var progressValue = progression.value;
              var handler = progression.handler;
              var promise = progression.promise;
              var receiver = progression.receiver;
              var ret = tryCatch(handler).call(receiver, progressValue);
              if (ret === errorObj) {
                if (ret.e != null && ret.e.name !== "StopProgressPropagation") {
                  var trace = util.canAttachTrace(ret.e) ? ret.e : new Error(util.toString(ret.e));
                  promise._attachExtraTrace(trace);
                  promise._progress(ret.e);
                }
              } else if (ret instanceof Promise) {
                ret._then(promise._progress, null, null, promise, undefined);
              } else {
                promise._progress(ret);
              }
            };
            Promise.prototype._progressUnchecked = function(progressValue) {
              var len = this._length();
              var progress = this._progress;
              for (var i = 0; i < len; i++) {
                var handler = this._progressHandlerAt(i);
                var promise = this._promiseAt(i);
                if (!(promise instanceof Promise)) {
                  var receiver = this._receiverAt(i);
                  if (typeof handler === "function") {
                    handler.call(receiver, progressValue, promise);
                  } else if (receiver instanceof PromiseArray && !receiver._isResolved()) {
                    receiver._promiseProgressed(progressValue, promise);
                  }
                  continue;
                }
                if (typeof handler === "function") {
                  async.invoke(this._doProgressWith, this, {
                    handler: handler,
                    promise: promise,
                    receiver: this._receiverAt(i),
                    value: progressValue
                  });
                } else {
                  async.invoke(progress, promise, progressValue);
                }
              }
            };
          };
        }, {
          "./async.js": 2,
          "./util.js": 38
        }],
        23: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function() {
            var makeSelfResolutionError = function() {
              return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
            };
            var reflect = function() {
              return new Promise.PromiseInspection(this._target());
            };
            var apiRejection = function(msg) {
              return Promise.reject(new TypeError(msg));
            };
            var util = _dereq_("./util.js");
            var getDomain;
            if (util.isNode) {
              getDomain = function() {
                var ret = process.domain;
                if (ret === undefined)
                  ret = null;
                return ret;
              };
            } else {
              getDomain = function() {
                return null;
              };
            }
            util.notEnumerableProp(Promise, "_getDomain", getDomain);
            var async = _dereq_("./async.js");
            var errors = _dereq_("./errors.js");
            var TypeError = Promise.TypeError = errors.TypeError;
            Promise.RangeError = errors.RangeError;
            Promise.CancellationError = errors.CancellationError;
            Promise.TimeoutError = errors.TimeoutError;
            Promise.OperationalError = errors.OperationalError;
            Promise.RejectionError = errors.OperationalError;
            Promise.AggregateError = errors.AggregateError;
            var INTERNAL = function() {};
            var APPLY = {};
            var NEXT_FILTER = {e: null};
            var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
            var PromiseArray = _dereq_("./promise_array.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
            var CapturedTrace = _dereq_("./captured_trace.js")();
            var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
            var createContext = _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
            var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
            var PromiseResolver = _dereq_("./promise_resolver.js");
            var nodebackForPromise = PromiseResolver._nodebackForPromise;
            var errorObj = util.errorObj;
            var tryCatch = util.tryCatch;
            function Promise(resolver) {
              if (typeof resolver !== "function") {
                throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
              }
              if (this.constructor !== Promise) {
                throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
              }
              this._bitField = 0;
              this._fulfillmentHandler0 = undefined;
              this._rejectionHandler0 = undefined;
              this._progressHandler0 = undefined;
              this._promise0 = undefined;
              this._receiver0 = undefined;
              this._settledValue = undefined;
              if (resolver !== INTERNAL)
                this._resolveFromResolver(resolver);
            }
            Promise.prototype.toString = function() {
              return "[object Promise]";
            };
            Promise.prototype.caught = Promise.prototype["catch"] = function(fn) {
              var len = arguments.length;
              if (len > 1) {
                var catchInstances = new Array(len - 1),
                    j = 0,
                    i;
                for (i = 0; i < len - 1; ++i) {
                  var item = arguments[i];
                  if (typeof item === "function") {
                    catchInstances[j++] = item;
                  } else {
                    return Promise.reject(new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
                  }
                }
                catchInstances.length = j;
                fn = arguments[i];
                var catchFilter = new CatchFilter(catchInstances, fn, this);
                return this._then(undefined, catchFilter.doFilter, undefined, catchFilter, undefined);
              }
              return this._then(undefined, fn, undefined, undefined, undefined);
            };
            Promise.prototype.reflect = function() {
              return this._then(reflect, reflect, undefined, this, undefined);
            };
            Promise.prototype.then = function(didFulfill, didReject, didProgress) {
              if (isDebugging() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
                var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
                if (arguments.length > 1) {
                  msg += ", " + util.classString(didReject);
                }
                this._warn(msg);
              }
              return this._then(didFulfill, didReject, didProgress, undefined, undefined);
            };
            Promise.prototype.done = function(didFulfill, didReject, didProgress) {
              var promise = this._then(didFulfill, didReject, didProgress, undefined, undefined);
              promise._setIsFinal();
            };
            Promise.prototype.spread = function(didFulfill, didReject) {
              return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
            };
            Promise.prototype.isCancellable = function() {
              return !this.isResolved() && this._cancellable();
            };
            Promise.prototype.toJSON = function() {
              var ret = {
                isFulfilled: false,
                isRejected: false,
                fulfillmentValue: undefined,
                rejectionReason: undefined
              };
              if (this.isFulfilled()) {
                ret.fulfillmentValue = this.value();
                ret.isFulfilled = true;
              } else if (this.isRejected()) {
                ret.rejectionReason = this.reason();
                ret.isRejected = true;
              }
              return ret;
            };
            Promise.prototype.all = function() {
              return new PromiseArray(this).promise();
            };
            Promise.prototype.error = function(fn) {
              return this.caught(util.originatesFromRejection, fn);
            };
            Promise.is = function(val) {
              return val instanceof Promise;
            };
            Promise.fromNode = function(fn) {
              var ret = new Promise(INTERNAL);
              var result = tryCatch(fn)(nodebackForPromise(ret));
              if (result === errorObj) {
                ret._rejectCallback(result.e, true, true);
              }
              return ret;
            };
            Promise.all = function(promises) {
              return new PromiseArray(promises).promise();
            };
            Promise.defer = Promise.pending = function() {
              var promise = new Promise(INTERNAL);
              return new PromiseResolver(promise);
            };
            Promise.cast = function(obj) {
              var ret = tryConvertToPromise(obj);
              if (!(ret instanceof Promise)) {
                var val = ret;
                ret = new Promise(INTERNAL);
                ret._fulfillUnchecked(val);
              }
              return ret;
            };
            Promise.resolve = Promise.fulfilled = Promise.cast;
            Promise.reject = Promise.rejected = function(reason) {
              var ret = new Promise(INTERNAL);
              ret._captureStackTrace();
              ret._rejectCallback(reason, true);
              return ret;
            };
            Promise.setScheduler = function(fn) {
              if (typeof fn !== "function")
                throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              var prev = async._schedule;
              async._schedule = fn;
              return prev;
            };
            Promise.prototype._then = function(didFulfill, didReject, didProgress, receiver, internalData) {
              var haveInternalData = internalData !== undefined;
              var ret = haveInternalData ? internalData : new Promise(INTERNAL);
              if (!haveInternalData) {
                ret._propagateFrom(this, 4 | 1);
                ret._captureStackTrace();
              }
              var target = this._target();
              if (target !== this) {
                if (receiver === undefined)
                  receiver = this._boundTo;
                if (!haveInternalData)
                  ret._setIsMigrated();
              }
              var callbackIndex = target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver, getDomain());
              if (target._isResolved() && !target._isSettlePromisesQueued()) {
                async.invoke(target._settlePromiseAtPostResolution, target, callbackIndex);
              }
              return ret;
            };
            Promise.prototype._settlePromiseAtPostResolution = function(index) {
              if (this._isRejectionUnhandled())
                this._unsetRejectionIsUnhandled();
              this._settlePromiseAt(index);
            };
            Promise.prototype._length = function() {
              return this._bitField & 131071;
            };
            Promise.prototype._isFollowingOrFulfilledOrRejected = function() {
              return (this._bitField & 939524096) > 0;
            };
            Promise.prototype._isFollowing = function() {
              return (this._bitField & 536870912) === 536870912;
            };
            Promise.prototype._setLength = function(len) {
              this._bitField = (this._bitField & -131072) | (len & 131071);
            };
            Promise.prototype._setFulfilled = function() {
              this._bitField = this._bitField | 268435456;
            };
            Promise.prototype._setRejected = function() {
              this._bitField = this._bitField | 134217728;
            };
            Promise.prototype._setFollowing = function() {
              this._bitField = this._bitField | 536870912;
            };
            Promise.prototype._setIsFinal = function() {
              this._bitField = this._bitField | 33554432;
            };
            Promise.prototype._isFinal = function() {
              return (this._bitField & 33554432) > 0;
            };
            Promise.prototype._cancellable = function() {
              return (this._bitField & 67108864) > 0;
            };
            Promise.prototype._setCancellable = function() {
              this._bitField = this._bitField | 67108864;
            };
            Promise.prototype._unsetCancellable = function() {
              this._bitField = this._bitField & (~67108864);
            };
            Promise.prototype._setIsMigrated = function() {
              this._bitField = this._bitField | 4194304;
            };
            Promise.prototype._unsetIsMigrated = function() {
              this._bitField = this._bitField & (~4194304);
            };
            Promise.prototype._isMigrated = function() {
              return (this._bitField & 4194304) > 0;
            };
            Promise.prototype._receiverAt = function(index) {
              var ret = index === 0 ? this._receiver0 : this[index * 5 - 5 + 4];
              if (ret === undefined && this._isBound()) {
                return this._boundValue();
              }
              return ret;
            };
            Promise.prototype._promiseAt = function(index) {
              return index === 0 ? this._promise0 : this[index * 5 - 5 + 3];
            };
            Promise.prototype._fulfillmentHandlerAt = function(index) {
              return index === 0 ? this._fulfillmentHandler0 : this[index * 5 - 5 + 0];
            };
            Promise.prototype._rejectionHandlerAt = function(index) {
              return index === 0 ? this._rejectionHandler0 : this[index * 5 - 5 + 1];
            };
            Promise.prototype._boundValue = function() {
              var ret = this._boundTo;
              if (ret !== undefined) {
                if (ret instanceof Promise) {
                  if (ret.isFulfilled()) {
                    return ret.value();
                  } else {
                    return undefined;
                  }
                }
              }
              return ret;
            };
            Promise.prototype._migrateCallbacks = function(follower, index) {
              var fulfill = follower._fulfillmentHandlerAt(index);
              var reject = follower._rejectionHandlerAt(index);
              var progress = follower._progressHandlerAt(index);
              var promise = follower._promiseAt(index);
              var receiver = follower._receiverAt(index);
              if (promise instanceof Promise)
                promise._setIsMigrated();
              this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
            };
            Promise.prototype._addCallbacks = function(fulfill, reject, progress, promise, receiver, domain) {
              var index = this._length();
              if (index >= 131071 - 5) {
                index = 0;
                this._setLength(0);
              }
              if (index === 0) {
                this._promise0 = promise;
                if (receiver !== undefined)
                  this._receiver0 = receiver;
                if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
                  this._fulfillmentHandler0 = domain === null ? fulfill : domain.bind(fulfill);
                }
                if (typeof reject === "function") {
                  this._rejectionHandler0 = domain === null ? reject : domain.bind(reject);
                }
                if (typeof progress === "function") {
                  this._progressHandler0 = domain === null ? progress : domain.bind(progress);
                }
              } else {
                var base = index * 5 - 5;
                this[base + 3] = promise;
                this[base + 4] = receiver;
                if (typeof fulfill === "function") {
                  this[base + 0] = domain === null ? fulfill : domain.bind(fulfill);
                }
                if (typeof reject === "function") {
                  this[base + 1] = domain === null ? reject : domain.bind(reject);
                }
                if (typeof progress === "function") {
                  this[base + 2] = domain === null ? progress : domain.bind(progress);
                }
              }
              this._setLength(index + 1);
              return index;
            };
            Promise.prototype._setProxyHandlers = function(receiver, promiseSlotValue) {
              var index = this._length();
              if (index >= 131071 - 5) {
                index = 0;
                this._setLength(0);
              }
              if (index === 0) {
                this._promise0 = promiseSlotValue;
                this._receiver0 = receiver;
              } else {
                var base = index * 5 - 5;
                this[base + 3] = promiseSlotValue;
                this[base + 4] = receiver;
              }
              this._setLength(index + 1);
            };
            Promise.prototype._proxyPromiseArray = function(promiseArray, index) {
              this._setProxyHandlers(promiseArray, index);
            };
            Promise.prototype._resolveCallback = function(value, shouldBind) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              if (value === this)
                return this._rejectCallback(makeSelfResolutionError(), false, true);
              var maybePromise = tryConvertToPromise(value, this);
              if (!(maybePromise instanceof Promise))
                return this._fulfill(value);
              var propagationFlags = 1 | (shouldBind ? 4 : 0);
              this._propagateFrom(maybePromise, propagationFlags);
              var promise = maybePromise._target();
              if (promise._isPending()) {
                var len = this._length();
                for (var i = 0; i < len; ++i) {
                  promise._migrateCallbacks(this, i);
                }
                this._setFollowing();
                this._setLength(0);
                this._setFollowee(promise);
              } else if (promise._isFulfilled()) {
                this._fulfillUnchecked(promise._value());
              } else {
                this._rejectUnchecked(promise._reason(), promise._getCarriedStackTrace());
              }
            };
            Promise.prototype._rejectCallback = function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
              if (!shouldNotMarkOriginatingFromRejection) {
                util.markAsOriginatingFromRejection(reason);
              }
              var trace = util.ensureErrorObject(reason);
              var hasStack = trace === reason;
              this._attachExtraTrace(trace, synchronous ? hasStack : false);
              this._reject(reason, hasStack ? undefined : trace);
            };
            Promise.prototype._resolveFromResolver = function(resolver) {
              var promise = this;
              this._captureStackTrace();
              this._pushContext();
              var synchronous = true;
              var r = tryCatch(resolver)(function(value) {
                if (promise === null)
                  return;
                promise._resolveCallback(value);
                promise = null;
              }, function(reason) {
                if (promise === null)
                  return;
                promise._rejectCallback(reason, synchronous);
                promise = null;
              });
              synchronous = false;
              this._popContext();
              if (r !== undefined && r === errorObj && promise !== null) {
                promise._rejectCallback(r.e, true, true);
                promise = null;
              }
            };
            Promise.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
              if (promise._isRejected())
                return;
              promise._pushContext();
              var x;
              if (receiver === APPLY && !this._isRejected()) {
                x = tryCatch(handler).apply(this._boundValue(), value);
              } else {
                x = tryCatch(handler).call(receiver, value);
              }
              promise._popContext();
              if (x === errorObj || x === promise || x === NEXT_FILTER) {
                var err = x === promise ? makeSelfResolutionError() : x.e;
                promise._rejectCallback(err, false, true);
              } else {
                promise._resolveCallback(x);
              }
            };
            Promise.prototype._target = function() {
              var ret = this;
              while (ret._isFollowing())
                ret = ret._followee();
              return ret;
            };
            Promise.prototype._followee = function() {
              return this._rejectionHandler0;
            };
            Promise.prototype._setFollowee = function(promise) {
              this._rejectionHandler0 = promise;
            };
            Promise.prototype._cleanValues = function() {
              if (this._cancellable()) {
                this._cancellationParent = undefined;
              }
            };
            Promise.prototype._propagateFrom = function(parent, flags) {
              if ((flags & 1) > 0 && parent._cancellable()) {
                this._setCancellable();
                this._cancellationParent = parent;
              }
              if ((flags & 4) > 0 && parent._isBound()) {
                this._setBoundTo(parent._boundTo);
              }
            };
            Promise.prototype._fulfill = function(value) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              this._fulfillUnchecked(value);
            };
            Promise.prototype._reject = function(reason, carriedStackTrace) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              this._rejectUnchecked(reason, carriedStackTrace);
            };
            Promise.prototype._settlePromiseAt = function(index) {
              var promise = this._promiseAt(index);
              var isPromise = promise instanceof Promise;
              if (isPromise && promise._isMigrated()) {
                promise._unsetIsMigrated();
                return async.invoke(this._settlePromiseAt, this, index);
              }
              var handler = this._isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
              var carriedStackTrace = this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
              var value = this._settledValue;
              var receiver = this._receiverAt(index);
              this._clearCallbackDataAtIndex(index);
              if (typeof handler === "function") {
                if (!isPromise) {
                  handler.call(receiver, value, promise);
                } else {
                  this._settlePromiseFromHandler(handler, receiver, value, promise);
                }
              } else if (receiver instanceof PromiseArray) {
                if (!receiver._isResolved()) {
                  if (this._isFulfilled()) {
                    receiver._promiseFulfilled(value, promise);
                  } else {
                    receiver._promiseRejected(value, promise);
                  }
                }
              } else if (isPromise) {
                if (this._isFulfilled()) {
                  promise._fulfill(value);
                } else {
                  promise._reject(value, carriedStackTrace);
                }
              }
              if (index >= 4 && (index & 31) === 4)
                async.invokeLater(this._setLength, this, 0);
            };
            Promise.prototype._clearCallbackDataAtIndex = function(index) {
              if (index === 0) {
                if (!this._isCarryingStackTrace()) {
                  this._fulfillmentHandler0 = undefined;
                }
                this._rejectionHandler0 = this._progressHandler0 = this._receiver0 = this._promise0 = undefined;
              } else {
                var base = index * 5 - 5;
                this[base + 3] = this[base + 4] = this[base + 0] = this[base + 1] = this[base + 2] = undefined;
              }
            };
            Promise.prototype._isSettlePromisesQueued = function() {
              return (this._bitField & -1073741824) === -1073741824;
            };
            Promise.prototype._setSettlePromisesQueued = function() {
              this._bitField = this._bitField | -1073741824;
            };
            Promise.prototype._unsetSettlePromisesQueued = function() {
              this._bitField = this._bitField & (~-1073741824);
            };
            Promise.prototype._queueSettlePromises = function() {
              async.settlePromises(this);
              this._setSettlePromisesQueued();
            };
            Promise.prototype._fulfillUnchecked = function(value) {
              if (value === this) {
                var err = makeSelfResolutionError();
                this._attachExtraTrace(err);
                return this._rejectUnchecked(err, undefined);
              }
              this._setFulfilled();
              this._settledValue = value;
              this._cleanValues();
              if (this._length() > 0) {
                this._queueSettlePromises();
              }
            };
            Promise.prototype._rejectUncheckedCheckError = function(reason) {
              var trace = util.ensureErrorObject(reason);
              this._rejectUnchecked(reason, trace === reason ? undefined : trace);
            };
            Promise.prototype._rejectUnchecked = function(reason, trace) {
              if (reason === this) {
                var err = makeSelfResolutionError();
                this._attachExtraTrace(err);
                return this._rejectUnchecked(err);
              }
              this._setRejected();
              this._settledValue = reason;
              this._cleanValues();
              if (this._isFinal()) {
                async.throwLater(function(e) {
                  if ("stack" in e) {
                    async.invokeFirst(CapturedTrace.unhandledRejection, undefined, e);
                  }
                  throw e;
                }, trace === undefined ? reason : trace);
                return;
              }
              if (trace !== undefined && trace !== reason) {
                this._setCarriedStackTrace(trace);
              }
              if (this._length() > 0) {
                this._queueSettlePromises();
              } else {
                this._ensurePossibleRejectionHandled();
              }
            };
            Promise.prototype._settlePromises = function() {
              this._unsetSettlePromisesQueued();
              var len = this._length();
              for (var i = 0; i < len; i++) {
                this._settlePromiseAt(i);
              }
            };
            util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError);
            _dereq_("./progress.js")(Promise, PromiseArray);
            _dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
            _dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
            _dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
            _dereq_("./direct_resolve.js")(Promise);
            _dereq_("./synchronous_inspection.js")(Promise);
            _dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
            Promise.Promise = Promise;
            _dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
            _dereq_('./cancel.js')(Promise);
            _dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
            _dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
            _dereq_('./nodeify.js')(Promise);
            _dereq_('./call_get.js')(Promise);
            _dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
            _dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
            _dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
            _dereq_('./settle.js')(Promise, PromiseArray);
            _dereq_('./some.js')(Promise, PromiseArray, apiRejection);
            _dereq_('./promisify.js')(Promise, INTERNAL);
            _dereq_('./any.js')(Promise);
            _dereq_('./each.js')(Promise, INTERNAL);
            _dereq_('./timers.js')(Promise, INTERNAL);
            _dereq_('./filter.js')(Promise, INTERNAL);
            util.toFastProperties(Promise);
            util.toFastProperties(Promise.prototype);
            function fillTypes(value) {
              var p = new Promise(INTERNAL);
              p._fulfillmentHandler0 = value;
              p._rejectionHandler0 = value;
              p._progressHandler0 = value;
              p._promise0 = value;
              p._receiver0 = value;
              p._settledValue = value;
            }
            fillTypes({a: 1});
            fillTypes({b: 2});
            fillTypes({c: 3});
            fillTypes(1);
            fillTypes(function() {});
            fillTypes(undefined);
            fillTypes(false);
            fillTypes(new Promise(INTERNAL));
            CapturedTrace.setBounds(async.firstLineError, util.lastLineError);
            return Promise;
          };
        }, {
          "./any.js": 1,
          "./async.js": 2,
          "./bind.js": 3,
          "./call_get.js": 5,
          "./cancel.js": 6,
          "./captured_trace.js": 7,
          "./catch_filter.js": 8,
          "./context.js": 9,
          "./debuggability.js": 10,
          "./direct_resolve.js": 11,
          "./each.js": 12,
          "./errors.js": 13,
          "./filter.js": 15,
          "./finally.js": 16,
          "./generators.js": 17,
          "./join.js": 18,
          "./map.js": 19,
          "./method.js": 20,
          "./nodeify.js": 21,
          "./progress.js": 22,
          "./promise_array.js": 24,
          "./promise_resolver.js": 25,
          "./promisify.js": 26,
          "./props.js": 27,
          "./race.js": 29,
          "./reduce.js": 30,
          "./settle.js": 32,
          "./some.js": 33,
          "./synchronous_inspection.js": 34,
          "./thenables.js": 35,
          "./timers.js": 36,
          "./using.js": 37,
          "./util.js": 38
        }],
        24: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
            var util = _dereq_("./util.js");
            var isArray = util.isArray;
            function toResolutionValue(val) {
              switch (val) {
                case -2:
                  return [];
                case -3:
                  return {};
              }
            }
            function PromiseArray(values) {
              var promise = this._promise = new Promise(INTERNAL);
              var parent;
              if (values instanceof Promise) {
                parent = values;
                promise._propagateFrom(parent, 1 | 4);
              }
              this._values = values;
              this._length = 0;
              this._totalResolved = 0;
              this._init(undefined, -2);
            }
            PromiseArray.prototype.length = function() {
              return this._length;
            };
            PromiseArray.prototype.promise = function() {
              return this._promise;
            };
            PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
              var values = tryConvertToPromise(this._values, this._promise);
              if (values instanceof Promise) {
                values = values._target();
                this._values = values;
                if (values._isFulfilled()) {
                  values = values._value();
                  if (!isArray(values)) {
                    var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
                    this.__hardReject__(err);
                    return;
                  }
                } else if (values._isPending()) {
                  values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
                  return;
                } else {
                  this._reject(values._reason());
                  return;
                }
              } else if (!isArray(values)) {
                this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
                return;
              }
              if (values.length === 0) {
                if (resolveValueIfEmpty === -5) {
                  this._resolveEmptyArray();
                } else {
                  this._resolve(toResolutionValue(resolveValueIfEmpty));
                }
                return;
              }
              var len = this.getActualLength(values.length);
              this._length = len;
              this._values = this.shouldCopyValues() ? new Array(len) : this._values;
              var promise = this._promise;
              for (var i = 0; i < len; ++i) {
                var isResolved = this._isResolved();
                var maybePromise = tryConvertToPromise(values[i], promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  if (isResolved) {
                    maybePromise._ignoreRejections();
                  } else if (maybePromise._isPending()) {
                    maybePromise._proxyPromiseArray(this, i);
                  } else if (maybePromise._isFulfilled()) {
                    this._promiseFulfilled(maybePromise._value(), i);
                  } else {
                    this._promiseRejected(maybePromise._reason(), i);
                  }
                } else if (!isResolved) {
                  this._promiseFulfilled(maybePromise, i);
                }
              }
            };
            PromiseArray.prototype._isResolved = function() {
              return this._values === null;
            };
            PromiseArray.prototype._resolve = function(value) {
              this._values = null;
              this._promise._fulfill(value);
            };
            PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function(reason) {
              this._values = null;
              this._promise._rejectCallback(reason, false, true);
            };
            PromiseArray.prototype._promiseProgressed = function(progressValue, index) {
              this._promise._progress({
                index: index,
                value: progressValue
              });
            };
            PromiseArray.prototype._promiseFulfilled = function(value, index) {
              this._values[index] = value;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                this._resolve(this._values);
              }
            };
            PromiseArray.prototype._promiseRejected = function(reason, index) {
              this._totalResolved++;
              this._reject(reason);
            };
            PromiseArray.prototype.shouldCopyValues = function() {
              return true;
            };
            PromiseArray.prototype.getActualLength = function(len) {
              return len;
            };
            return PromiseArray;
          };
        }, {"./util.js": 38}],
        25: [function(_dereq_, module, exports) {
          "use strict";
          var util = _dereq_("./util.js");
          var maybeWrapAsError = util.maybeWrapAsError;
          var errors = _dereq_("./errors.js");
          var TimeoutError = errors.TimeoutError;
          var OperationalError = errors.OperationalError;
          var haveGetters = util.haveGetters;
          var es5 = _dereq_("./es5.js");
          function isUntypedError(obj) {
            return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
          }
          var rErrorKey = /^(?:name|message|stack|cause)$/;
          function wrapAsOperationalError(obj) {
            var ret;
            if (isUntypedError(obj)) {
              ret = new OperationalError(obj);
              ret.name = obj.name;
              ret.message = obj.message;
              ret.stack = obj.stack;
              var keys = es5.keys(obj);
              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (!rErrorKey.test(key)) {
                  ret[key] = obj[key];
                }
              }
              return ret;
            }
            util.markAsOriginatingFromRejection(obj);
            return obj;
          }
          function nodebackForPromise(promise) {
            return function(err, value) {
              if (promise === null)
                return;
              if (err) {
                var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                promise._attachExtraTrace(wrapped);
                promise._reject(wrapped);
              } else if (arguments.length > 2) {
                var $_len = arguments.length;
                var args = new Array($_len - 1);
                for (var $_i = 1; $_i < $_len; ++$_i) {
                  args[$_i - 1] = arguments[$_i];
                }
                promise._fulfill(args);
              } else {
                promise._fulfill(value);
              }
              promise = null;
            };
          }
          var PromiseResolver;
          if (!haveGetters) {
            PromiseResolver = function(promise) {
              this.promise = promise;
              this.asCallback = nodebackForPromise(promise);
              this.callback = this.asCallback;
            };
          } else {
            PromiseResolver = function(promise) {
              this.promise = promise;
            };
          }
          if (haveGetters) {
            var prop = {get: function() {
                return nodebackForPromise(this.promise);
              }};
            es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
            es5.defineProperty(PromiseResolver.prototype, "callback", prop);
          }
          PromiseResolver._nodebackForPromise = nodebackForPromise;
          PromiseResolver.prototype.toString = function() {
            return "[object PromiseResolver]";
          };
          PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function(value) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
            }
            this.promise._resolveCallback(value);
          };
          PromiseResolver.prototype.reject = function(reason) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
            }
            this.promise._rejectCallback(reason);
          };
          PromiseResolver.prototype.progress = function(value) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
            }
            this.promise._progress(value);
          };
          PromiseResolver.prototype.cancel = function(err) {
            this.promise.cancel(err);
          };
          PromiseResolver.prototype.timeout = function() {
            this.reject(new TimeoutError("timeout"));
          };
          PromiseResolver.prototype.isResolved = function() {
            return this.promise.isResolved();
          };
          PromiseResolver.prototype.toJSON = function() {
            return this.promise.toJSON();
          };
          module.exports = PromiseResolver;
        }, {
          "./errors.js": 13,
          "./es5.js": 14,
          "./util.js": 38
        }],
        26: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var THIS = {};
            var util = _dereq_("./util.js");
            var nodebackForPromise = _dereq_("./promise_resolver.js")._nodebackForPromise;
            var withAppended = util.withAppended;
            var maybeWrapAsError = util.maybeWrapAsError;
            var canEvaluate = util.canEvaluate;
            var TypeError = _dereq_("./errors").TypeError;
            var defaultSuffix = "Async";
            var defaultPromisified = {__isPromisified__: true};
            var noCopyProps = ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"];
            var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
            var defaultFilter = function(name) {
              return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
            };
            function propsFilter(key) {
              return !noCopyPropsPattern.test(key);
            }
            function isPromisified(fn) {
              try {
                return fn.__isPromisified__ === true;
              } catch (e) {
                return false;
              }
            }
            function hasPromisified(obj, key, suffix) {
              var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
              return val ? isPromisified(val) : false;
            }
            function checkValid(ret, suffix, suffixRegexp) {
              for (var i = 0; i < ret.length; i += 2) {
                var key = ret[i];
                if (suffixRegexp.test(key)) {
                  var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                  for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                      throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a".replace("%s", suffix));
                    }
                  }
                }
              }
            }
            function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
              var keys = util.inheritedDataKeys(obj);
              var ret = [];
              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                var value = obj[key];
                var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
                if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
                  ret.push(key, value);
                }
              }
              checkValid(ret, suffix, suffixRegexp);
              return ret;
            }
            var escapeIdentRegex = function(str) {
              return str.replace(/([$])/, "\\$");
            };
            var makeNodePromisifiedEval;
            if (!true) {
              var switchCaseArgumentOrder = function(likelyArgumentCount) {
                var ret = [likelyArgumentCount];
                var min = Math.max(0, likelyArgumentCount - 1 - 3);
                for (var i = likelyArgumentCount - 1; i >= min; --i) {
                  ret.push(i);
                }
                for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                  ret.push(i);
                }
                return ret;
              };
              var argumentSequence = function(argumentCount) {
                return util.filledRange(argumentCount, "_arg", "");
              };
              var parameterDeclaration = function(parameterCount) {
                return util.filledRange(Math.max(parameterCount, 3), "_arg", "");
              };
              var parameterCount = function(fn) {
                if (typeof fn.length === "number") {
                  return Math.max(Math.min(fn.length, 1023 + 1), 0);
                }
                return 0;
              };
              makeNodePromisifiedEval = function(callback, receiver, originalName, fn) {
                var newParameterCount = Math.max(0, parameterCount(fn) - 1);
                var argumentOrder = switchCaseArgumentOrder(newParameterCount);
                var shouldProxyThis = typeof callback === "string" || receiver === THIS;
                function generateCallForArgumentCount(count) {
                  var args = argumentSequence(count).join(", ");
                  var comma = count > 0 ? ", " : "";
                  var ret;
                  if (shouldProxyThis) {
                    ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                  } else {
                    ret = receiver === undefined ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                  }
                  return ret.replace("{{args}}", args).replace(", ", comma);
                }
                function generateArgumentSwitchCase() {
                  var ret = "";
                  for (var i = 0; i < argumentOrder.length; ++i) {
                    ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                  }
                  ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n"));
                  return ret;
                }
                var getFunctionCode = typeof callback === "string" ? ("this != null ? this['" + callback + "'] : fn") : "fn";
                return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", "'use strict';                            \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise);                      \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
        ".replace("Parameters", parameterDeclaration(newParameterCount)).replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode))(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
              };
            }
            function makeNodePromisifiedClosure(callback, receiver, _, fn) {
              var defaultThis = (function() {
                return this;
              })();
              var method = callback;
              if (typeof method === "string") {
                callback = fn;
              }
              function promisified() {
                var _receiver = receiver;
                if (receiver === THIS)
                  _receiver = this;
                var promise = new Promise(INTERNAL);
                promise._captureStackTrace();
                var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
                var fn = nodebackForPromise(promise);
                try {
                  cb.apply(_receiver, withAppended(arguments, fn));
                } catch (e) {
                  promise._rejectCallback(maybeWrapAsError(e), true, true);
                }
                return promise;
              }
              util.notEnumerableProp(promisified, "__isPromisified__", true);
              return promisified;
            }
            var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
            function promisifyAll(obj, suffix, filter, promisifier) {
              var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
              var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);
              for (var i = 0,
                  len = methods.length; i < len; i += 2) {
                var key = methods[i];
                var fn = methods[i + 1];
                var promisifiedKey = key + suffix;
                obj[promisifiedKey] = promisifier === makeNodePromisified ? makeNodePromisified(key, THIS, key, fn, suffix) : promisifier(fn, function() {
                  return makeNodePromisified(key, THIS, key, fn, suffix);
                });
              }
              util.toFastProperties(obj);
              return obj;
            }
            function promisify(callback, receiver) {
              return makeNodePromisified(callback, receiver, undefined, callback);
            }
            Promise.promisify = function(fn, receiver) {
              if (typeof fn !== "function") {
                throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              }
              if (isPromisified(fn)) {
                return fn;
              }
              var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
              util.copyDescriptors(fn, ret, propsFilter);
              return ret;
            };
            Promise.promisifyAll = function(target, options) {
              if (typeof target !== "function" && typeof target !== "object") {
                throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
              }
              options = Object(options);
              var suffix = options.suffix;
              if (typeof suffix !== "string")
                suffix = defaultSuffix;
              var filter = options.filter;
              if (typeof filter !== "function")
                filter = defaultFilter;
              var promisifier = options.promisifier;
              if (typeof promisifier !== "function")
                promisifier = makeNodePromisified;
              if (!util.isIdentifier(suffix)) {
                throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
              }
              var keys = util.inheritedDataKeys(target);
              for (var i = 0; i < keys.length; ++i) {
                var value = target[keys[i]];
                if (keys[i] !== "constructor" && util.isClass(value)) {
                  promisifyAll(value.prototype, suffix, filter, promisifier);
                  promisifyAll(value, suffix, filter, promisifier);
                }
              }
              return promisifyAll(target, suffix, filter, promisifier);
            };
          };
        }, {
          "./errors": 13,
          "./promise_resolver.js": 25,
          "./util.js": 38
        }],
        27: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, tryConvertToPromise, apiRejection) {
            var util = _dereq_("./util.js");
            var isObject = util.isObject;
            var es5 = _dereq_("./es5.js");
            function PropertiesPromiseArray(obj) {
              var keys = es5.keys(obj);
              var len = keys.length;
              var values = new Array(len * 2);
              for (var i = 0; i < len; ++i) {
                var key = keys[i];
                values[i] = obj[key];
                values[i + len] = key;
              }
              this.constructor$(values);
            }
            util.inherits(PropertiesPromiseArray, PromiseArray);
            PropertiesPromiseArray.prototype._init = function() {
              this._init$(undefined, -3);
            };
            PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
              this._values[index] = value;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                var val = {};
                var keyOffset = this.length();
                for (var i = 0,
                    len = this.length(); i < len; ++i) {
                  val[this._values[i + keyOffset]] = this._values[i];
                }
                this._resolve(val);
              }
            };
            PropertiesPromiseArray.prototype._promiseProgressed = function(value, index) {
              this._promise._progress({
                key: this._values[index + this.length()],
                value: value
              });
            };
            PropertiesPromiseArray.prototype.shouldCopyValues = function() {
              return false;
            };
            PropertiesPromiseArray.prototype.getActualLength = function(len) {
              return len >> 1;
            };
            function props(promises) {
              var ret;
              var castValue = tryConvertToPromise(promises);
              if (!isObject(castValue)) {
                return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
              } else if (castValue instanceof Promise) {
                ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);
              } else {
                ret = new PropertiesPromiseArray(castValue).promise();
              }
              if (castValue instanceof Promise) {
                ret._propagateFrom(castValue, 4);
              }
              return ret;
            }
            Promise.prototype.props = function() {
              return props(this);
            };
            Promise.props = function(promises) {
              return props(promises);
            };
          };
        }, {
          "./es5.js": 14,
          "./util.js": 38
        }],
        28: [function(_dereq_, module, exports) {
          "use strict";
          function arrayMove(src, srcIndex, dst, dstIndex, len) {
            for (var j = 0; j < len; ++j) {
              dst[j + dstIndex] = src[j + srcIndex];
              src[j + srcIndex] = void 0;
            }
          }
          function Queue(capacity) {
            this._capacity = capacity;
            this._length = 0;
            this._front = 0;
          }
          Queue.prototype._willBeOverCapacity = function(size) {
            return this._capacity < size;
          };
          Queue.prototype._pushOne = function(arg) {
            var length = this.length();
            this._checkCapacity(length + 1);
            var i = (this._front + length) & (this._capacity - 1);
            this[i] = arg;
            this._length = length + 1;
          };
          Queue.prototype._unshiftOne = function(value) {
            var capacity = this._capacity;
            this._checkCapacity(this.length() + 1);
            var front = this._front;
            var i = ((((front - 1) & (capacity - 1)) ^ capacity) - capacity);
            this[i] = value;
            this._front = i;
            this._length = this.length() + 1;
          };
          Queue.prototype.unshift = function(fn, receiver, arg) {
            this._unshiftOne(arg);
            this._unshiftOne(receiver);
            this._unshiftOne(fn);
          };
          Queue.prototype.push = function(fn, receiver, arg) {
            var length = this.length() + 3;
            if (this._willBeOverCapacity(length)) {
              this._pushOne(fn);
              this._pushOne(receiver);
              this._pushOne(arg);
              return;
            }
            var j = this._front + length - 3;
            this._checkCapacity(length);
            var wrapMask = this._capacity - 1;
            this[(j + 0) & wrapMask] = fn;
            this[(j + 1) & wrapMask] = receiver;
            this[(j + 2) & wrapMask] = arg;
            this._length = length;
          };
          Queue.prototype.shift = function() {
            var front = this._front,
                ret = this[front];
            this[front] = undefined;
            this._front = (front + 1) & (this._capacity - 1);
            this._length--;
            return ret;
          };
          Queue.prototype.length = function() {
            return this._length;
          };
          Queue.prototype._checkCapacity = function(size) {
            if (this._capacity < size) {
              this._resizeTo(this._capacity << 1);
            }
          };
          Queue.prototype._resizeTo = function(capacity) {
            var oldCapacity = this._capacity;
            this._capacity = capacity;
            var front = this._front;
            var length = this._length;
            var moveItemsCount = (front + length) & (oldCapacity - 1);
            arrayMove(this, 0, this, oldCapacity, moveItemsCount);
          };
          module.exports = Queue;
        }, {}],
        29: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
            var isArray = _dereq_("./util.js").isArray;
            var raceLater = function(promise) {
              return promise.then(function(array) {
                return race(array, promise);
              });
            };
            function race(promises, parent) {
              var maybePromise = tryConvertToPromise(promises);
              if (maybePromise instanceof Promise) {
                return raceLater(maybePromise);
              } else if (!isArray(promises)) {
                return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
              }
              var ret = new Promise(INTERNAL);
              if (parent !== undefined) {
                ret._propagateFrom(parent, 4 | 1);
              }
              var fulfill = ret._fulfill;
              var reject = ret._reject;
              for (var i = 0,
                  len = promises.length; i < len; ++i) {
                var val = promises[i];
                if (val === undefined && !(i in promises)) {
                  continue;
                }
                Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
              }
              return ret;
            }
            Promise.race = function(promises) {
              return race(promises, undefined);
            };
            Promise.prototype.race = function() {
              return race(this, undefined);
            };
          };
        }, {"./util.js": 38}],
        30: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
            var getDomain = Promise._getDomain;
            var async = _dereq_("./async.js");
            var util = _dereq_("./util.js");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            function ReductionPromiseArray(promises, fn, accum, _each) {
              this.constructor$(promises);
              this._promise._captureStackTrace();
              this._preservedValues = _each === INTERNAL ? [] : null;
              this._zerothIsAccum = (accum === undefined);
              this._gotAccum = false;
              this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
              this._valuesPhase = undefined;
              var maybePromise = tryConvertToPromise(accum, this._promise);
              var rejected = false;
              var isPromise = maybePromise instanceof Promise;
              if (isPromise) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  maybePromise._proxyPromiseArray(this, -1);
                } else if (maybePromise._isFulfilled()) {
                  accum = maybePromise._value();
                  this._gotAccum = true;
                } else {
                  this._reject(maybePromise._reason());
                  rejected = true;
                }
              }
              if (!(isPromise || this._zerothIsAccum))
                this._gotAccum = true;
              var domain = getDomain();
              this._callback = domain === null ? fn : domain.bind(fn);
              this._accum = accum;
              if (!rejected)
                async.invoke(init, this, undefined);
            }
            function init() {
              this._init$(undefined, -5);
            }
            util.inherits(ReductionPromiseArray, PromiseArray);
            ReductionPromiseArray.prototype._init = function() {};
            ReductionPromiseArray.prototype._resolveEmptyArray = function() {
              if (this._gotAccum || this._zerothIsAccum) {
                this._resolve(this._preservedValues !== null ? [] : this._accum);
              }
            };
            ReductionPromiseArray.prototype._promiseFulfilled = function(value, index) {
              var values = this._values;
              values[index] = value;
              var length = this.length();
              var preservedValues = this._preservedValues;
              var isEach = preservedValues !== null;
              var gotAccum = this._gotAccum;
              var valuesPhase = this._valuesPhase;
              var valuesPhaseIndex;
              if (!valuesPhase) {
                valuesPhase = this._valuesPhase = new Array(length);
                for (valuesPhaseIndex = 0; valuesPhaseIndex < length; ++valuesPhaseIndex) {
                  valuesPhase[valuesPhaseIndex] = 0;
                }
              }
              valuesPhaseIndex = valuesPhase[index];
              if (index === 0 && this._zerothIsAccum) {
                this._accum = value;
                this._gotAccum = gotAccum = true;
                valuesPhase[index] = ((valuesPhaseIndex === 0) ? 1 : 2);
              } else if (index === -1) {
                this._accum = value;
                this._gotAccum = gotAccum = true;
              } else {
                if (valuesPhaseIndex === 0) {
                  valuesPhase[index] = 1;
                } else {
                  valuesPhase[index] = 2;
                  this._accum = value;
                }
              }
              if (!gotAccum)
                return;
              var callback = this._callback;
              var receiver = this._promise._boundValue();
              var ret;
              for (var i = this._reducingIndex; i < length; ++i) {
                valuesPhaseIndex = valuesPhase[i];
                if (valuesPhaseIndex === 2) {
                  this._reducingIndex = i + 1;
                  continue;
                }
                if (valuesPhaseIndex !== 1)
                  return;
                value = values[i];
                this._promise._pushContext();
                if (isEach) {
                  preservedValues.push(value);
                  ret = tryCatch(callback).call(receiver, value, i, length);
                } else {
                  ret = tryCatch(callback).call(receiver, this._accum, value, i, length);
                }
                this._promise._popContext();
                if (ret === errorObj)
                  return this._reject(ret.e);
                var maybePromise = tryConvertToPromise(ret, this._promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  if (maybePromise._isPending()) {
                    valuesPhase[i] = 4;
                    return maybePromise._proxyPromiseArray(this, i);
                  } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                  } else {
                    return this._reject(maybePromise._reason());
                  }
                }
                this._reducingIndex = i + 1;
                this._accum = ret;
              }
              this._resolve(isEach ? preservedValues : this._accum);
            };
            function reduce(promises, fn, initialValue, _each) {
              if (typeof fn !== "function")
                return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
              return array.promise();
            }
            Promise.prototype.reduce = function(fn, initialValue) {
              return reduce(this, fn, initialValue, null);
            };
            Promise.reduce = function(promises, fn, initialValue, _each) {
              return reduce(promises, fn, initialValue, _each);
            };
          };
        }, {
          "./async.js": 2,
          "./util.js": 38
        }],
        31: [function(_dereq_, module, exports) {
          "use strict";
          var schedule;
          var util = _dereq_("./util");
          var noAsyncScheduler = function() {
            throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
          };
          if (util.isNode && typeof MutationObserver === "undefined") {
            var GlobalSetImmediate = global.setImmediate;
            var ProcessNextTick = process.nextTick;
            schedule = util.isRecentNode ? function(fn) {
              GlobalSetImmediate.call(global, fn);
            } : function(fn) {
              ProcessNextTick.call(process, fn);
            };
          } else if ((typeof MutationObserver !== "undefined") && !(typeof window !== "undefined" && window.navigator && window.navigator.standalone)) {
            schedule = function(fn) {
              var div = document.createElement("div");
              var observer = new MutationObserver(fn);
              observer.observe(div, {attributes: true});
              return function() {
                div.classList.toggle("foo");
              };
            };
            schedule.isStatic = true;
          } else if (typeof setImmediate !== "undefined") {
            schedule = function(fn) {
              setImmediate(fn);
            };
          } else if (typeof setTimeout !== "undefined") {
            schedule = function(fn) {
              setTimeout(fn, 0);
            };
          } else {
            schedule = noAsyncScheduler;
          }
          module.exports = schedule;
        }, {"./util": 38}],
        32: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray) {
            var PromiseInspection = Promise.PromiseInspection;
            var util = _dereq_("./util.js");
            function SettledPromiseArray(values) {
              this.constructor$(values);
            }
            util.inherits(SettledPromiseArray, PromiseArray);
            SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
              this._values[index] = inspection;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                this._resolve(this._values);
              }
            };
            SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
              var ret = new PromiseInspection();
              ret._bitField = 268435456;
              ret._settledValue = value;
              this._promiseResolved(index, ret);
            };
            SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
              var ret = new PromiseInspection();
              ret._bitField = 134217728;
              ret._settledValue = reason;
              this._promiseResolved(index, ret);
            };
            Promise.settle = function(promises) {
              return new SettledPromiseArray(promises).promise();
            };
            Promise.prototype.settle = function() {
              return new SettledPromiseArray(this).promise();
            };
          };
        }, {"./util.js": 38}],
        33: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, apiRejection) {
            var util = _dereq_("./util.js");
            var RangeError = _dereq_("./errors.js").RangeError;
            var AggregateError = _dereq_("./errors.js").AggregateError;
            var isArray = util.isArray;
            function SomePromiseArray(values) {
              this.constructor$(values);
              this._howMany = 0;
              this._unwrap = false;
              this._initialized = false;
            }
            util.inherits(SomePromiseArray, PromiseArray);
            SomePromiseArray.prototype._init = function() {
              if (!this._initialized) {
                return;
              }
              if (this._howMany === 0) {
                this._resolve([]);
                return;
              }
              this._init$(undefined, -5);
              var isArrayResolved = isArray(this._values);
              if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
                this._reject(this._getRangeError(this.length()));
              }
            };
            SomePromiseArray.prototype.init = function() {
              this._initialized = true;
              this._init();
            };
            SomePromiseArray.prototype.setUnwrap = function() {
              this._unwrap = true;
            };
            SomePromiseArray.prototype.howMany = function() {
              return this._howMany;
            };
            SomePromiseArray.prototype.setHowMany = function(count) {
              this._howMany = count;
            };
            SomePromiseArray.prototype._promiseFulfilled = function(value) {
              this._addFulfilled(value);
              if (this._fulfilled() === this.howMany()) {
                this._values.length = this.howMany();
                if (this.howMany() === 1 && this._unwrap) {
                  this._resolve(this._values[0]);
                } else {
                  this._resolve(this._values);
                }
              }
            };
            SomePromiseArray.prototype._promiseRejected = function(reason) {
              this._addRejected(reason);
              if (this.howMany() > this._canPossiblyFulfill()) {
                var e = new AggregateError();
                for (var i = this.length(); i < this._values.length; ++i) {
                  e.push(this._values[i]);
                }
                this._reject(e);
              }
            };
            SomePromiseArray.prototype._fulfilled = function() {
              return this._totalResolved;
            };
            SomePromiseArray.prototype._rejected = function() {
              return this._values.length - this.length();
            };
            SomePromiseArray.prototype._addRejected = function(reason) {
              this._values.push(reason);
            };
            SomePromiseArray.prototype._addFulfilled = function(value) {
              this._values[this._totalResolved++] = value;
            };
            SomePromiseArray.prototype._canPossiblyFulfill = function() {
              return this.length() - this._rejected();
            };
            SomePromiseArray.prototype._getRangeError = function(count) {
              var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
              return new RangeError(message);
            };
            SomePromiseArray.prototype._resolveEmptyArray = function() {
              this._reject(this._getRangeError(0));
            };
            function some(promises, howMany) {
              if ((howMany | 0) !== howMany || howMany < 0) {
                return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
              }
              var ret = new SomePromiseArray(promises);
              var promise = ret.promise();
              ret.setHowMany(howMany);
              ret.init();
              return promise;
            }
            Promise.some = function(promises, howMany) {
              return some(promises, howMany);
            };
            Promise.prototype.some = function(howMany) {
              return some(this, howMany);
            };
            Promise._SomePromiseArray = SomePromiseArray;
          };
        }, {
          "./errors.js": 13,
          "./util.js": 38
        }],
        34: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            function PromiseInspection(promise) {
              if (promise !== undefined) {
                promise = promise._target();
                this._bitField = promise._bitField;
                this._settledValue = promise._settledValue;
              } else {
                this._bitField = 0;
                this._settledValue = undefined;
              }
            }
            PromiseInspection.prototype.value = function() {
              if (!this.isFulfilled()) {
                throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
              }
              return this._settledValue;
            };
            PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
              if (!this.isRejected()) {
                throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
              }
              return this._settledValue;
            };
            PromiseInspection.prototype.isFulfilled = Promise.prototype._isFulfilled = function() {
              return (this._bitField & 268435456) > 0;
            };
            PromiseInspection.prototype.isRejected = Promise.prototype._isRejected = function() {
              return (this._bitField & 134217728) > 0;
            };
            PromiseInspection.prototype.isPending = Promise.prototype._isPending = function() {
              return (this._bitField & 402653184) === 0;
            };
            PromiseInspection.prototype.isResolved = Promise.prototype._isResolved = function() {
              return (this._bitField & 402653184) > 0;
            };
            Promise.prototype.isPending = function() {
              return this._target()._isPending();
            };
            Promise.prototype.isRejected = function() {
              return this._target()._isRejected();
            };
            Promise.prototype.isFulfilled = function() {
              return this._target()._isFulfilled();
            };
            Promise.prototype.isResolved = function() {
              return this._target()._isResolved();
            };
            Promise.prototype._value = function() {
              return this._settledValue;
            };
            Promise.prototype._reason = function() {
              this._unsetRejectionIsUnhandled();
              return this._settledValue;
            };
            Promise.prototype.value = function() {
              var target = this._target();
              if (!target.isFulfilled()) {
                throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
              }
              return target._settledValue;
            };
            Promise.prototype.reason = function() {
              var target = this._target();
              if (!target.isRejected()) {
                throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
              }
              target._unsetRejectionIsUnhandled();
              return target._settledValue;
            };
            Promise.PromiseInspection = PromiseInspection;
          };
        }, {}],
        35: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var util = _dereq_("./util.js");
            var errorObj = util.errorObj;
            var isObject = util.isObject;
            function tryConvertToPromise(obj, context) {
              if (isObject(obj)) {
                if (obj instanceof Promise) {
                  return obj;
                } else if (isAnyBluebirdPromise(obj)) {
                  var ret = new Promise(INTERNAL);
                  obj._then(ret._fulfillUnchecked, ret._rejectUncheckedCheckError, ret._progressUnchecked, ret, null);
                  return ret;
                }
                var then = util.tryCatch(getThen)(obj);
                if (then === errorObj) {
                  if (context)
                    context._pushContext();
                  var ret = Promise.reject(then.e);
                  if (context)
                    context._popContext();
                  return ret;
                } else if (typeof then === "function") {
                  return doThenable(obj, then, context);
                }
              }
              return obj;
            }
            function getThen(obj) {
              return obj.then;
            }
            var hasProp = {}.hasOwnProperty;
            function isAnyBluebirdPromise(obj) {
              return hasProp.call(obj, "_promise0");
            }
            function doThenable(x, then, context) {
              var promise = new Promise(INTERNAL);
              var ret = promise;
              if (context)
                context._pushContext();
              promise._captureStackTrace();
              if (context)
                context._popContext();
              var synchronous = true;
              var result = util.tryCatch(then).call(x, resolveFromThenable, rejectFromThenable, progressFromThenable);
              synchronous = false;
              if (promise && result === errorObj) {
                promise._rejectCallback(result.e, true, true);
                promise = null;
              }
              function resolveFromThenable(value) {
                if (!promise)
                  return;
                promise._resolveCallback(value);
                promise = null;
              }
              function rejectFromThenable(reason) {
                if (!promise)
                  return;
                promise._rejectCallback(reason, synchronous, true);
                promise = null;
              }
              function progressFromThenable(value) {
                if (!promise)
                  return;
                if (typeof promise._progress === "function") {
                  promise._progress(value);
                }
              }
              return ret;
            }
            return tryConvertToPromise;
          };
        }, {"./util.js": 38}],
        36: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var util = _dereq_("./util.js");
            var TimeoutError = Promise.TimeoutError;
            var afterTimeout = function(promise, message) {
              if (!promise.isPending())
                return;
              if (typeof message !== "string") {
                message = "operation timed out";
              }
              var err = new TimeoutError(message);
              util.markAsOriginatingFromRejection(err);
              promise._attachExtraTrace(err);
              promise._cancel(err);
            };
            var afterValue = function(value) {
              return delay(+this).thenReturn(value);
            };
            var delay = Promise.delay = function(value, ms) {
              if (ms === undefined) {
                ms = value;
                value = undefined;
                var ret = new Promise(INTERNAL);
                setTimeout(function() {
                  ret._fulfill();
                }, ms);
                return ret;
              }
              ms = +ms;
              return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
            };
            Promise.prototype.delay = function(ms) {
              return delay(this, ms);
            };
            function successClear(value) {
              var handle = this;
              if (handle instanceof Number)
                handle = +handle;
              clearTimeout(handle);
              return value;
            }
            function failureClear(reason) {
              var handle = this;
              if (handle instanceof Number)
                handle = +handle;
              clearTimeout(handle);
              throw reason;
            }
            Promise.prototype.timeout = function(ms, message) {
              ms = +ms;
              var ret = this.then().cancellable();
              ret._cancellationParent = this;
              var handle = setTimeout(function timeoutTimeout() {
                afterTimeout(ret, message);
              }, ms);
              return ret._then(successClear, failureClear, undefined, handle, undefined);
            };
          };
        }, {"./util.js": 38}],
        37: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, apiRejection, tryConvertToPromise, createContext) {
            var TypeError = _dereq_("./errors.js").TypeError;
            var inherits = _dereq_("./util.js").inherits;
            var PromiseInspection = Promise.PromiseInspection;
            function inspectionMapper(inspections) {
              var len = inspections.length;
              for (var i = 0; i < len; ++i) {
                var inspection = inspections[i];
                if (inspection.isRejected()) {
                  return Promise.reject(inspection.error());
                }
                inspections[i] = inspection._settledValue;
              }
              return inspections;
            }
            function thrower(e) {
              setTimeout(function() {
                throw e;
              }, 0);
            }
            function castPreservingDisposable(thenable) {
              var maybePromise = tryConvertToPromise(thenable);
              if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
                maybePromise._setDisposable(thenable._getDisposer());
              }
              return maybePromise;
            }
            function dispose(resources, inspection) {
              var i = 0;
              var len = resources.length;
              var ret = Promise.defer();
              function iterator() {
                if (i >= len)
                  return ret.resolve();
                var maybePromise = castPreservingDisposable(resources[i++]);
                if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                  try {
                    maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                  } catch (e) {
                    return thrower(e);
                  }
                  if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower, null, null, null);
                  }
                }
                iterator();
              }
              iterator();
              return ret.promise;
            }
            function disposerSuccess(value) {
              var inspection = new PromiseInspection();
              inspection._settledValue = value;
              inspection._bitField = 268435456;
              return dispose(this, inspection).thenReturn(value);
            }
            function disposerFail(reason) {
              var inspection = new PromiseInspection();
              inspection._settledValue = reason;
              inspection._bitField = 134217728;
              return dispose(this, inspection).thenThrow(reason);
            }
            function Disposer(data, promise, context) {
              this._data = data;
              this._promise = promise;
              this._context = context;
            }
            Disposer.prototype.data = function() {
              return this._data;
            };
            Disposer.prototype.promise = function() {
              return this._promise;
            };
            Disposer.prototype.resource = function() {
              if (this.promise().isFulfilled()) {
                return this.promise().value();
              }
              return null;
            };
            Disposer.prototype.tryDispose = function(inspection) {
              var resource = this.resource();
              var context = this._context;
              if (context !== undefined)
                context._pushContext();
              var ret = resource !== null ? this.doDispose(resource, inspection) : null;
              if (context !== undefined)
                context._popContext();
              this._promise._unsetDisposable();
              this._data = null;
              return ret;
            };
            Disposer.isDisposer = function(d) {
              return (d != null && typeof d.resource === "function" && typeof d.tryDispose === "function");
            };
            function FunctionDisposer(fn, promise, context) {
              this.constructor$(fn, promise, context);
            }
            inherits(FunctionDisposer, Disposer);
            FunctionDisposer.prototype.doDispose = function(resource, inspection) {
              var fn = this.data();
              return fn.call(resource, resource, inspection);
            };
            function maybeUnwrapDisposer(value) {
              if (Disposer.isDisposer(value)) {
                this.resources[this.index]._setDisposable(value);
                return value.promise();
              }
              return value;
            }
            Promise.using = function() {
              var len = arguments.length;
              if (len < 2)
                return apiRejection("you must pass at least 2 arguments to Promise.using");
              var fn = arguments[len - 1];
              if (typeof fn !== "function")
                return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              len--;
              var resources = new Array(len);
              for (var i = 0; i < len; ++i) {
                var resource = arguments[i];
                if (Disposer.isDisposer(resource)) {
                  var disposer = resource;
                  resource = resource.promise();
                  resource._setDisposable(disposer);
                } else {
                  var maybePromise = tryConvertToPromise(resource);
                  if (maybePromise instanceof Promise) {
                    resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                      resources: resources,
                      index: i
                    }, undefined);
                  }
                }
                resources[i] = resource;
              }
              var promise = Promise.settle(resources).then(inspectionMapper).then(function(vals) {
                promise._pushContext();
                var ret;
                try {
                  ret = fn.apply(undefined, vals);
                } finally {
                  promise._popContext();
                }
                return ret;
              })._then(disposerSuccess, disposerFail, undefined, resources, undefined);
              resources.promise = promise;
              return promise;
            };
            Promise.prototype._setDisposable = function(disposer) {
              this._bitField = this._bitField | 262144;
              this._disposer = disposer;
            };
            Promise.prototype._isDisposable = function() {
              return (this._bitField & 262144) > 0;
            };
            Promise.prototype._getDisposer = function() {
              return this._disposer;
            };
            Promise.prototype._unsetDisposable = function() {
              this._bitField = this._bitField & (~262144);
              this._disposer = undefined;
            };
            Promise.prototype.disposer = function(fn) {
              if (typeof fn === "function") {
                return new FunctionDisposer(fn, this, createContext());
              }
              throw new TypeError();
            };
          };
        }, {
          "./errors.js": 13,
          "./util.js": 38
        }],
        38: [function(_dereq_, module, exports) {
          "use strict";
          var es5 = _dereq_("./es5.js");
          var canEvaluate = typeof navigator == "undefined";
          var haveGetters = (function() {
            try {
              var o = {};
              es5.defineProperty(o, "f", {get: function() {
                  return 3;
                }});
              return o.f === 3;
            } catch (e) {
              return false;
            }
          })();
          var errorObj = {e: {}};
          var tryCatchTarget;
          function tryCatcher() {
            try {
              var target = tryCatchTarget;
              tryCatchTarget = null;
              return target.apply(this, arguments);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatch(fn) {
            tryCatchTarget = fn;
            return tryCatcher;
          }
          var inherits = function(Child, Parent) {
            var hasProp = {}.hasOwnProperty;
            function T() {
              this.constructor = Child;
              this.constructor$ = Parent;
              for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                  this[propertyName + "$"] = Parent.prototype[propertyName];
                }
              }
            }
            T.prototype = Parent.prototype;
            Child.prototype = new T();
            return Child.prototype;
          };
          function isPrimitive(val) {
            return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
          }
          function isObject(value) {
            return !isPrimitive(value);
          }
          function maybeWrapAsError(maybeError) {
            if (!isPrimitive(maybeError))
              return maybeError;
            return new Error(safeToString(maybeError));
          }
          function withAppended(target, appendee) {
            var len = target.length;
            var ret = new Array(len + 1);
            var i;
            for (i = 0; i < len; ++i) {
              ret[i] = target[i];
            }
            ret[i] = appendee;
            return ret;
          }
          function getDataPropertyOrDefault(obj, key, defaultValue) {
            if (es5.isES5) {
              var desc = Object.getOwnPropertyDescriptor(obj, key);
              if (desc != null) {
                return desc.get == null && desc.set == null ? desc.value : defaultValue;
              }
            } else {
              return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
            }
          }
          function notEnumerableProp(obj, name, value) {
            if (isPrimitive(obj))
              return obj;
            var descriptor = {
              value: value,
              configurable: true,
              enumerable: false,
              writable: true
            };
            es5.defineProperty(obj, name, descriptor);
            return obj;
          }
          function thrower(r) {
            throw r;
          }
          var inheritedDataKeys = (function() {
            var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];
            var isExcludedProto = function(val) {
              for (var i = 0; i < excludedPrototypes.length; ++i) {
                if (excludedPrototypes[i] === val) {
                  return true;
                }
              }
              return false;
            };
            if (es5.isES5) {
              var getKeys = Object.getOwnPropertyNames;
              return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && !isExcludedProto(obj)) {
                  var keys;
                  try {
                    keys = getKeys(obj);
                  } catch (e) {
                    return ret;
                  }
                  for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key])
                      continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                      ret.push(key);
                    }
                  }
                  obj = es5.getPrototypeOf(obj);
                }
                return ret;
              };
            } else {
              var hasProp = {}.hasOwnProperty;
              return function(obj) {
                if (isExcludedProto(obj))
                  return [];
                var ret = [];
                enumeration: for (var key in obj) {
                  if (hasProp.call(obj, key)) {
                    ret.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }
                    ret.push(key);
                  }
                }
                return ret;
              };
            }
          })();
          var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
          function isClass(fn) {
            try {
              if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
                var hasMethods = es5.isES5 && keys.length > 1;
                var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
                var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
                if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                  return true;
                }
              }
              return false;
            } catch (e) {
              return false;
            }
          }
          function toFastProperties(obj) {
            function f() {}
            f.prototype = obj;
            var l = 8;
            while (l--)
              new f();
            return obj;
            eval(obj);
          }
          var rident = /^[a-z$_][a-z$_0-9]*$/i;
          function isIdentifier(str) {
            return rident.test(str);
          }
          function filledRange(count, prefix, suffix) {
            var ret = new Array(count);
            for (var i = 0; i < count; ++i) {
              ret[i] = prefix + i + suffix;
            }
            return ret;
          }
          function safeToString(obj) {
            try {
              return obj + "";
            } catch (e) {
              return "[no string representation]";
            }
          }
          function markAsOriginatingFromRejection(e) {
            try {
              notEnumerableProp(e, "isOperational", true);
            } catch (ignore) {}
          }
          function originatesFromRejection(e) {
            if (e == null)
              return false;
            return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) || e["isOperational"] === true);
          }
          function canAttachTrace(obj) {
            return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
          }
          var ensureErrorObject = (function() {
            if (!("stack" in new Error())) {
              return function(value) {
                if (canAttachTrace(value))
                  return value;
                try {
                  throw new Error(safeToString(value));
                } catch (err) {
                  return err;
                }
              };
            } else {
              return function(value) {
                if (canAttachTrace(value))
                  return value;
                return new Error(safeToString(value));
              };
            }
          })();
          function classString(obj) {
            return {}.toString.call(obj);
          }
          function copyDescriptors(from, to, filter) {
            var keys = es5.names(from);
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (filter(key)) {
                try {
                  es5.defineProperty(to, key, es5.getDescriptor(from, key));
                } catch (ignore) {}
              }
            }
          }
          var ret = {
            isClass: isClass,
            isIdentifier: isIdentifier,
            inheritedDataKeys: inheritedDataKeys,
            getDataPropertyOrDefault: getDataPropertyOrDefault,
            thrower: thrower,
            isArray: es5.isArray,
            haveGetters: haveGetters,
            notEnumerableProp: notEnumerableProp,
            isPrimitive: isPrimitive,
            isObject: isObject,
            canEvaluate: canEvaluate,
            errorObj: errorObj,
            tryCatch: tryCatch,
            inherits: inherits,
            withAppended: withAppended,
            maybeWrapAsError: maybeWrapAsError,
            toFastProperties: toFastProperties,
            filledRange: filledRange,
            toString: safeToString,
            canAttachTrace: canAttachTrace,
            ensureErrorObject: ensureErrorObject,
            originatesFromRejection: originatesFromRejection,
            markAsOriginatingFromRejection: markAsOriginatingFromRejection,
            classString: classString,
            copyDescriptors: copyDescriptors,
            hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
            isNode: typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]"
          };
          ret.isRecentNode = ret.isNode && (function() {
            var version = process.versions.node.split(".").map(Number);
            return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
          })();
          if (ret.isNode)
            ret.toFastProperties(process);
          try {
            throw new Error();
          } catch (e) {
            ret.lastLineError = e;
          }
          module.exports = ret;
        }, {"./es5.js": 14}]
      }, {}, [4])(4);
    });
    ;
    if (typeof window !== 'undefined' && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== 'undefined' && self !== null) {
      self.P = self.Promise;
    }
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-util@0.1.0/index.js", ["npm:util@0.10.3.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('util') : require("npm:util@0.10.3.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.1/index.js", ["npm:process@0.10.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require("npm:process@0.10.1.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:uuid@2.0.1/rng-browser.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var rng;
  if (global.crypto && crypto.getRandomValues) {
    var _rnds8 = new Uint8Array(16);
    rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }
  if (!rng) {
    var _rnds = new Array(16);
    rng = function() {
      for (var i = 0,
          r; i < 16; i++) {
        if ((i & 0x03) === 0)
          r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }
      return _rnds;
    };
  }
  module.exports = rng;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-buffer@0.1.0/index.js", ["npm:buffer@3.4.2.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('buffer') : require("npm:buffer@3.4.2.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:querystring@0.2.0.js", ["npm:querystring@0.2.0/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:querystring@0.2.0/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:punycode@1.3.2.js", ["npm:punycode@1.3.2/punycode.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:punycode@1.3.2/punycode.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:util@0.10.3/util.js", ["npm:util@0.10.3/support/isBufferBrowser.js", "npm:inherits@2.0.1.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%')
          return '%';
        if (i >= len)
          return x;
        switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (isUndefined(global.process)) {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnviron;
    exports.debuglog = function(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
          array = false,
          braces = ['{', '}'];
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0,
          l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name,
          str,
          desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require("npm:util@0.10.3/support/isBufferBrowser.js");
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }
    exports.log = function() {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require("npm:inherits@2.0.1.js");
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4.js", ["npm:xmlbuilder@2.6.4/lib/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:xmlbuilder@2.6.4/lib/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:sax@1.1.1.js", ["npm:sax@1.1.1/lib/sax.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:sax@1.1.1/lib/sax.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xml2js@0.4.10/lib/processors.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    "use strict";
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports.normalize = function(str) {
      return str.toLowerCase();
    };
    exports.firstCharLowerCase = function(str) {
      return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports.stripPrefix = function(str) {
      return str.replace(prefixMatch, '');
    };
    exports.parseNumbers = function(str) {
      if (!isNaN(str)) {
        str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
      }
      return str;
    };
    exports.parseBooleans = function(str) {
      if (/^(?:true|false)$/i.test(str)) {
        str = str.toLowerCase() === 'true';
      }
      return str;
    };
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-events@0.1.1.js", ["github:jspm/nodelibs-events@0.1.1/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-events@0.1.1/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xml2js@0.4.10/lib/bom.js", ["npm:xml2js@0.4.10/lib/xml2js.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    "use strict";
    var xml2js;
    xml2js = require("npm:xml2js@0.4.10/lib/xml2js.js");
    exports.stripBOM = function(str) {
      if (str[0] === '\uFEFF') {
        return str.substring(1);
      } else {
        return str;
      }
    };
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:buffer@3.4.2.js", ["npm:buffer@3.4.2/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:buffer@3.4.2/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:querystring@0.2.0/index.js", ["npm:querystring@0.2.0/decode.js", "npm:querystring@0.2.0/encode.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  exports.decode = exports.parse = require("npm:querystring@0.2.0/decode.js");
  exports.encode = exports.stringify = require("npm:querystring@0.2.0/encode.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.10.1.js", ["npm:process@0.10.1/browser.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.1/browser.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:inherits@2.0.1.js", ["npm:inherits@2.0.1/inherits_browser.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:inherits@2.0.1/inherits_browser.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:util@0.10.3/support/isBufferBrowser.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:punycode@1.3.2/punycode.js", ["github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(root) {
      var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
      var freeModule = typeof module == 'object' && module && !module.nodeType && module;
      var freeGlobal = typeof global == 'object' && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode,
          maxInt = 2147483647,
          base = 36,
          tMin = 1,
          tMax = 26,
          skew = 38,
          damp = 700,
          initialBias = 72,
          initialN = 128,
          delimiter = '-',
          regexPunycode = /^xn--/,
          regexNonASCII = /[^\x20-\x7E]/,
          regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
          errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
          },
          baseMinusTMin = base - tMin,
          floor = Math.floor,
          stringFromCharCode = String.fromCharCode,
          key;
      function error(type) {
        throw RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
          result = parts[0] + '@';
          string = parts[1];
        }
        string = string.replace(regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = map(labels, fn).join('.');
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
              output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = '';
          if (value > 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
            value = 0xDC00 | value & 0x3FF;
          }
          output += stringFromCharCode(value);
          return output;
        }).join('');
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,
            baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 0x80) {
            error('not-basic');
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error('invalid-input');
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error('overflow');
            }
            i += digit * w;
            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error('overflow');
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error('overflow');
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],
            inputLength,
            handledCPCountPlusOne,
            baseMinusT,
            qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 0x80) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error('overflow');
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error('overflow');
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join('');
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
        });
      }
      punycode = {
        'version': '1.3.2',
        'ucs2': {
          'decode': ucs2decode,
          'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
      };
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('punycode', function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    }(this));
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/index.js", ["npm:lodash@3.10.1/object/assign.js", "npm:xmlbuilder@2.6.4/lib/XMLBuilder.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLBuilder,
        assign;
    assign = require("npm:lodash@3.10.1/object/assign.js");
    XMLBuilder = require("npm:xmlbuilder@2.6.4/lib/XMLBuilder.js");
    module.exports.create = function(name, xmldec, doctype, options) {
      options = assign({}, xmldec, doctype, options);
      return new XMLBuilder(name, options).root();
    };
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:querystring@0.2.0/encode.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var stringifyPrimitive = function(v) {
    switch (typeof v) {
      case 'string':
        return v;
      case 'boolean':
        return v ? 'true' : 'false';
      case 'number':
        return isFinite(v) ? v : '';
      default:
        return '';
    }
  };
  module.exports = function(obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
      obj = undefined;
    }
    if (typeof obj === 'object') {
      return Object.keys(obj).map(function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (Array.isArray(obj[k])) {
          return obj[k].map(function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);
    }
    if (!name)
      return '';
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-events@0.1.1/index.js", ["npm:events@1.0.2.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('events') : require("npm:events@1.0.2.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:sax@1.1.1/lib/sax.js", ["github:jspm/nodelibs-stream@0.1.0.js", "github:jspm/nodelibs-string_decoder@0.1.0.js", "github:jspm/nodelibs-buffer@0.1.0.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    ;
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"];
      sax.EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser))
          return new SAXParser(strict, opt);
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns)
          parser.ns = Object.create(rootNS);
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create)
        Object.create = function(o) {
          function f() {
            this.__proto__ = o;
          }
          f.prototype = o;
          return new f;
        };
      if (!Object.getPrototypeOf)
        Object.getPrototypeOf = function(o) {
          return o.__proto__;
        };
      if (!Object.keys)
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10),
            maxActual = 0;
        for (var i = 0,
            l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual) + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0,
            l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write: write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      try {
        var Stream = require("github:jspm/nodelibs-stream@0.1.0.js").Stream;
      } catch (ex) {
        var Stream = function() {};
      }
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream))
          return new SAXStream(strict, opt);
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                return me._parser["on" + ev] = h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {constructor: {value: SAXStream}});
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require("github:jspm/nodelibs-string_decoder@0.1.0.js").StringDecoder;
            this._decoder = new SD('utf8');
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length)
          this.write(chunk);
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var whitespace = "\r\n\t ",
          number = "0124356789",
          letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
          quote = "'\"",
          entity = number + letter + "#",
          attribEnd = whitespace + ">",
          CDATA = "[CDATA[",
          DOCTYPE = "DOCTYPE",
          XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace",
          XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/",
          rootNS = {
            xml: XML_NAMESPACE,
            xmlns: XMLNS_NAMESPACE
          };
      whitespace = charClass(whitespace);
      number = charClass(number);
      letter = charClass(letter);
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
      quote = charClass(quote);
      entity = charClass(entity);
      attribEnd = charClass(attribEnd);
      function charClass(str) {
        return str.split("").reduce(function(s, c) {
          s[c] = true;
          return s;
        }, {});
      }
      function isRegExp(c) {
        return Object.prototype.toString.call(c) === '[object RegExp]';
      }
      function is(charclass, c) {
        return isRegExp(charclass) ? !!c.match(charclass) : charclass[c];
      }
      function not(charclass, c) {
        return !is(charclass, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": "\"",
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": "\"",
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s = typeof e === 'number' ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
      });
      for (var S in sax.STATE)
        sax.STATE[sax.STATE[S]] = S;
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if ((parser.state !== S.BEGIN) && (parser.state !== S.BEGIN_WHITESPACE) && (parser.state !== S.TEXT))
          error(parser, "Unexpected end");
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== 'object' || !(parser instanceof SAXParser))
          throw new Error('bad call to strictFail');
        if (parser.strict)
          error(parser, message);
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser,
            tag = parser.tag = {
              name: parser.tagName,
              attributes: {}
            };
        if (parser.opt.xmlns)
          tag.ns = parent.ns;
        parser.attribList.length = 0;
      }
      function qname(name, attribute) {
        var i = name.indexOf(":"),
            qualName = i < 0 ? ["", name] : name.split(":"),
            prefix = qualName[0],
            local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return {
          prefix: prefix,
          local: local
        };
      }
      function attrib(parser) {
        if (!parser.strict)
          parser.attribName = parser.attribName[parser.looseCase]();
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          return parser.attribName = parser.attribValue = "";
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true),
              prefix = qn.prefix,
              local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\n" + "Actual: " + parser.attribValue);
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n" + "Actual: " + parser.attribValue);
            } else {
              var tag = parser.tag,
                  parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0,
              l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0],
                value = nv[1],
                qualName = qname(name, true),
                prefix = qualName.prefix,
                local = qualName.local,
                uri = prefix == "" ? "" : (tag.ns[prefix] || ""),
                a = {
                  name: name,
                  value: value,
                  prefix: prefix,
                  local: local,
                  uri: uri
                };
            if (prefix && prefix != "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict)
          tagName = tagName[parser.looseCase]();
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else
            break;
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s = parser.tags.length;
        while (s-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns)
            x[i] = tag.ns[i];
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", {
                prefix: p,
                uri: n
              });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity,
            entityLC = entity.toLowerCase(),
            num,
            numStr = "";
        if (parser.ENTITIES[entity])
          return parser.ENTITIES[entity];
        if (parser.ENTITIES[entityLC])
          return parser.ENTITIES[entityLC];
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function write(chunk) {
        var parser = this;
        if (this.error)
          throw this.error;
        if (parser.closed)
          return error(parser, "Cannot write after close. Assign an onready handler.");
        if (chunk === null)
          return end(parser);
        var i = 0,
            c = "";
        while (parser.c = c = chunk.charAt(i++)) {
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else
              parser.column++;
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
            case S.BEGIN_WHITESPACE:
              if (c === "<") {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (not(whitespace, c)) {
                strictFail(parser, "Non-whitespace before first tag.");
                parser.textNode = c;
                parser.state = S.TEXT;
              }
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = chunk.charAt(i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else
                      parser.column++;
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))
                  strictFail(parser, "Text data outside of root node.");
                if (c === "&")
                  parser.state = S.TEXT_ENTITY;
                else
                  parser.textNode += c;
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else
                parser.script += c;
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (is(whitespace, c)) {} else if (is(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot)
                  strictFail(parser, "Inappropriately located doctype declaration");
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (is(quote, c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else
                parser.sgmlDecl += c;
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[")
                  parser.state = S.DOCTYPE_DTD;
                else if (is(quote, c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]")
                parser.state = S.DOCTYPE;
              else if (is(quote, c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-")
                parser.state = S.COMMENT_ENDING;
              else
                parser.comment += c;
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment)
                  emitNode(parser, "oncomment", parser.comment);
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else
                parser.state = S.TEXT;
              continue;
            case S.CDATA:
              if (c === "]")
                parser.state = S.CDATA_ENDING;
              else
                parser.cdata += c;
              continue;
            case S.CDATA_ENDING:
              if (c === "]")
                parser.state = S.CDATA_ENDING_2;
              else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata)
                  emitNode(parser, "oncdata", parser.cdata);
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?")
                parser.state = S.PROC_INST_ENDING;
              else if (is(whitespace, c))
                parser.state = S.PROC_INST_BODY;
              else
                parser.procInstName += c;
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && is(whitespace, c))
                continue;
              else if (c === "?")
                parser.state = S.PROC_INST_ENDING;
              else
                parser.procInstBody += c;
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (is(nameBody, c))
                parser.tagName += c;
              else {
                newTag(parser);
                if (c === ">")
                  openTag(parser);
                else if (c === "/")
                  parser.state = S.OPEN_TAG_SLASH;
                else {
                  if (not(whitespace, c))
                    strictFail(parser, "Invalid character in tag name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (is(whitespace, c))
                continue;
              else if (c === ">")
                openTag(parser);
              else if (c === "/")
                parser.state = S.OPEN_TAG_SLASH;
              else if (is(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else
                strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME:
              if (c === "=")
                parser.state = S.ATTRIB_VALUE;
              else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (is(whitespace, c))
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              else if (is(nameBody, c))
                parser.attribName += c;
              else
                strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=")
                parser.state = S.ATTRIB_VALUE;
              else if (is(whitespace, c))
                continue;
              else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">")
                  openTag(parser);
                else if (is(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (is(whitespace, c))
                continue;
              else if (is(quote, c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&")
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                else
                  parser.attribValue += c;
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (is(whitespace, c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">")
                openTag(parser);
              else if (c === "/")
                parser.state = S.OPEN_TAG_SLASH;
              else if (is(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else
                strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (not(attribEnd, c)) {
                if (c === "&")
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                else
                  parser.attribValue += c;
                continue;
              }
              attrib(parser);
              if (c === ">")
                openTag(parser);
              else
                parser.state = S.ATTRIB;
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (is(whitespace, c))
                  continue;
                else if (not(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else
                  parser.tagName = c;
              } else if (c === ">")
                closeTag(parser);
              else if (is(nameBody, c))
                parser.tagName += c;
              else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (not(whitespace, c))
                  strictFail(parser, "Invalid tagname in closing tag");
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (is(whitespace, c))
                continue;
              if (c === ">")
                closeTag(parser);
              else
                strictFail(parser, "Invalid characters in closing tag");
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  var returnState = S.TEXT,
                      buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  var returnState = S.ATTRIB_VALUE_QUOTED,
                      buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  var returnState = S.ATTRIB_VALUE_UNQUOTED,
                      buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (is(entity, c))
                parser.entity += c;
              else {
                strictFail(parser, "Invalid character entity");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition)
          checkBufferLength(parser);
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 0x4000;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return '';
            }
            var result = '';
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
                throw RangeError('Invalid code point: ' + codePoint);
              }
              if (codePoint <= 0xFFFF) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 0x10000;
                highSurrogate = (codePoint >> 10) + 0xD800;
                lowSurrogate = (codePoint % 0x400) + 0xDC00;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, 'fromCodePoint', {
              'value': fromCodePoint,
              'configurable': true,
              'writable': true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        }());
      }
    })(typeof exports === "undefined" ? sax = {} : exports);
  })(require("github:jspm/nodelibs-buffer@0.1.0.js").Buffer, require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:querystring@0.2.0/decode.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  module.exports = function(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};
    if (typeof qs !== 'string' || qs.length === 0) {
      return obj;
    }
    var regexp = /\+/g;
    qs = qs.split(sep);
    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
      maxKeys = options.maxKeys;
    }
    var len = qs.length;
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }
    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr,
          vstr,
          k,
          v;
      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = '';
      }
      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);
      if (!hasOwnProperty(obj, k)) {
        obj[k] = v;
      } else if (Array.isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }
    return obj;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:buffer@3.4.2/index.js", ["npm:base64-js@0.0.8.js", "npm:ieee754@1.1.6.js", "npm:is-array@1.0.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var base64 = require("npm:base64-js@0.0.8.js");
  var ieee754 = require("npm:ieee754@1.1.6.js");
  var isArray = require("npm:is-array@1.0.1.js");
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = (function() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function() {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  })();
  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      if (arguments.length > 1)
        return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }
    this.length = 0;
    this.parent = undefined;
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }
    return fromObject(this, arg);
  }
  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '')
      encoding = 'utf8';
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);
    that.write(string, encoding);
    return that;
  }
  function fromObject(that, object) {
    if (Buffer.isBuffer(object))
      return fromBuffer(that, object);
    if (isArray(object))
      return fromArray(that, object);
    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }
    if (object.length)
      return fromArrayLike(that, object);
    return fromJsonObject(that, object);
  }
  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }
  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromJsonObject(that, object) {
    var array;
    var length = 0;
    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = Buffer._augment(new Uint8Array(length));
    } else {
      that.length = length;
      that._isBuffer = true;
    }
    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool)
      that.parent = rootParent;
    return that;
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding);
    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i])
        break;
      ++i;
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!isArray(list))
      throw new TypeError('list argument must be an Array of Buffers.');
    if (list.length === 0) {
      return new Buffer(0);
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }
    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  function byteLength(string, encoding) {
    if (typeof string !== 'string')
      string = '' + string;
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  Buffer.prototype.length = undefined;
  Buffer.prototype.parent = undefined;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0)
      return '';
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff)
      byteOffset = 0x7fffffff;
    else if (byteOffset < -0x80000000)
      byteOffset = -0x80000000;
    byteOffset >>= 0;
    if (this.length === 0)
      return -1;
    if (byteOffset >= this.length)
      return -1;
    if (byteOffset < 0)
      byteOffset = Math.max(this.length + byteOffset, 0);
    if (typeof val === 'string') {
      if (val.length === 0)
        return -1;
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }
    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === val.length)
            return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }
    throw new TypeError('val must be string, number or Buffer');
  };
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
          return asciiWrite(this, string, offset, length);
        case 'binary':
          return binaryWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var firstByte;
    var secondByte;
    var thirdByte;
    var fourthByte;
    var bytesPerSequence;
    var tempCodePoint;
    var codePoint;
    var res = [];
    var i = start;
    for (; i < end; i += bytesPerSequence) {
      firstByte = buf[i];
      codePoint = 0xFFFD;
      if (firstByte > 0xEF) {
        bytesPerSequence = 4;
      } else if (firstByte > 0xDF) {
        bytesPerSequence = 3;
      } else if (firstByte > 0xBF) {
        bytesPerSequence = 2;
      } else {
        bytesPerSequence = 1;
      }
      if (i + bytesPerSequence <= end) {
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === 0xFFFD) {
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }
      res.push(codePoint);
    }
    return String.fromCharCode.apply(String, res);
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = value;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = value;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = value;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = value;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = value;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = value;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return;
    if (this.length === 0)
      return;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (!leadSurrogate) {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1)
            bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
      }
      leadSurrogate = null;
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.10.1/browser.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:inherits@2.0.1/inherits_browser.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if (typeof Object.create === 'function') {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/object/assign.js", ["npm:lodash@3.10.1/internal/assignWith.js", "npm:lodash@3.10.1/internal/baseAssign.js", "npm:lodash@3.10.1/internal/createAssigner.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assignWith = require("npm:lodash@3.10.1/internal/assignWith.js"),
      baseAssign = require("npm:lodash@3.10.1/internal/baseAssign.js"),
      createAssigner = require("npm:lodash@3.10.1/internal/createAssigner.js");
  var assign = createAssigner(function(object, source, customizer) {
    return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
  });
  module.exports = assign;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLBuilder.js", ["npm:xmlbuilder@2.6.4/lib/XMLStringifier.js", "npm:xmlbuilder@2.6.4/lib/XMLDeclaration.js", "npm:xmlbuilder@2.6.4/lib/XMLDocType.js", "npm:xmlbuilder@2.6.4/lib/XMLElement.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLBuilder,
        XMLDeclaration,
        XMLDocType,
        XMLElement,
        XMLStringifier;
    XMLStringifier = require("npm:xmlbuilder@2.6.4/lib/XMLStringifier.js");
    XMLDeclaration = require("npm:xmlbuilder@2.6.4/lib/XMLDeclaration.js");
    XMLDocType = require("npm:xmlbuilder@2.6.4/lib/XMLDocType.js");
    XMLElement = require("npm:xmlbuilder@2.6.4/lib/XMLElement.js");
    module.exports = XMLBuilder = (function() {
      function XMLBuilder(name, options) {
        var root,
            temp;
        if (name == null) {
          throw new Error("Root element needs a name");
        }
        if (options == null) {
          options = {};
        }
        this.options = options;
        this.stringify = new XMLStringifier(options);
        temp = new XMLElement(this, 'doc');
        root = temp.element(name);
        root.isRoot = true;
        root.documentObject = this;
        this.rootObject = root;
        if (!options.headless) {
          root.declaration(options);
          if ((options.pubID != null) || (options.sysID != null)) {
            root.doctype(options);
          }
        }
      }
      XMLBuilder.prototype.root = function() {
        return this.rootObject;
      };
      XMLBuilder.prototype.end = function(options) {
        return this.toString(options);
      };
      XMLBuilder.prototype.toString = function(options) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        r = '';
        if (this.xmldec != null) {
          r += this.xmldec.toString(options);
        }
        if (this.doctype != null) {
          r += this.doctype.toString(options);
        }
        r += this.rootObject.toString(options);
        if (pretty && r.slice(-newline.length) === newline) {
          r = r.slice(0, -newline.length);
        }
        return r;
      };
      return XMLBuilder;
    })();
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:events@1.0.2.js", ["npm:events@1.0.2/events.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:events@1.0.2/events.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-string_decoder@0.1.0.js", ["github:jspm/nodelibs-string_decoder@0.1.0/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-string_decoder@0.1.0/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-stream@0.1.0.js", ["github:jspm/nodelibs-stream@0.1.0/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-stream@0.1.0/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ieee754@1.1.6.js", ["npm:ieee754@1.1.6/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:ieee754@1.1.6/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:base64-js@0.0.8.js", ["npm:base64-js@0.0.8/lib/b64.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:base64-js@0.0.8/lib/b64.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:is-array@1.0.1.js", ["npm:is-array@1.0.1/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:is-array@1.0.1/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/createAssigner.js", ["npm:lodash@3.10.1/internal/bindCallback.js", "npm:lodash@3.10.1/internal/isIterateeCall.js", "npm:lodash@3.10.1/function/restParam.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var bindCallback = require("npm:lodash@3.10.1/internal/bindCallback.js"),
      isIterateeCall = require("npm:lodash@3.10.1/internal/isIterateeCall.js"),
      restParam = require("npm:lodash@3.10.1/function/restParam.js");
  function createAssigner(assigner) {
    return restParam(function(object, sources) {
      var index = -1,
          length = object == null ? 0 : sources.length,
          customizer = length > 2 ? sources[length - 2] : undefined,
          guard = length > 2 ? sources[2] : undefined,
          thisArg = length > 1 ? sources[length - 1] : undefined;
      if (typeof customizer == 'function') {
        customizer = bindCallback(customizer, thisArg, 5);
        length -= 2;
      } else {
        customizer = typeof thisArg == 'function' ? thisArg : undefined;
        length -= (customizer ? 1 : 0);
      }
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, customizer);
        }
      }
      return object;
    });
  }
  module.exports = createAssigner;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseAssign.js", ["npm:lodash@3.10.1/internal/baseCopy.js", "npm:lodash@3.10.1/object/keys.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseCopy = require("npm:lodash@3.10.1/internal/baseCopy.js"),
      keys = require("npm:lodash@3.10.1/object/keys.js");
  function baseAssign(object, source) {
    return source == null ? object : baseCopy(source, keys(source), object);
  }
  module.exports = baseAssign;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/assignWith.js", ["npm:lodash@3.10.1/object/keys.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var keys = require("npm:lodash@3.10.1/object/keys.js");
  function assignWith(object, source, customizer) {
    var index = -1,
        props = keys(source),
        length = props.length;
    while (++index < length) {
      var key = props[index],
          value = object[key],
          result = customizer(value, source[key], key, object, source);
      if ((result === result ? (result !== value) : (value === value)) || (value === undefined && !(key in object))) {
        object[key] = result;
      }
    }
    return object;
  }
  module.exports = assignWith;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLDeclaration.js", ["npm:lodash@3.10.1/object/create.js", "npm:lodash@3.10.1/lang/isObject.js", "npm:xmlbuilder@2.6.4/lib/XMLNode.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLDeclaration,
        XMLNode,
        create,
        isObject,
        extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
    create = require("npm:lodash@3.10.1/object/create.js");
    isObject = require("npm:lodash@3.10.1/lang/isObject.js");
    XMLNode = require("npm:xmlbuilder@2.6.4/lib/XMLNode.js");
    module.exports = XMLDeclaration = (function(superClass) {
      extend(XMLDeclaration, superClass);
      function XMLDeclaration(parent, version, encoding, standalone) {
        var ref;
        XMLDeclaration.__super__.constructor.call(this, parent);
        if (isObject(version)) {
          ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
        }
        if (!version) {
          version = '1.0';
        }
        if (version != null) {
          this.version = this.stringify.xmlVersion(version);
        }
        if (encoding != null) {
          this.encoding = this.stringify.xmlEncoding(encoding);
        }
        if (standalone != null) {
          this.standalone = this.stringify.xmlStandalone(standalone);
        }
      }
      XMLDeclaration.prototype.clone = function() {
        return create(XMLDeclaration.prototype, this);
      };
      XMLDeclaration.prototype.toString = function(options, level) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += '<?xml';
        if (this.version != null) {
          r += ' version="' + this.version + '"';
        }
        if (this.encoding != null) {
          r += ' encoding="' + this.encoding + '"';
        }
        if (this.standalone != null) {
          r += ' standalone="' + this.standalone + '"';
        }
        r += '?>';
        if (pretty) {
          r += newline;
        }
        return r;
      };
      return XMLDeclaration;
    })(XMLNode);
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLElement.js", ["npm:lodash@3.10.1/object/create.js", "npm:lodash@3.10.1/lang/isObject.js", "npm:lodash@3.10.1/lang/isArray.js", "npm:lodash@3.10.1/lang/isFunction.js", "npm:lodash@3.10.1/collection/every.js", "npm:xmlbuilder@2.6.4/lib/XMLNode.js", "npm:xmlbuilder@2.6.4/lib/XMLAttribute.js", "npm:xmlbuilder@2.6.4/lib/XMLProcessingInstruction.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLAttribute,
        XMLElement,
        XMLNode,
        XMLProcessingInstruction,
        create,
        every,
        isArray,
        isFunction,
        isObject,
        extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
    create = require("npm:lodash@3.10.1/object/create.js");
    isObject = require("npm:lodash@3.10.1/lang/isObject.js");
    isArray = require("npm:lodash@3.10.1/lang/isArray.js");
    isFunction = require("npm:lodash@3.10.1/lang/isFunction.js");
    every = require("npm:lodash@3.10.1/collection/every.js");
    XMLNode = require("npm:xmlbuilder@2.6.4/lib/XMLNode.js");
    XMLAttribute = require("npm:xmlbuilder@2.6.4/lib/XMLAttribute.js");
    XMLProcessingInstruction = require("npm:xmlbuilder@2.6.4/lib/XMLProcessingInstruction.js");
    module.exports = XMLElement = (function(superClass) {
      extend(XMLElement, superClass);
      function XMLElement(parent, name, attributes) {
        XMLElement.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing element name");
        }
        this.name = this.stringify.eleName(name);
        this.children = [];
        this.instructions = [];
        this.attributes = {};
        if (attributes != null) {
          this.attribute(attributes);
        }
      }
      XMLElement.prototype.clone = function() {
        var att,
            attName,
            clonedSelf,
            i,
            len,
            pi,
            ref,
            ref1;
        clonedSelf = create(XMLElement.prototype, this);
        if (clonedSelf.isRoot) {
          clonedSelf.documentObject = null;
        }
        clonedSelf.attributes = {};
        ref = this.attributes;
        for (attName in ref) {
          if (!hasProp.call(ref, attName))
            continue;
          att = ref[attName];
          clonedSelf.attributes[attName] = att.clone();
        }
        clonedSelf.instructions = [];
        ref1 = this.instructions;
        for (i = 0, len = ref1.length; i < len; i++) {
          pi = ref1[i];
          clonedSelf.instructions.push(pi.clone());
        }
        clonedSelf.children = [];
        this.children.forEach(function(child) {
          var clonedChild;
          clonedChild = child.clone();
          clonedChild.parent = clonedSelf;
          return clonedSelf.children.push(clonedChild);
        });
        return clonedSelf;
      };
      XMLElement.prototype.attribute = function(name, value) {
        var attName,
            attValue;
        if (name != null) {
          name = name.valueOf();
        }
        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName))
              continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          if (!this.options.skipNullAttributes || (value != null)) {
            this.attributes[name] = new XMLAttribute(this, name, value);
          }
        }
        return this;
      };
      XMLElement.prototype.removeAttribute = function(name) {
        var attName,
            i,
            len;
        if (name == null) {
          throw new Error("Missing attribute name");
        }
        name = name.valueOf();
        if (isArray(name)) {
          for (i = 0, len = name.length; i < len; i++) {
            attName = name[i];
            delete this.attributes[attName];
          }
        } else {
          delete this.attributes[name];
        }
        return this;
      };
      XMLElement.prototype.instruction = function(target, value) {
        var i,
            insTarget,
            insValue,
            instruction,
            len;
        if (target != null) {
          target = target.valueOf();
        }
        if (value != null) {
          value = value.valueOf();
        }
        if (isArray(target)) {
          for (i = 0, len = target.length; i < len; i++) {
            insTarget = target[i];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget))
              continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          instruction = new XMLProcessingInstruction(this, target, value);
          this.instructions.push(instruction);
        }
        return this;
      };
      XMLElement.prototype.toString = function(options, level) {
        var att,
            child,
            i,
            indent,
            instruction,
            j,
            len,
            len1,
            name,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            ref3,
            ref4,
            ref5,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        ref3 = this.instructions;
        for (i = 0, len = ref3.length; i < len; i++) {
          instruction = ref3[i];
          r += instruction.toString(options, level + 1);
        }
        if (pretty) {
          r += space;
        }
        r += '<' + this.name;
        ref4 = this.attributes;
        for (name in ref4) {
          if (!hasProp.call(ref4, name))
            continue;
          att = ref4[name];
          r += att.toString(options);
        }
        if (this.children.length === 0 || every(this.children, function(e) {
          return e.value === '';
        })) {
          r += '/>';
          if (pretty) {
            r += newline;
          }
        } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {
          r += '>';
          r += this.children[0].value;
          r += '</' + this.name + '>';
          r += newline;
        } else {
          r += '>';
          if (pretty) {
            r += newline;
          }
          ref5 = this.children;
          for (j = 0, len1 = ref5.length; j < len1; j++) {
            child = ref5[j];
            r += child.toString(options, level + 1);
          }
          if (pretty) {
            r += space;
          }
          r += '</' + this.name + '>';
          if (pretty) {
            r += newline;
          }
        }
        return r;
      };
      XMLElement.prototype.att = function(name, value) {
        return this.attribute(name, value);
      };
      XMLElement.prototype.ins = function(target, value) {
        return this.instruction(target, value);
      };
      XMLElement.prototype.a = function(name, value) {
        return this.attribute(name, value);
      };
      XMLElement.prototype.i = function(target, value) {
        return this.instruction(target, value);
      };
      return XMLElement;
    })(XMLNode);
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLDocType.js", ["npm:lodash@3.10.1/object/create.js", "npm:lodash@3.10.1/lang/isObject.js", "npm:xmlbuilder@2.6.4/lib/XMLCData.js", "npm:xmlbuilder@2.6.4/lib/XMLComment.js", "npm:xmlbuilder@2.6.4/lib/XMLDTDAttList.js", "npm:xmlbuilder@2.6.4/lib/XMLDTDEntity.js", "npm:xmlbuilder@2.6.4/lib/XMLDTDElement.js", "npm:xmlbuilder@2.6.4/lib/XMLDTDNotation.js", "npm:xmlbuilder@2.6.4/lib/XMLProcessingInstruction.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLCData,
        XMLComment,
        XMLDTDAttList,
        XMLDTDElement,
        XMLDTDEntity,
        XMLDTDNotation,
        XMLDocType,
        XMLProcessingInstruction,
        create,
        isObject;
    create = require("npm:lodash@3.10.1/object/create.js");
    isObject = require("npm:lodash@3.10.1/lang/isObject.js");
    XMLCData = require("npm:xmlbuilder@2.6.4/lib/XMLCData.js");
    XMLComment = require("npm:xmlbuilder@2.6.4/lib/XMLComment.js");
    XMLDTDAttList = require("npm:xmlbuilder@2.6.4/lib/XMLDTDAttList.js");
    XMLDTDEntity = require("npm:xmlbuilder@2.6.4/lib/XMLDTDEntity.js");
    XMLDTDElement = require("npm:xmlbuilder@2.6.4/lib/XMLDTDElement.js");
    XMLDTDNotation = require("npm:xmlbuilder@2.6.4/lib/XMLDTDNotation.js");
    XMLProcessingInstruction = require("npm:xmlbuilder@2.6.4/lib/XMLProcessingInstruction.js");
    module.exports = XMLDocType = (function() {
      function XMLDocType(parent, pubID, sysID) {
        var ref,
            ref1;
        this.documentObject = parent;
        this.stringify = this.documentObject.stringify;
        this.children = [];
        if (isObject(pubID)) {
          ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
        }
        if (sysID == null) {
          ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
        }
        if (pubID != null) {
          this.pubID = this.stringify.dtdPubID(pubID);
        }
        if (sysID != null) {
          this.sysID = this.stringify.dtdSysID(sysID);
        }
      }
      XMLDocType.prototype.clone = function() {
        return create(XMLDocType.prototype, this);
      };
      XMLDocType.prototype.element = function(name, value) {
        var child;
        child = new XMLDTDElement(this, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var child;
        child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.children.push(child);
        return this;
      };
      XMLDocType.prototype.entity = function(name, value) {
        var child;
        child = new XMLDTDEntity(this, false, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType.prototype.pEntity = function(name, value) {
        var child;
        child = new XMLDTDEntity(this, true, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType.prototype.notation = function(name, value) {
        var child;
        child = new XMLDTDNotation(this, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType.prototype.cdata = function(value) {
        var child;
        child = new XMLCData(this, value);
        this.children.push(child);
        return this;
      };
      XMLDocType.prototype.comment = function(value) {
        var child;
        child = new XMLComment(this, value);
        this.children.push(child);
        return this;
      };
      XMLDocType.prototype.instruction = function(target, value) {
        var child;
        child = new XMLProcessingInstruction(this, target, value);
        this.children.push(child);
        return this;
      };
      XMLDocType.prototype.root = function() {
        return this.documentObject.root();
      };
      XMLDocType.prototype.document = function() {
        return this.documentObject;
      };
      XMLDocType.prototype.toString = function(options, level) {
        var child,
            i,
            indent,
            len,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            ref3,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += '<!DOCTYPE ' + this.root().name;
        if (this.pubID && this.sysID) {
          r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
        } else if (this.sysID) {
          r += ' SYSTEM "' + this.sysID + '"';
        }
        if (this.children.length > 0) {
          r += ' [';
          if (pretty) {
            r += newline;
          }
          ref3 = this.children;
          for (i = 0, len = ref3.length; i < len; i++) {
            child = ref3[i];
            r += child.toString(options, level + 1);
          }
          r += ']';
        }
        r += '>';
        if (pretty) {
          r += newline;
        }
        return r;
      };
      XMLDocType.prototype.ele = function(name, value) {
        return this.element(name, value);
      };
      XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
      };
      XMLDocType.prototype.ent = function(name, value) {
        return this.entity(name, value);
      };
      XMLDocType.prototype.pent = function(name, value) {
        return this.pEntity(name, value);
      };
      XMLDocType.prototype.not = function(name, value) {
        return this.notation(name, value);
      };
      XMLDocType.prototype.dat = function(value) {
        return this.cdata(value);
      };
      XMLDocType.prototype.com = function(value) {
        return this.comment(value);
      };
      XMLDocType.prototype.ins = function(target, value) {
        return this.instruction(target, value);
      };
      XMLDocType.prototype.up = function() {
        return this.root();
      };
      XMLDocType.prototype.doc = function() {
        return this.document();
      };
      return XMLDocType;
    })();
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:events@1.0.2/events.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function EventEmitter() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;
  EventEmitter.defaultMaxListeners = 10;
  EventEmitter.prototype.setMaxListeners = function(n) {
    if (!isNumber(n) || n < 0 || isNaN(n))
      throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };
  EventEmitter.prototype.emit = function(type) {
    var er,
        handler,
        len,
        args,
        i,
        listeners;
    if (!this._events)
      this._events = {};
    if (type === 'error') {
      if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {
        er = arguments[1];
        if (er instanceof Error) {
          throw er;
        }
        throw TypeError('Uncaught, unspecified "error" event.');
      }
    }
    handler = this._events[type];
    if (isUndefined(handler))
      return false;
    if (isFunction(handler)) {
      switch (arguments.length) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    } else if (isObject(handler)) {
      len = arguments.length;
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++)
        listeners[i].apply(this, args);
    }
    return true;
  };
  EventEmitter.prototype.addListener = function(type, listener) {
    var m;
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    if (!this._events)
      this._events = {};
    if (this._events.newListener)
      this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
    if (!this._events[type])
      this._events[type] = listener;
    else if (isObject(this._events[type]))
      this._events[type].push(listener);
    else
      this._events[type] = [this._events[type], listener];
    if (isObject(this._events[type]) && !this._events[type].warned) {
      var m;
      if (!isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }
      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
        if (typeof console.trace === 'function') {
          console.trace();
        }
      }
    }
    return this;
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.once = function(type, listener) {
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    var fired = false;
    function g() {
      this.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(this, arguments);
      }
    }
    g.listener = listener;
    this.on(type, g);
    return this;
  };
  EventEmitter.prototype.removeListener = function(type, listener) {
    var list,
        position,
        length,
        i;
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    if (!this._events || !this._events[type])
      return this;
    list = this._events[type];
    length = list.length;
    position = -1;
    if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
      delete this._events[type];
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    } else if (isObject(list)) {
      for (i = length; i-- > 0; ) {
        if (list[i] === listener || (list[i].listener && list[i].listener === listener)) {
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function(type) {
    var key,
        listeners;
    if (!this._events)
      return this;
    if (!this._events.removeListener) {
      if (arguments.length === 0)
        this._events = {};
      else if (this._events[type])
        delete this._events[type];
      return this;
    }
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener')
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }
    listeners = this._events[type];
    if (isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else {
      while (listeners.length)
        this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];
    return this;
  };
  EventEmitter.prototype.listeners = function(type) {
    var ret;
    if (!this._events || !this._events[type])
      ret = [];
    else if (isFunction(this._events[type]))
      ret = [this._events[type]];
    else
      ret = this._events[type].slice();
    return ret;
  };
  EventEmitter.listenerCount = function(emitter, type) {
    var ret;
    if (!emitter._events || !emitter._events[type])
      ret = 0;
    else if (isFunction(emitter._events[type]))
      ret = 1;
    else
      ret = emitter._events[type].length;
    return ret;
  };
  function isFunction(arg) {
    return typeof arg === 'function';
  }
  function isNumber(arg) {
    return typeof arg === 'number';
  }
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLStringifier.js", ["github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    (function() {
      var XMLStringifier,
          bind = function(fn, me) {
            return function() {
              return fn.apply(me, arguments);
            };
          },
          hasProp = {}.hasOwnProperty;
      module.exports = XMLStringifier = (function() {
        function XMLStringifier(options) {
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key,
              ref,
              value;
          this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;
          ref = (options != null ? options.stringify : void 0) || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this[key] = value;
          }
        }
        XMLStringifier.prototype.eleName = function(val) {
          val = '' + val || '';
          return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.eleText = function(val) {
          val = '' + val || '';
          return this.assertLegalChar(this.elEscape(val));
        };
        XMLStringifier.prototype.cdata = function(val) {
          val = '' + val || '';
          if (val.match(/]]>/)) {
            throw new Error("Invalid CDATA text: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.comment = function(val) {
          val = '' + val || '';
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.raw = function(val) {
          return '' + val || '';
        };
        XMLStringifier.prototype.attName = function(val) {
          return '' + val || '';
        };
        XMLStringifier.prototype.attValue = function(val) {
          val = '' + val || '';
          return this.attEscape(val);
        };
        XMLStringifier.prototype.insTarget = function(val) {
          return '' + val || '';
        };
        XMLStringifier.prototype.insValue = function(val) {
          val = '' + val || '';
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return val;
        };
        XMLStringifier.prototype.xmlVersion = function(val) {
          val = '' + val || '';
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
        XMLStringifier.prototype.xmlEncoding = function(val) {
          val = '' + val || '';
          if (!val.match(/[A-Za-z](?:[A-Za-z0-9._-]|-)*/)) {
            throw new Error("Invalid encoding: " + val);
          }
          return val;
        };
        XMLStringifier.prototype.xmlStandalone = function(val) {
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier.prototype.dtdPubID = function(val) {
          return '' + val || '';
        };
        XMLStringifier.prototype.dtdSysID = function(val) {
          return '' + val || '';
        };
        XMLStringifier.prototype.dtdElementValue = function(val) {
          return '' + val || '';
        };
        XMLStringifier.prototype.dtdAttType = function(val) {
          return '' + val || '';
        };
        XMLStringifier.prototype.dtdAttDefault = function(val) {
          if (val != null) {
            return '' + val || '';
          } else {
            return val;
          }
        };
        XMLStringifier.prototype.dtdEntityValue = function(val) {
          return '' + val || '';
        };
        XMLStringifier.prototype.dtdNData = function(val) {
          return '' + val || '';
        };
        XMLStringifier.prototype.convertAttKey = '@';
        XMLStringifier.prototype.convertPIKey = '?';
        XMLStringifier.prototype.convertTextKey = '#text';
        XMLStringifier.prototype.convertCDataKey = '#cdata';
        XMLStringifier.prototype.convertCommentKey = '#comment';
        XMLStringifier.prototype.convertRawKey = '#raw';
        XMLStringifier.prototype.convertListKey = '#list';
        XMLStringifier.prototype.assertLegalChar = function(str) {
          var chars,
              chr;
          if (this.allowSurrogateChars) {
            chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;
          } else {
            chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;
          }
          chr = str.match(chars);
          if (chr) {
            throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);
          }
          return str;
        };
        XMLStringifier.prototype.elEscape = function(str) {
          return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
        };
        XMLStringifier.prototype.attEscape = function(str) {
          return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
        };
        return XMLStringifier;
      })();
    }).call(this);
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-stream@0.1.0/index.js", ["npm:stream-browserify@1.0.0.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('stream') : require("npm:stream-browserify@1.0.0.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-string_decoder@0.1.0/index.js", ["npm:string_decoder@0.10.31.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('string_decoder') : require("npm:string_decoder@0.10.31.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:base64-js@0.0.8/lib/b64.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ieee754@1.1.6/index.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:is-array@1.0.1/index.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  var str = Object.prototype.toString;
  module.exports = isArray || function(val) {
    return !!val && '[object Array]' == str.call(val);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/isIterateeCall.js", ["npm:lodash@3.10.1/internal/isArrayLike.js", "npm:lodash@3.10.1/internal/isIndex.js", "npm:lodash@3.10.1/lang/isObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArrayLike = require("npm:lodash@3.10.1/internal/isArrayLike.js"),
      isIndex = require("npm:lodash@3.10.1/internal/isIndex.js"),
      isObject = require("npm:lodash@3.10.1/lang/isObject.js");
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
      var other = object[index];
      return value === value ? (value === other) : (other !== other);
    }
    return false;
  }
  module.exports = isIterateeCall;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/function/restParam.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var FUNC_ERROR_TEXT = 'Expected a function';
  var nativeMax = Math.max;
  function restParam(func, start) {
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          rest = Array(length);
      while (++index < length) {
        rest[index] = args[start + index];
      }
      switch (start) {
        case 0:
          return func.call(this, rest);
        case 1:
          return func.call(this, args[0], rest);
        case 2:
          return func.call(this, args[0], args[1], rest);
      }
      var otherArgs = Array(start + 1);
      index = -1;
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = rest;
      return func.apply(this, otherArgs);
    };
  }
  module.exports = restParam;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/bindCallback.js", ["npm:lodash@3.10.1/utility/identity.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var identity = require("npm:lodash@3.10.1/utility/identity.js");
  function bindCallback(func, thisArg, argCount) {
    if (typeof func != 'function') {
      return identity;
    }
    if (thisArg === undefined) {
      return func;
    }
    switch (argCount) {
      case 1:
        return function(value) {
          return func.call(thisArg, value);
        };
      case 3:
        return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
      case 4:
        return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      case 5:
        return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
    }
    return function() {
      return func.apply(thisArg, arguments);
    };
  }
  module.exports = bindCallback;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseCopy.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function baseCopy(source, props, object) {
    object || (object = {});
    var index = -1,
        length = props.length;
    while (++index < length) {
      var key = props[index];
      object[key] = source[key];
    }
    return object;
  }
  module.exports = baseCopy;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/object/keys.js", ["npm:lodash@3.10.1/internal/getNative.js", "npm:lodash@3.10.1/internal/isArrayLike.js", "npm:lodash@3.10.1/lang/isObject.js", "npm:lodash@3.10.1/internal/shimKeys.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getNative = require("npm:lodash@3.10.1/internal/getNative.js"),
      isArrayLike = require("npm:lodash@3.10.1/internal/isArrayLike.js"),
      isObject = require("npm:lodash@3.10.1/lang/isObject.js"),
      shimKeys = require("npm:lodash@3.10.1/internal/shimKeys.js");
  var nativeKeys = getNative(Object, 'keys');
  var keys = !nativeKeys ? shimKeys : function(object) {
    var Ctor = object == null ? undefined : object.constructor;
    if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && isArrayLike(object))) {
      return shimKeys(object);
    }
    return isObject(object) ? nativeKeys(object) : [];
  };
  module.exports = keys;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/object/create.js", ["npm:lodash@3.10.1/internal/baseAssign.js", "npm:lodash@3.10.1/internal/baseCreate.js", "npm:lodash@3.10.1/internal/isIterateeCall.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseAssign = require("npm:lodash@3.10.1/internal/baseAssign.js"),
      baseCreate = require("npm:lodash@3.10.1/internal/baseCreate.js"),
      isIterateeCall = require("npm:lodash@3.10.1/internal/isIterateeCall.js");
  function create(prototype, properties, guard) {
    var result = baseCreate(prototype);
    if (guard && isIterateeCall(prototype, properties, guard)) {
      properties = undefined;
    }
    return properties ? baseAssign(result, properties) : result;
  }
  module.exports = create;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/lang/isObject.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  module.exports = isObject;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLNode.js", ["npm:lodash@3.10.1/lang/isObject.js", "npm:lodash@3.10.1/lang/isArray.js", "npm:lodash@3.10.1/lang/isFunction.js", "npm:lodash@3.10.1/lang/isEmpty.js", "npm:xmlbuilder@2.6.4/lib/XMLElement.js", "npm:xmlbuilder@2.6.4/lib/XMLCData.js", "npm:xmlbuilder@2.6.4/lib/XMLComment.js", "npm:xmlbuilder@2.6.4/lib/XMLDeclaration.js", "npm:xmlbuilder@2.6.4/lib/XMLDocType.js", "npm:xmlbuilder@2.6.4/lib/XMLRaw.js", "npm:xmlbuilder@2.6.4/lib/XMLText.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLCData,
        XMLComment,
        XMLDeclaration,
        XMLDocType,
        XMLElement,
        XMLNode,
        XMLRaw,
        XMLText,
        isArray,
        isEmpty,
        isFunction,
        isObject,
        hasProp = {}.hasOwnProperty;
    isObject = require("npm:lodash@3.10.1/lang/isObject.js");
    isArray = require("npm:lodash@3.10.1/lang/isArray.js");
    isFunction = require("npm:lodash@3.10.1/lang/isFunction.js");
    isEmpty = require("npm:lodash@3.10.1/lang/isEmpty.js");
    XMLElement = null;
    XMLCData = null;
    XMLComment = null;
    XMLDeclaration = null;
    XMLDocType = null;
    XMLRaw = null;
    XMLText = null;
    module.exports = XMLNode = (function() {
      function XMLNode(parent) {
        this.parent = parent;
        this.options = this.parent.options;
        this.stringify = this.parent.stringify;
        if (XMLElement === null) {
          XMLElement = require("npm:xmlbuilder@2.6.4/lib/XMLElement.js");
          XMLCData = require("npm:xmlbuilder@2.6.4/lib/XMLCData.js");
          XMLComment = require("npm:xmlbuilder@2.6.4/lib/XMLComment.js");
          XMLDeclaration = require("npm:xmlbuilder@2.6.4/lib/XMLDeclaration.js");
          XMLDocType = require("npm:xmlbuilder@2.6.4/lib/XMLDocType.js");
          XMLRaw = require("npm:xmlbuilder@2.6.4/lib/XMLRaw.js");
          XMLText = require("npm:xmlbuilder@2.6.4/lib/XMLText.js");
        }
      }
      XMLNode.prototype.clone = function() {
        throw new Error("Cannot clone generic XMLNode");
      };
      XMLNode.prototype.element = function(name, attributes, text) {
        var item,
            j,
            key,
            lastChild,
            len,
            ref,
            val;
        lastChild = null;
        if (attributes == null) {
          attributes = {};
        }
        attributes = attributes.valueOf();
        if (!isObject(attributes)) {
          ref = [attributes, text], text = ref[0], attributes = ref[1];
        }
        if (name != null) {
          name = name.valueOf();
        }
        if (isArray(name)) {
          for (j = 0, len = name.length; j < len; j++) {
            item = name[j];
            lastChild = this.element(item);
          }
        } else if (isFunction(name)) {
          lastChild = this.element(name.apply());
        } else if (isObject(name)) {
          for (key in name) {
            if (!hasProp.call(name, key))
              continue;
            val = name[key];
            if (isFunction(val)) {
              val = val.apply();
            }
            if ((isObject(val)) && (isEmpty(val))) {
              val = null;
            }
            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && key.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);
            } else if (isObject(val)) {
              if (!this.options.ignoreDecorators && this.stringify.convertListKey && key.indexOf(this.stringify.convertListKey) === 0 && isArray(val)) {
                lastChild = this.element(val);
              } else {
                lastChild = this.element(key);
                lastChild.element(val);
              }
            } else {
              lastChild = this.element(key, val);
            }
          }
        } else {
          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
            lastChild = this.text(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
            lastChild = this.cdata(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
            lastChild = this.comment(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
            lastChild = this.raw(text);
          } else {
            lastChild = this.node(name, attributes, text);
          }
        }
        if (lastChild == null) {
          throw new Error("Could not create any elements with: " + name);
        }
        return lastChild;
      };
      XMLNode.prototype.insertBefore = function(name, attributes, text) {
        var child,
            i,
            removed;
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level");
        }
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };
      XMLNode.prototype.insertAfter = function(name, attributes, text) {
        var child,
            i,
            removed;
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level");
        }
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };
      XMLNode.prototype.remove = function() {
        var i,
            ref;
        if (this.isRoot) {
          throw new Error("Cannot remove the root element");
        }
        i = this.parent.children.indexOf(this);
        [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref = [])), ref;
        return this.parent;
      };
      XMLNode.prototype.node = function(name, attributes, text) {
        var child,
            ref;
        if (name != null) {
          name = name.valueOf();
        }
        if (attributes == null) {
          attributes = {};
        }
        attributes = attributes.valueOf();
        if (!isObject(attributes)) {
          ref = [attributes, text], text = ref[0], attributes = ref[1];
        }
        child = new XMLElement(this, name, attributes);
        if (text != null) {
          child.text(text);
        }
        this.children.push(child);
        return child;
      };
      XMLNode.prototype.text = function(value) {
        var child;
        child = new XMLText(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode.prototype.cdata = function(value) {
        var child;
        child = new XMLCData(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode.prototype.comment = function(value) {
        var child;
        child = new XMLComment(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode.prototype.raw = function(value) {
        var child;
        child = new XMLRaw(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode.prototype.declaration = function(version, encoding, standalone) {
        var doc,
            xmldec;
        doc = this.document();
        xmldec = new XMLDeclaration(doc, version, encoding, standalone);
        doc.xmldec = xmldec;
        return doc.root();
      };
      XMLNode.prototype.doctype = function(pubID, sysID) {
        var doc,
            doctype;
        doc = this.document();
        doctype = new XMLDocType(doc, pubID, sysID);
        doc.doctype = doctype;
        return doctype;
      };
      XMLNode.prototype.up = function() {
        if (this.isRoot) {
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        }
        return this.parent;
      };
      XMLNode.prototype.root = function() {
        var child;
        if (this.isRoot) {
          return this;
        }
        child = this.parent;
        while (!child.isRoot) {
          child = child.parent;
        }
        return child;
      };
      XMLNode.prototype.document = function() {
        return this.root().documentObject;
      };
      XMLNode.prototype.end = function(options) {
        return this.document().toString(options);
      };
      XMLNode.prototype.prev = function() {
        var i;
        if (this.isRoot) {
          throw new Error("Root node has no siblings");
        }
        i = this.parent.children.indexOf(this);
        if (i < 1) {
          throw new Error("Already at the first node");
        }
        return this.parent.children[i - 1];
      };
      XMLNode.prototype.next = function() {
        var i;
        if (this.isRoot) {
          throw new Error("Root node has no siblings");
        }
        i = this.parent.children.indexOf(this);
        if (i === -1 || i === this.parent.children.length - 1) {
          throw new Error("Already at the last node");
        }
        return this.parent.children[i + 1];
      };
      XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {
        var clonedRoot;
        clonedRoot = xmlbuilder.root().clone();
        clonedRoot.parent = this;
        clonedRoot.isRoot = false;
        this.children.push(clonedRoot);
        return this;
      };
      XMLNode.prototype.ele = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode.prototype.txt = function(value) {
        return this.text(value);
      };
      XMLNode.prototype.dat = function(value) {
        return this.cdata(value);
      };
      XMLNode.prototype.com = function(value) {
        return this.comment(value);
      };
      XMLNode.prototype.doc = function() {
        return this.document();
      };
      XMLNode.prototype.dec = function(version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLNode.prototype.dtd = function(pubID, sysID) {
        return this.doctype(pubID, sysID);
      };
      XMLNode.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode.prototype.t = function(value) {
        return this.text(value);
      };
      XMLNode.prototype.d = function(value) {
        return this.cdata(value);
      };
      XMLNode.prototype.c = function(value) {
        return this.comment(value);
      };
      XMLNode.prototype.r = function(value) {
        return this.raw(value);
      };
      XMLNode.prototype.u = function() {
        return this.up();
      };
      return XMLNode;
    })();
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/lang/isFunction.js", ["npm:lodash@3.10.1/lang/isObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:lodash@3.10.1/lang/isObject.js");
  var funcTag = '[object Function]';
  var objectProto = Object.prototype;
  var objToString = objectProto.toString;
  function isFunction(value) {
    return isObject(value) && objToString.call(value) == funcTag;
  }
  module.exports = isFunction;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/collection/every.js", ["npm:lodash@3.10.1/internal/arrayEvery.js", "npm:lodash@3.10.1/internal/baseCallback.js", "npm:lodash@3.10.1/internal/baseEvery.js", "npm:lodash@3.10.1/lang/isArray.js", "npm:lodash@3.10.1/internal/isIterateeCall.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var arrayEvery = require("npm:lodash@3.10.1/internal/arrayEvery.js"),
      baseCallback = require("npm:lodash@3.10.1/internal/baseCallback.js"),
      baseEvery = require("npm:lodash@3.10.1/internal/baseEvery.js"),
      isArray = require("npm:lodash@3.10.1/lang/isArray.js"),
      isIterateeCall = require("npm:lodash@3.10.1/internal/isIterateeCall.js");
  function every(collection, predicate, thisArg) {
    var func = isArray(collection) ? arrayEvery : baseEvery;
    if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
      predicate = undefined;
    }
    if (typeof predicate != 'function' || thisArg !== undefined) {
      predicate = baseCallback(predicate, thisArg, 3);
    }
    return func(collection, predicate);
  }
  module.exports = every;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLAttribute.js", ["npm:lodash@3.10.1/object/create.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLAttribute,
        create;
    create = require("npm:lodash@3.10.1/object/create.js");
    module.exports = XMLAttribute = (function() {
      function XMLAttribute(parent, name, value) {
        this.stringify = parent.stringify;
        if (name == null) {
          throw new Error("Missing attribute name of element " + parent.name);
        }
        if (value == null) {
          throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
        }
        this.name = this.stringify.attName(name);
        this.value = this.stringify.attValue(value);
      }
      XMLAttribute.prototype.clone = function() {
        return create(XMLAttribute.prototype, this);
      };
      XMLAttribute.prototype.toString = function(options, level) {
        return ' ' + this.name + '="' + this.value + '"';
      };
      return XMLAttribute;
    })();
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/lang/isArray.js", ["npm:lodash@3.10.1/internal/getNative.js", "npm:lodash@3.10.1/internal/isLength.js", "npm:lodash@3.10.1/internal/isObjectLike.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getNative = require("npm:lodash@3.10.1/internal/getNative.js"),
      isLength = require("npm:lodash@3.10.1/internal/isLength.js"),
      isObjectLike = require("npm:lodash@3.10.1/internal/isObjectLike.js");
  var arrayTag = '[object Array]';
  var objectProto = Object.prototype;
  var objToString = objectProto.toString;
  var nativeIsArray = getNative(Array, 'isArray');
  var isArray = nativeIsArray || function(value) {
    return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
  };
  module.exports = isArray;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLProcessingInstruction.js", ["npm:lodash@3.10.1/object/create.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLProcessingInstruction,
        create;
    create = require("npm:lodash@3.10.1/object/create.js");
    module.exports = XMLProcessingInstruction = (function() {
      function XMLProcessingInstruction(parent, target, value) {
        this.stringify = parent.stringify;
        if (target == null) {
          throw new Error("Missing instruction target");
        }
        this.target = this.stringify.insTarget(target);
        if (value) {
          this.value = this.stringify.insValue(value);
        }
      }
      XMLProcessingInstruction.prototype.clone = function() {
        return create(XMLProcessingInstruction.prototype, this);
      };
      XMLProcessingInstruction.prototype.toString = function(options, level) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += '<?';
        r += this.target;
        if (this.value) {
          r += ' ' + this.value;
        }
        r += '?>';
        if (pretty) {
          r += newline;
        }
        return r;
      };
      return XMLProcessingInstruction;
    })();
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLDTDEntity.js", ["npm:lodash@3.10.1/object/create.js", "npm:lodash@3.10.1/lang/isObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLDTDEntity,
        create,
        isObject;
    create = require("npm:lodash@3.10.1/object/create.js");
    isObject = require("npm:lodash@3.10.1/lang/isObject.js");
    module.exports = XMLDTDEntity = (function() {
      function XMLDTDEntity(parent, pe, name, value) {
        this.stringify = parent.stringify;
        if (name == null) {
          throw new Error("Missing entity name");
        }
        if (value == null) {
          throw new Error("Missing entity value");
        }
        this.pe = !!pe;
        this.name = this.stringify.eleName(name);
        if (!isObject(value)) {
          this.value = this.stringify.dtdEntityValue(value);
        } else {
          if (!value.pubID && !value.sysID) {
            throw new Error("Public and/or system identifiers are required for an external entity");
          }
          if (value.pubID && !value.sysID) {
            throw new Error("System identifier is required for a public external entity");
          }
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
          if (value.nData != null) {
            this.nData = this.stringify.dtdNData(value.nData);
          }
          if (this.pe && this.nData) {
            throw new Error("Notation declaration is not allowed in a parameter entity");
          }
        }
      }
      XMLDTDEntity.prototype.clone = function() {
        return create(XMLDTDEntity.prototype, this);
      };
      XMLDTDEntity.prototype.toString = function(options, level) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += '<!ENTITY';
        if (this.pe) {
          r += ' %';
        }
        r += ' ' + this.name;
        if (this.value) {
          r += ' "' + this.value + '"';
        } else {
          if (this.pubID && this.sysID) {
            r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
          } else if (this.sysID) {
            r += ' SYSTEM "' + this.sysID + '"';
          }
          if (this.nData) {
            r += ' NDATA ' + this.nData;
          }
        }
        r += '>';
        if (pretty) {
          r += newline;
        }
        return r;
      };
      return XMLDTDEntity;
    })();
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLDTDElement.js", ["npm:lodash@3.10.1/object/create.js", "npm:lodash@3.10.1/lang/isArray.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLDTDElement,
        create,
        isArray;
    create = require("npm:lodash@3.10.1/object/create.js");
    isArray = require("npm:lodash@3.10.1/lang/isArray.js");
    module.exports = XMLDTDElement = (function() {
      function XMLDTDElement(parent, name, value) {
        this.stringify = parent.stringify;
        if (name == null) {
          throw new Error("Missing DTD element name");
        }
        if (!value) {
          value = '(#PCDATA)';
        }
        if (isArray(value)) {
          value = '(' + value.join(',') + ')';
        }
        this.name = this.stringify.eleName(name);
        this.value = this.stringify.dtdElementValue(value);
      }
      XMLDTDElement.prototype.clone = function() {
        return create(XMLDTDElement.prototype, this);
      };
      XMLDTDElement.prototype.toString = function(options, level) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += '<!ELEMENT ' + this.name + ' ' + this.value + '>';
        if (pretty) {
          r += newline;
        }
        return r;
      };
      return XMLDTDElement;
    })();
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLDTDNotation.js", ["npm:lodash@3.10.1/object/create.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLDTDNotation,
        create;
    create = require("npm:lodash@3.10.1/object/create.js");
    module.exports = XMLDTDNotation = (function() {
      function XMLDTDNotation(parent, name, value) {
        this.stringify = parent.stringify;
        if (name == null) {
          throw new Error("Missing notation name");
        }
        if (!value.pubID && !value.sysID) {
          throw new Error("Public or system identifiers are required for an external entity");
        }
        this.name = this.stringify.eleName(name);
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
      }
      XMLDTDNotation.prototype.clone = function() {
        return create(XMLDTDNotation.prototype, this);
      };
      XMLDTDNotation.prototype.toString = function(options, level) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += '<!NOTATION ' + this.name;
        if (this.pubID && this.sysID) {
          r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
        } else if (this.pubID) {
          r += ' PUBLIC "' + this.pubID + '"';
        } else if (this.sysID) {
          r += ' SYSTEM "' + this.sysID + '"';
        }
        r += '>';
        if (pretty) {
          r += newline;
        }
        return r;
      };
      return XMLDTDNotation;
    })();
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLComment.js", ["npm:lodash@3.10.1/object/create.js", "npm:xmlbuilder@2.6.4/lib/XMLNode.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLComment,
        XMLNode,
        create,
        extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
    create = require("npm:lodash@3.10.1/object/create.js");
    XMLNode = require("npm:xmlbuilder@2.6.4/lib/XMLNode.js");
    module.exports = XMLComment = (function(superClass) {
      extend(XMLComment, superClass);
      function XMLComment(parent, text) {
        XMLComment.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing comment text");
        }
        this.text = this.stringify.comment(text);
      }
      XMLComment.prototype.clone = function() {
        return create(XMLComment.prototype, this);
      };
      XMLComment.prototype.toString = function(options, level) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += '<!-- ' + this.text + ' -->';
        if (pretty) {
          r += newline;
        }
        return r;
      };
      return XMLComment;
    })(XMLNode);
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLCData.js", ["npm:lodash@3.10.1/object/create.js", "npm:xmlbuilder@2.6.4/lib/XMLNode.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLCData,
        XMLNode,
        create,
        extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
    create = require("npm:lodash@3.10.1/object/create.js");
    XMLNode = require("npm:xmlbuilder@2.6.4/lib/XMLNode.js");
    module.exports = XMLCData = (function(superClass) {
      extend(XMLCData, superClass);
      function XMLCData(parent, text) {
        XMLCData.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing CDATA text");
        }
        this.text = this.stringify.cdata(text);
      }
      XMLCData.prototype.clone = function() {
        return create(XMLCData.prototype, this);
      };
      XMLCData.prototype.toString = function(options, level) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += '<![CDATA[' + this.text + ']]>';
        if (pretty) {
          r += newline;
        }
        return r;
      };
      return XMLCData;
    })(XMLNode);
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:string_decoder@0.10.31.js", ["npm:string_decoder@0.10.31/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:string_decoder@0.10.31/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:stream-browserify@1.0.0.js", ["npm:stream-browserify@1.0.0/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:stream-browserify@1.0.0/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLDTDAttList.js", ["npm:lodash@3.10.1/object/create.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLDTDAttList,
        create;
    create = require("npm:lodash@3.10.1/object/create.js");
    module.exports = XMLDTDAttList = (function() {
      function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        this.stringify = parent.stringify;
        if (elementName == null) {
          throw new Error("Missing DTD element name");
        }
        if (attributeName == null) {
          throw new Error("Missing DTD attribute name");
        }
        if (!attributeType) {
          throw new Error("Missing DTD attribute type");
        }
        if (!defaultValueType) {
          throw new Error("Missing DTD attribute default");
        }
        if (defaultValueType.indexOf('#') !== 0) {
          defaultValueType = '#' + defaultValueType;
        }
        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
        }
        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
          throw new Error("Default value only applies to #FIXED or #DEFAULT");
        }
        this.elementName = this.stringify.eleName(elementName);
        this.attributeName = this.stringify.attName(attributeName);
        this.attributeType = this.stringify.dtdAttType(attributeType);
        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
        this.defaultValueType = defaultValueType;
      }
      XMLDTDAttList.prototype.clone = function() {
        return create(XMLDTDAttList.prototype, this);
      };
      XMLDTDAttList.prototype.toString = function(options, level) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += '<!ATTLIST ' + this.elementName + ' ' + this.attributeName + ' ' + this.attributeType;
        if (this.defaultValueType !== '#DEFAULT') {
          r += ' ' + this.defaultValueType;
        }
        if (this.defaultValue) {
          r += ' "' + this.defaultValue + '"';
        }
        r += '>';
        if (pretty) {
          r += newline;
        }
        return r;
      };
      return XMLDTDAttList;
    })();
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/isArrayLike.js", ["npm:lodash@3.10.1/internal/getLength.js", "npm:lodash@3.10.1/internal/isLength.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getLength = require("npm:lodash@3.10.1/internal/getLength.js"),
      isLength = require("npm:lodash@3.10.1/internal/isLength.js");
  function isArrayLike(value) {
    return value != null && isLength(getLength(value));
  }
  module.exports = isArrayLike;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/isIndex.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var reIsUint = /^\d+$/;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isIndex(value, length) {
    value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return value > -1 && value % 1 == 0 && value < length;
  }
  module.exports = isIndex;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/utility/identity.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function identity(value) {
    return value;
  }
  module.exports = identity;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/getNative.js", ["npm:lodash@3.10.1/lang/isNative.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isNative = require("npm:lodash@3.10.1/lang/isNative.js");
  function getNative(object, key) {
    var value = object == null ? undefined : object[key];
    return isNative(value) ? value : undefined;
  }
  module.exports = getNative;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseCreate.js", ["npm:lodash@3.10.1/lang/isObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:lodash@3.10.1/lang/isObject.js");
  var baseCreate = (function() {
    function object() {}
    return function(prototype) {
      if (isObject(prototype)) {
        object.prototype = prototype;
        var result = new object;
        object.prototype = undefined;
      }
      return result || {};
    };
  }());
  module.exports = baseCreate;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/shimKeys.js", ["npm:lodash@3.10.1/lang/isArguments.js", "npm:lodash@3.10.1/lang/isArray.js", "npm:lodash@3.10.1/internal/isIndex.js", "npm:lodash@3.10.1/internal/isLength.js", "npm:lodash@3.10.1/object/keysIn.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArguments = require("npm:lodash@3.10.1/lang/isArguments.js"),
      isArray = require("npm:lodash@3.10.1/lang/isArray.js"),
      isIndex = require("npm:lodash@3.10.1/internal/isIndex.js"),
      isLength = require("npm:lodash@3.10.1/internal/isLength.js"),
      keysIn = require("npm:lodash@3.10.1/object/keysIn.js");
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function shimKeys(object) {
    var props = keysIn(object),
        propsLength = props.length,
        length = propsLength && object.length;
    var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
    var index = -1,
        result = [];
    while (++index < propsLength) {
      var key = props[index];
      if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
        result.push(key);
      }
    }
    return result;
  }
  module.exports = shimKeys;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/lang/isEmpty.js", ["npm:lodash@3.10.1/lang/isArguments.js", "npm:lodash@3.10.1/lang/isArray.js", "npm:lodash@3.10.1/internal/isArrayLike.js", "npm:lodash@3.10.1/lang/isFunction.js", "npm:lodash@3.10.1/internal/isObjectLike.js", "npm:lodash@3.10.1/lang/isString.js", "npm:lodash@3.10.1/object/keys.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArguments = require("npm:lodash@3.10.1/lang/isArguments.js"),
      isArray = require("npm:lodash@3.10.1/lang/isArray.js"),
      isArrayLike = require("npm:lodash@3.10.1/internal/isArrayLike.js"),
      isFunction = require("npm:lodash@3.10.1/lang/isFunction.js"),
      isObjectLike = require("npm:lodash@3.10.1/internal/isObjectLike.js"),
      isString = require("npm:lodash@3.10.1/lang/isString.js"),
      keys = require("npm:lodash@3.10.1/object/keys.js");
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
      return !value.length;
    }
    return !keys(value).length;
  }
  module.exports = isEmpty;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLText.js", ["npm:lodash@3.10.1/object/create.js", "npm:xmlbuilder@2.6.4/lib/XMLNode.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLNode,
        XMLText,
        create,
        extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
    create = require("npm:lodash@3.10.1/object/create.js");
    XMLNode = require("npm:xmlbuilder@2.6.4/lib/XMLNode.js");
    module.exports = XMLText = (function(superClass) {
      extend(XMLText, superClass);
      function XMLText(parent, text) {
        XMLText.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing element text");
        }
        this.value = this.stringify.eleText(text);
      }
      XMLText.prototype.clone = function() {
        return create(XMLText.prototype, this);
      };
      XMLText.prototype.toString = function(options, level) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += this.value;
        if (pretty) {
          r += newline;
        }
        return r;
      };
      return XMLText;
    })(XMLNode);
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:xmlbuilder@2.6.4/lib/XMLRaw.js", ["npm:lodash@3.10.1/object/create.js", "npm:xmlbuilder@2.6.4/lib/XMLNode.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    var XMLNode,
        XMLRaw,
        create,
        extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
    create = require("npm:lodash@3.10.1/object/create.js");
    XMLNode = require("npm:xmlbuilder@2.6.4/lib/XMLNode.js");
    module.exports = XMLRaw = (function(superClass) {
      extend(XMLRaw, superClass);
      function XMLRaw(parent, text) {
        XMLRaw.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing raw text");
        }
        this.value = this.stringify.raw(text);
      }
      XMLRaw.prototype.clone = function() {
        return create(XMLRaw.prototype, this);
      };
      XMLRaw.prototype.toString = function(options, level) {
        var indent,
            newline,
            offset,
            pretty,
            r,
            ref,
            ref1,
            ref2,
            space;
        pretty = (options != null ? options.pretty : void 0) || false;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
        level || (level = 0);
        space = new Array(level + offset + 1).join(indent);
        r = '';
        if (pretty) {
          r += space;
        }
        r += this.value;
        if (pretty) {
          r += newline;
        }
        return r;
      };
      return XMLRaw;
    })(XMLNode);
  }).call(this);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseEvery.js", ["npm:lodash@3.10.1/internal/baseEach.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseEach = require("npm:lodash@3.10.1/internal/baseEach.js");
  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function(value, index, collection) {
      result = !!predicate(value, index, collection);
      return result;
    });
    return result;
  }
  module.exports = baseEvery;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/arrayEvery.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array.length;
    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }
  module.exports = arrayEvery;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseCallback.js", ["npm:lodash@3.10.1/internal/baseMatches.js", "npm:lodash@3.10.1/internal/baseMatchesProperty.js", "npm:lodash@3.10.1/internal/bindCallback.js", "npm:lodash@3.10.1/utility/identity.js", "npm:lodash@3.10.1/utility/property.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseMatches = require("npm:lodash@3.10.1/internal/baseMatches.js"),
      baseMatchesProperty = require("npm:lodash@3.10.1/internal/baseMatchesProperty.js"),
      bindCallback = require("npm:lodash@3.10.1/internal/bindCallback.js"),
      identity = require("npm:lodash@3.10.1/utility/identity.js"),
      property = require("npm:lodash@3.10.1/utility/property.js");
  function baseCallback(func, thisArg, argCount) {
    var type = typeof func;
    if (type == 'function') {
      return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
    }
    if (func == null) {
      return identity;
    }
    if (type == 'object') {
      return baseMatches(func);
    }
    return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
  }
  module.exports = baseCallback;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/isObjectLike.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  module.exports = isObjectLike;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/isLength.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  module.exports = isLength;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:string_decoder@0.10.31/index.js", ["github:jspm/nodelibs-buffer@0.1.0.js", "github:jspm/nodelibs-buffer@0.1.0.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var Buffer = require("github:jspm/nodelibs-buffer@0.1.0.js").Buffer;
    var isBufferEncoding = Buffer.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      while (this.charLength) {
        var available = (buffer.length >= this.charLength - this.charReceived) ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return '';
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = (buffer.length >= 3) ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0.js").Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:stream-browserify@1.0.0/index.js", ["github:jspm/nodelibs-events@0.1.1.js", "npm:inherits@2.0.1.js", "npm:readable-stream@1.1.13/readable.js", "npm:readable-stream@1.1.13/writable.js", "npm:readable-stream@1.1.13/duplex.js", "npm:readable-stream@1.1.13/transform.js", "npm:readable-stream@1.1.13/passthrough.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Stream;
  var EE = require("github:jspm/nodelibs-events@0.1.1.js").EventEmitter;
  var inherits = require("npm:inherits@2.0.1.js");
  inherits(Stream, EE);
  Stream.Readable = require("npm:readable-stream@1.1.13/readable.js");
  Stream.Writable = require("npm:readable-stream@1.1.13/writable.js");
  Stream.Duplex = require("npm:readable-stream@1.1.13/duplex.js");
  Stream.Transform = require("npm:readable-stream@1.1.13/transform.js");
  Stream.PassThrough = require("npm:readable-stream@1.1.13/passthrough.js");
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on('data', ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on('drain', ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === 'function')
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, 'error') === 0) {
        throw er;
      }
    }
    source.on('error', onerror);
    dest.on('error', onerror);
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);
      source.removeListener('end', onend);
      source.removeListener('close', onclose);
      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);
      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);
      dest.removeListener('close', cleanup);
    }
    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source);
    return dest;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/getLength.js", ["npm:lodash@3.10.1/internal/baseProperty.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseProperty = require("npm:lodash@3.10.1/internal/baseProperty.js");
  var getLength = baseProperty('length');
  module.exports = getLength;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/lang/isNative.js", ["npm:lodash@3.10.1/lang/isFunction.js", "npm:lodash@3.10.1/internal/isObjectLike.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isFunction = require("npm:lodash@3.10.1/lang/isFunction.js"),
      isObjectLike = require("npm:lodash@3.10.1/internal/isObjectLike.js");
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var objectProto = Object.prototype;
  var fnToString = Function.prototype.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  function isNative(value) {
    if (value == null) {
      return false;
    }
    if (isFunction(value)) {
      return reIsNative.test(fnToString.call(value));
    }
    return isObjectLike(value) && reIsHostCtor.test(value);
  }
  module.exports = isNative;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/object/keysIn.js", ["npm:lodash@3.10.1/lang/isArguments.js", "npm:lodash@3.10.1/lang/isArray.js", "npm:lodash@3.10.1/internal/isIndex.js", "npm:lodash@3.10.1/internal/isLength.js", "npm:lodash@3.10.1/lang/isObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArguments = require("npm:lodash@3.10.1/lang/isArguments.js"),
      isArray = require("npm:lodash@3.10.1/lang/isArray.js"),
      isIndex = require("npm:lodash@3.10.1/internal/isIndex.js"),
      isLength = require("npm:lodash@3.10.1/internal/isLength.js"),
      isObject = require("npm:lodash@3.10.1/lang/isObject.js");
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function keysIn(object) {
    if (object == null) {
      return [];
    }
    if (!isObject(object)) {
      object = Object(object);
    }
    var length = object.length;
    length = (length && isLength(length) && (isArray(object) || isArguments(object)) && length) || 0;
    var Ctor = object.constructor,
        index = -1,
        isProto = typeof Ctor == 'function' && Ctor.prototype === object,
        result = Array(length),
        skipIndexes = length > 0;
    while (++index < length) {
      result[index] = (index + '');
    }
    for (var key in object) {
      if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  module.exports = keysIn;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/lang/isArguments.js", ["npm:lodash@3.10.1/internal/isArrayLike.js", "npm:lodash@3.10.1/internal/isObjectLike.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArrayLike = require("npm:lodash@3.10.1/internal/isArrayLike.js"),
      isObjectLike = require("npm:lodash@3.10.1/internal/isObjectLike.js");
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  function isArguments(value) {
    return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  }
  module.exports = isArguments;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/lang/isString.js", ["npm:lodash@3.10.1/internal/isObjectLike.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObjectLike = require("npm:lodash@3.10.1/internal/isObjectLike.js");
  var stringTag = '[object String]';
  var objectProto = Object.prototype;
  var objToString = objectProto.toString;
  function isString(value) {
    return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
  }
  module.exports = isString;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseEach.js", ["npm:lodash@3.10.1/internal/baseForOwn.js", "npm:lodash@3.10.1/internal/createBaseEach.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseForOwn = require("npm:lodash@3.10.1/internal/baseForOwn.js"),
      createBaseEach = require("npm:lodash@3.10.1/internal/createBaseEach.js");
  var baseEach = createBaseEach(baseForOwn);
  module.exports = baseEach;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/utility/property.js", ["npm:lodash@3.10.1/internal/baseProperty.js", "npm:lodash@3.10.1/internal/basePropertyDeep.js", "npm:lodash@3.10.1/internal/isKey.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseProperty = require("npm:lodash@3.10.1/internal/baseProperty.js"),
      basePropertyDeep = require("npm:lodash@3.10.1/internal/basePropertyDeep.js"),
      isKey = require("npm:lodash@3.10.1/internal/isKey.js");
  function property(path) {
    return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
  }
  module.exports = property;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseMatches.js", ["npm:lodash@3.10.1/internal/baseIsMatch.js", "npm:lodash@3.10.1/internal/getMatchData.js", "npm:lodash@3.10.1/internal/toObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseIsMatch = require("npm:lodash@3.10.1/internal/baseIsMatch.js"),
      getMatchData = require("npm:lodash@3.10.1/internal/getMatchData.js"),
      toObject = require("npm:lodash@3.10.1/internal/toObject.js");
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      var key = matchData[0][0],
          value = matchData[0][1];
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === value && (value !== undefined || (key in toObject(object)));
      };
    }
    return function(object) {
      return baseIsMatch(object, matchData);
    };
  }
  module.exports = baseMatches;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseMatchesProperty.js", ["npm:lodash@3.10.1/internal/baseGet.js", "npm:lodash@3.10.1/internal/baseIsEqual.js", "npm:lodash@3.10.1/internal/baseSlice.js", "npm:lodash@3.10.1/lang/isArray.js", "npm:lodash@3.10.1/internal/isKey.js", "npm:lodash@3.10.1/internal/isStrictComparable.js", "npm:lodash@3.10.1/array/last.js", "npm:lodash@3.10.1/internal/toObject.js", "npm:lodash@3.10.1/internal/toPath.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseGet = require("npm:lodash@3.10.1/internal/baseGet.js"),
      baseIsEqual = require("npm:lodash@3.10.1/internal/baseIsEqual.js"),
      baseSlice = require("npm:lodash@3.10.1/internal/baseSlice.js"),
      isArray = require("npm:lodash@3.10.1/lang/isArray.js"),
      isKey = require("npm:lodash@3.10.1/internal/isKey.js"),
      isStrictComparable = require("npm:lodash@3.10.1/internal/isStrictComparable.js"),
      last = require("npm:lodash@3.10.1/array/last.js"),
      toObject = require("npm:lodash@3.10.1/internal/toObject.js"),
      toPath = require("npm:lodash@3.10.1/internal/toPath.js");
  function baseMatchesProperty(path, srcValue) {
    var isArr = isArray(path),
        isCommon = isKey(path) && isStrictComparable(srcValue),
        pathKey = (path + '');
    path = toPath(path);
    return function(object) {
      if (object == null) {
        return false;
      }
      var key = pathKey;
      object = toObject(object);
      if ((isArr || !isCommon) && !(key in object)) {
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        key = last(path);
        object = toObject(object);
      }
      return object[key] === srcValue ? (srcValue !== undefined || (key in object)) : baseIsEqual(srcValue, object[key], undefined, true);
    };
  }
  module.exports = baseMatchesProperty;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/writable.js", ["npm:readable-stream@1.1.13/lib/_stream_writable.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:readable-stream@1.1.13/lib/_stream_writable.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/passthrough.js", ["npm:readable-stream@1.1.13/lib/_stream_passthrough.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:readable-stream@1.1.13/lib/_stream_passthrough.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/duplex.js", ["npm:readable-stream@1.1.13/lib/_stream_duplex.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:readable-stream@1.1.13/lib/_stream_duplex.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/transform.js", ["npm:readable-stream@1.1.13/lib/_stream_transform.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:readable-stream@1.1.13/lib/_stream_transform.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/readable.js", ["npm:readable-stream@1.1.13/lib/_stream_readable.js", "npm:stream-browserify@1.0.0/index.js", "npm:readable-stream@1.1.13/lib/_stream_writable.js", "npm:readable-stream@1.1.13/lib/_stream_duplex.js", "npm:readable-stream@1.1.13/lib/_stream_transform.js", "npm:readable-stream@1.1.13/lib/_stream_passthrough.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = require("npm:readable-stream@1.1.13/lib/_stream_readable.js");
  exports.Stream = require("npm:stream-browserify@1.0.0/index.js");
  exports.Readable = exports;
  exports.Writable = require("npm:readable-stream@1.1.13/lib/_stream_writable.js");
  exports.Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex.js");
  exports.Transform = require("npm:readable-stream@1.1.13/lib/_stream_transform.js");
  exports.PassThrough = require("npm:readable-stream@1.1.13/lib/_stream_passthrough.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseProperty.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }
  module.exports = baseProperty;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/createBaseEach.js", ["npm:lodash@3.10.1/internal/getLength.js", "npm:lodash@3.10.1/internal/isLength.js", "npm:lodash@3.10.1/internal/toObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getLength = require("npm:lodash@3.10.1/internal/getLength.js"),
      isLength = require("npm:lodash@3.10.1/internal/isLength.js"),
      toObject = require("npm:lodash@3.10.1/internal/toObject.js");
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        return eachFunc(collection, iteratee);
      }
      var index = fromRight ? length : -1,
          iterable = toObject(collection);
      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  module.exports = createBaseEach;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseForOwn.js", ["npm:lodash@3.10.1/internal/baseFor.js", "npm:lodash@3.10.1/object/keys.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseFor = require("npm:lodash@3.10.1/internal/baseFor.js"),
      keys = require("npm:lodash@3.10.1/object/keys.js");
  function baseForOwn(object, iteratee) {
    return baseFor(object, iteratee, keys);
  }
  module.exports = baseForOwn;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/toObject.js", ["npm:lodash@3.10.1/lang/isObject.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var isObject = require("npm:lodash@3.10.1/lang/isObject.js");
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }
    module.exports = toObject;
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/basePropertyDeep.js", ["npm:lodash@3.10.1/internal/baseGet.js", "npm:lodash@3.10.1/internal/toPath.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseGet = require("npm:lodash@3.10.1/internal/baseGet.js"),
      toPath = require("npm:lodash@3.10.1/internal/toPath.js");
  function basePropertyDeep(path) {
    var pathKey = (path + '');
    path = toPath(path);
    return function(object) {
      return baseGet(object, path, pathKey);
    };
  }
  module.exports = basePropertyDeep;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/getMatchData.js", ["npm:lodash@3.10.1/internal/isStrictComparable.js", "npm:lodash@3.10.1/object/pairs.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isStrictComparable = require("npm:lodash@3.10.1/internal/isStrictComparable.js"),
      pairs = require("npm:lodash@3.10.1/object/pairs.js");
  function getMatchData(object) {
    var result = pairs(object),
        length = result.length;
    while (length--) {
      result[length][2] = isStrictComparable(result[length][1]);
    }
    return result;
  }
  module.exports = getMatchData;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/isKey.js", ["npm:lodash@3.10.1/lang/isArray.js", "npm:lodash@3.10.1/internal/toObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArray = require("npm:lodash@3.10.1/lang/isArray.js"),
      toObject = require("npm:lodash@3.10.1/internal/toObject.js");
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    var type = typeof value;
    if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
      return true;
    }
    if (isArray(value)) {
      return false;
    }
    var result = !reIsDeepProp.test(value);
    return result || (object != null && value in toObject(object));
  }
  module.exports = isKey;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseIsMatch.js", ["npm:lodash@3.10.1/internal/baseIsEqual.js", "npm:lodash@3.10.1/internal/toObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseIsEqual = require("npm:lodash@3.10.1/internal/baseIsEqual.js"),
      toObject = require("npm:lodash@3.10.1/internal/toObject.js");
  function baseIsMatch(object, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = toObject(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var result = customizer ? customizer(objValue, srcValue, key) : undefined;
        if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  module.exports = baseIsMatch;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseIsEqual.js", ["npm:lodash@3.10.1/internal/baseIsEqualDeep.js", "npm:lodash@3.10.1/lang/isObject.js", "npm:lodash@3.10.1/internal/isObjectLike.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseIsEqualDeep = require("npm:lodash@3.10.1/internal/baseIsEqualDeep.js"),
      isObject = require("npm:lodash@3.10.1/lang/isObject.js"),
      isObjectLike = require("npm:lodash@3.10.1/internal/isObjectLike.js");
  function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
  }
  module.exports = baseIsEqual;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseSlice.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;
    start = start == null ? 0 : (+start || 0);
    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = (end === undefined || end > length) ? length : (+end || 0);
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  module.exports = baseSlice;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/isStrictComparable.js", ["npm:lodash@3.10.1/lang/isObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = require("npm:lodash@3.10.1/lang/isObject.js");
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  module.exports = isStrictComparable;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseGet.js", ["npm:lodash@3.10.1/internal/toObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = require("npm:lodash@3.10.1/internal/toObject.js");
  function baseGet(object, path, pathKey) {
    if (object == null) {
      return;
    }
    if (pathKey !== undefined && pathKey in toObject(object)) {
      path = [pathKey];
    }
    var index = 0,
        length = path.length;
    while (object != null && index < length) {
      object = object[path[index++]];
    }
    return (index && index == length) ? object : undefined;
  }
  module.exports = baseGet;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/array/last.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function last(array) {
    var length = array ? array.length : 0;
    return length ? array[length - 1] : undefined;
  }
  module.exports = last;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/toPath.js", ["npm:lodash@3.10.1/internal/baseToString.js", "npm:lodash@3.10.1/lang/isArray.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var baseToString = require("npm:lodash@3.10.1/internal/baseToString.js"),
        isArray = require("npm:lodash@3.10.1/lang/isArray.js");
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
    var reEscapeChar = /\\(\\)?/g;
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }
    module.exports = toPath;
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/lib/_stream_passthrough.js", ["npm:readable-stream@1.1.13/lib/_stream_transform.js", "npm:core-util-is@1.0.1.js", "npm:inherits@2.0.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = PassThrough;
  var Transform = require("npm:readable-stream@1.1.13/lib/_stream_transform.js");
  var util = require("npm:core-util-is@1.0.1.js");
  util.inherits = require("npm:inherits@2.0.1.js");
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/lib/_stream_transform.js", ["npm:readable-stream@1.1.13/lib/_stream_duplex.js", "npm:core-util-is@1.0.1.js", "npm:inherits@2.0.1.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    module.exports = Transform;
    var Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex.js");
    var util = require("npm:core-util-is@1.0.1.js");
    util.inherits = require("npm:inherits@2.0.1.js");
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (!util.isNullOrUndefined(data))
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once('prefinish', function() {
        if (util.isFunction(this._flush))
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
      return stream.push(null);
    }
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/lib/_stream_duplex.js", ["npm:core-util-is@1.0.1.js", "npm:inherits@2.0.1.js", "npm:readable-stream@1.1.13/lib/_stream_readable.js", "npm:readable-stream@1.1.13/lib/_stream_writable.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    module.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util = require("npm:core-util-is@1.0.1.js");
    util.inherits = require("npm:inherits@2.0.1.js");
    var Readable = require("npm:readable-stream@1.1.13/lib/_stream_readable.js");
    var Writable = require("npm:readable-stream@1.1.13/lib/_stream_writable.js");
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/lib/_stream_writable.js", ["github:jspm/nodelibs-buffer@0.1.0.js", "npm:core-util-is@1.0.1.js", "npm:inherits@2.0.1.js", "npm:stream-browserify@1.0.0/index.js", "npm:readable-stream@1.1.13/lib/_stream_duplex.js", "npm:readable-stream@1.1.13/lib/_stream_duplex.js", "github:jspm/nodelibs-buffer@0.1.0.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports = Writable;
    var Buffer = require("github:jspm/nodelibs-buffer@0.1.0.js").Buffer;
    Writable.WritableState = WritableState;
    var util = require("npm:core-util-is@1.0.1.js");
    util.inherits = require("npm:inherits@2.0.1.js");
    var Stream = require("npm:stream-browserify@1.0.0/index.js");
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      var Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex.js");
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex.js");
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (util.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (!util.isFunction(cb))
        cb = function() {};
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(this, state);
      }
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (util.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, false, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          state.pendingcb--;
          cb(er);
        });
      else {
        state.pendingcb--;
        cb(er);
      }
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      if (stream._writev && state.buffer.length > 1) {
        var cbs = [];
        for (var c = 0; c < state.buffer.length; c++)
          cbs.push(state.buffer[c].callback);
        state.pendingcb++;
        doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
        state.buffer = [];
      } else {
        for (var c = 0; c < state.buffer.length; c++) {
          var entry = state.buffer[c];
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          if (state.writing) {
            c++;
            break;
          }
        }
        if (c < state.buffer.length)
          state.buffer = state.buffer.slice(c);
        else
          state.buffer.length = 0;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (util.isFunction(chunk)) {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (!util.isNullOrUndefined(chunk))
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return (state.ending && state.length === 0 && !state.finished && !state.writing);
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else
          prefinish(stream, state);
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0.js").Buffer, require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseFor.js", ["npm:lodash@3.10.1/internal/createBaseFor.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var createBaseFor = require("npm:lodash@3.10.1/internal/createBaseFor.js");
  var baseFor = createBaseFor();
  module.exports = baseFor;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:readable-stream@1.1.13/lib/_stream_readable.js", ["npm:isarray@0.0.1.js", "github:jspm/nodelibs-buffer@0.1.0.js", "github:jspm/nodelibs-events@0.1.1.js", "npm:stream-browserify@1.0.0/index.js", "npm:core-util-is@1.0.1.js", "npm:inherits@2.0.1.js", "@empty", "npm:readable-stream@1.1.13/lib/_stream_duplex.js", "npm:string_decoder@0.10.31.js", "npm:readable-stream@1.1.13/lib/_stream_duplex.js", "npm:string_decoder@0.10.31.js", "github:jspm/nodelibs-buffer@0.1.0.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports = Readable;
    var isArray = require("npm:isarray@0.0.1.js");
    var Buffer = require("github:jspm/nodelibs-buffer@0.1.0.js").Buffer;
    Readable.ReadableState = ReadableState;
    var EE = require("github:jspm/nodelibs-events@0.1.1.js").EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = require("npm:stream-browserify@1.0.0/index.js");
    var util = require("npm:core-util-is@1.0.1.js");
    util.inherits = require("npm:inherits@2.0.1.js");
    var StringDecoder;
    var debug = require("@empty");
    if (debug && debug.debuglog) {
      debug = debug.debuglog('stream');
    } else {
      debug = function() {};
    }
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      var Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex.js");
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require("npm:string_decoder@0.10.31.js").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      var Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex.js");
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (util.isString(chunk) && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (util.isNullOrUndefined(chunk)) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          if (!addToFront)
            state.reading = false;
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("npm:string_decoder@0.10.31.js").StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (isNaN(n) || util.isNull(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
      if (!util.isNumber(n) || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug('need readable', doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (util.isNull(ret)) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
      if (!util.isNull(ret))
        this.emit('data', ret);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          process.nextTick(function() {
            emitReadable_(stream);
          });
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug('onend');
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      function cleanup() {
        debug('cleanup');
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          debug('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
      dest.emit('pipe', src);
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit('unpipe', this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            var self = this;
            process.nextTick(function() {
              debug('readable nexttick read 0');
              self.read(0);
            });
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        if (!state.reading) {
          debug('resume read 0');
          this.read(0);
        }
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(function() {
          resume_(stream, state);
        });
      }
    }
    function resume_(stream, state) {
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
        self.push(null);
      });
      stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (!chunk || !state.objectMode && !chunk.length)
          return;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
          var c = 0;
          for (var i = 0,
              l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0.js").Buffer, require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/object/pairs.js", ["npm:lodash@3.10.1/object/keys.js", "npm:lodash@3.10.1/internal/toObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var keys = require("npm:lodash@3.10.1/object/keys.js"),
      toObject = require("npm:lodash@3.10.1/internal/toObject.js");
  function pairs(object) {
    object = toObject(object);
    var index = -1,
        props = keys(object),
        length = props.length,
        result = Array(length);
    while (++index < length) {
      var key = props[index];
      result[index] = [key, object[key]];
    }
    return result;
  }
  module.exports = pairs;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseIsEqualDeep.js", ["npm:lodash@3.10.1/internal/equalArrays.js", "npm:lodash@3.10.1/internal/equalByTag.js", "npm:lodash@3.10.1/internal/equalObjects.js", "npm:lodash@3.10.1/lang/isArray.js", "npm:lodash@3.10.1/lang/isTypedArray.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var equalArrays = require("npm:lodash@3.10.1/internal/equalArrays.js"),
      equalByTag = require("npm:lodash@3.10.1/internal/equalByTag.js"),
      equalObjects = require("npm:lodash@3.10.1/internal/equalObjects.js"),
      isArray = require("npm:lodash@3.10.1/lang/isArray.js"),
      isTypedArray = require("npm:lodash@3.10.1/lang/isTypedArray.js");
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag = '[object Object]';
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objToString = objectProto.toString;
  function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = arrayTag,
        othTag = arrayTag;
    if (!objIsArr) {
      objTag = objToString.call(object);
      if (objTag == argsTag) {
        objTag = objectTag;
      } else if (objTag != objectTag) {
        objIsArr = isTypedArray(object);
      }
    }
    if (!othIsArr) {
      othTag = objToString.call(other);
      if (othTag == argsTag) {
        othTag = objectTag;
      } else if (othTag != objectTag) {
        othIsArr = isTypedArray(other);
      }
    }
    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;
    if (isSameTag && !(objIsArr || objIsObj)) {
      return equalByTag(object, other, objTag);
    }
    if (!isLoose) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
      if (objIsWrapped || othIsWrapped) {
        return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stackA || (stackA = []);
    stackB || (stackB = []);
    var length = stackA.length;
    while (length--) {
      if (stackA[length] == object) {
        return stackB[length] == other;
      }
    }
    stackA.push(object);
    stackB.push(other);
    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
    stackA.pop();
    stackB.pop();
    return result;
  }
  module.exports = baseIsEqualDeep;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/baseToString.js", ["github:jspm/nodelibs-process@0.1.1.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    function baseToString(value) {
      return value == null ? '' : (value + '');
    }
    module.exports = baseToString;
  })(require("github:jspm/nodelibs-process@0.1.1.js"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-util-is@1.0.1.js", ["npm:core-util-is@1.0.1/lib/util.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:core-util-is@1.0.1/lib/util.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/createBaseFor.js", ["npm:lodash@3.10.1/internal/toObject.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = require("npm:lodash@3.10.1/internal/toObject.js");
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var iterable = toObject(object),
          props = keysFunc(object),
          length = props.length,
          index = fromRight ? length : -1;
      while ((fromRight ? index-- : ++index < length)) {
        var key = props[index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  module.exports = createBaseFor;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:isarray@0.0.1.js", ["npm:isarray@0.0.1/index.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:isarray@0.0.1/index.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/lang/isTypedArray.js", ["npm:lodash@3.10.1/internal/isLength.js", "npm:lodash@3.10.1/internal/isObjectLike.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isLength = require("npm:lodash@3.10.1/internal/isLength.js"),
      isObjectLike = require("npm:lodash@3.10.1/internal/isObjectLike.js");
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var objectProto = Object.prototype;
  var objToString = objectProto.toString;
  function isTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
  }
  module.exports = isTypedArray;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/equalArrays.js", ["npm:lodash@3.10.1/internal/arraySome.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var arraySome = require("npm:lodash@3.10.1/internal/arraySome.js");
  function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
    var index = -1,
        arrLength = array.length,
        othLength = other.length;
    if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
      return false;
    }
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index],
          result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
      if (result !== undefined) {
        if (result) {
          continue;
        }
        return false;
      }
      if (isLoose) {
        if (!arraySome(other, function(othValue) {
          return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
        })) {
          return false;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
        return false;
      }
    }
    return true;
  }
  module.exports = equalArrays;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/equalObjects.js", ["npm:lodash@3.10.1/object/keys.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var keys = require("npm:lodash@3.10.1/object/keys.js");
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
    var objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;
    if (objLength != othLength && !isLoose) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var skipCtor = isLoose;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key],
          result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
      if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
        return false;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (!skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;
      if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        return false;
      }
    }
    return true;
  }
  module.exports = equalObjects;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/equalByTag.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      numberTag = '[object Number]',
      regexpTag = '[object RegExp]',
      stringTag = '[object String]';
  function equalByTag(object, other, tag) {
    switch (tag) {
      case boolTag:
      case dateTag:
        return +object == +other;
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case numberTag:
        return (object != +object) ? other != +other : object == +other;
      case regexpTag:
      case stringTag:
        return object == (other + '');
    }
    return false;
  }
  module.exports = equalByTag;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:isarray@0.0.1/index.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Array.isArray || function(arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-util-is@1.0.1/lib/util.js", ["github:jspm/nodelibs-buffer@0.1.0.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    function isBuffer(arg) {
      return Buffer.isBuffer(arg);
    }
    exports.isBuffer = isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0.js").Buffer);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/internal/arraySome.js", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function arraySome(array, predicate) {
    var index = -1,
        length = array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  module.exports = arraySome;
  global.define = __define;
  return module.exports;
});

//# sourceMappingURL=build.js.map